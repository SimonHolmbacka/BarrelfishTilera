/*
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * INTERFACE NAME: intermon
 * INTEFACE FILE: /home/andreas/barrelfish/new_test2/if/intermon.if
 * INTERFACE DESCRIPTION: The Interface between monitors
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr.6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY FLOUNDER: DO NOT EDIT!
 */

#include <barrelfish/barrelfish.h>
#include <flounder/flounder_support.h>
#include <if/intermon_defs.h>

/*
 * Export function
 */
 errval_t intermon_export(void *st, idc_export_callback_fn *export_cb, intermon_connect_fn *connect_cb, struct waitset *ws, idc_export_flags_t flags)
{
    struct intermon_export *e = malloc(sizeof(struct intermon_export ));
    if (e == NULL) {
        return(LIB_ERR_MALLOC_FAIL);
    }
    
    // fill in common parts of export struct
    e->connect_cb = connect_cb;
    e->waitset = ws;
    e->st = st;
    (e->common).export_callback = export_cb;
    (e->common).flags = flags;
    (e->common).connect_cb_st = e;
    (e->common).export_cb_st = st;
    
    // fill in connect handler for each enabled backend
    #ifdef CONFIG_FLOUNDER_BACKEND_LMP
    (e->common).lmp_connect_callback = intermon_lmp_connect_handler;
    #endif // CONFIG_FLOUNDER_BACKEND_LMP
    #ifdef CONFIG_FLOUNDER_BACKEND_UMP
    (e->common).ump_connect_callback = intermon_ump_connect_handler;
    #endif // CONFIG_FLOUNDER_BACKEND_UMP
    #ifdef CONFIG_FLOUNDER_BACKEND_UMP_IPI
    (e->common).ump_connect_callback = intermon_ump_ipi_connect_handler;
    #endif // CONFIG_FLOUNDER_BACKEND_UMP_IPI
    #ifdef CONFIG_FLOUNDER_BACKEND_MULTIHOP
    (e->common).multihop_connect_callback = intermon_multihop_connect_handler;
    #endif // CONFIG_FLOUNDER_BACKEND_MULTIHOP
    #ifdef CONFIG_FLOUNDER_BACKEND_UDN
    (e->common).udn_connect_callback = intermon_udn_connect_handler;
    #endif // CONFIG_FLOUNDER_BACKEND_UDN
    
    return(idc_export_service(&(e->common)));
}


/*
 * Generic bind function
 */
static  void intermon_bind_continuation_direct(void *st, errval_t err, struct intermon_binding *_binding)
{
    // This bind cont function uses the different backends in the following order:
    // lmp ump_ipi ump multihop udn
    
    struct flounder_generic_bind_attempt *b = st;
    switch (b->driver_num) {
    case 0:
        (b->driver_num)++;
        #ifdef CONFIG_FLOUNDER_BACKEND_LMP
        // try next backend
        b->binding = malloc(sizeof(struct intermon_lmp_binding ));
        assert((b->binding) != NULL);
        err = intermon_lmp_bind(b->binding, b->iref, intermon_bind_continuation_direct, b, b->waitset, b->flags, DEFAULT_LMP_BUF_WORDS);
        if (err_is_fail(err)) {
            free(b->binding);
            _binding = NULL;
            goto out;
        } else {
            return;
        }
        #else
        // skip non-enabled backend (fall through)
        #endif // CONFIG_FLOUNDER_BACKEND_LMP
    case 1:
        #ifdef CONFIG_FLOUNDER_BACKEND_LMP
        if (err_is_ok(err)) {
            goto out;
        } else {
            free(b->binding);
            if (err_no(err) == MON_ERR_IDC_BIND_NOT_SAME_CORE) {
                goto try_next_1;
            } else {
                // report permanent failure to user
                _binding = NULL;
                goto out;
            }
        }
        try_next_1:
        #endif // CONFIG_FLOUNDER_BACKEND_LMP
        (b->driver_num)++;
        #ifdef CONFIG_FLOUNDER_BACKEND_UMP_IPI
        // try next backend
        b->binding = malloc(sizeof(struct intermon_ump_ipi_binding ));
        assert((b->binding) != NULL);
        err = intermon_ump_ipi_bind(b->binding, b->iref, intermon_bind_continuation_direct, b, b->waitset, b->flags, DEFAULT_UMP_BUFLEN, DEFAULT_UMP_BUFLEN);
        if (err_is_fail(err)) {
            free(b->binding);
            _binding = NULL;
            goto out;
        } else {
            return;
        }
        #else
        // skip non-enabled backend (fall through)
        #endif // CONFIG_FLOUNDER_BACKEND_UMP_IPI
    case 2:
        #ifdef CONFIG_FLOUNDER_BACKEND_UMP_IPI
        if (err_is_ok(err)) {
            goto out;
        } else {
            free(b->binding);
            if (true) {
                goto try_next_2;
            } else {
                // report permanent failure to user
                _binding = NULL;
                goto out;
            }
        }
        try_next_2:
        #endif // CONFIG_FLOUNDER_BACKEND_UMP_IPI
        (b->driver_num)++;
        #ifdef CONFIG_FLOUNDER_BACKEND_UMP
        // try next backend
        b->binding = malloc(sizeof(struct intermon_ump_binding ));
        assert((b->binding) != NULL);
        err = intermon_ump_bind(b->binding, b->iref, intermon_bind_continuation_direct, b, b->waitset, b->flags, DEFAULT_UMP_BUFLEN, DEFAULT_UMP_BUFLEN);
        if (err_is_fail(err)) {
            free(b->binding);
            _binding = NULL;
            goto out;
        } else {
            return;
        }
        #else
        // skip non-enabled backend (fall through)
        #endif // CONFIG_FLOUNDER_BACKEND_UMP
    case 3:
        #ifdef CONFIG_FLOUNDER_BACKEND_UMP
        if (err_is_ok(err)) {
            goto out;
        } else {
            free(b->binding);
            if (true) {
                goto try_next_3;
            } else {
                // report permanent failure to user
                _binding = NULL;
                goto out;
            }
        }
        try_next_3:
        #endif // CONFIG_FLOUNDER_BACKEND_UMP
        (b->driver_num)++;
        #ifdef CONFIG_FLOUNDER_BACKEND_MULTIHOP
        // try next backend
        b->binding = malloc(sizeof(struct intermon_multihop_binding ));
        assert((b->binding) != NULL);
        err = intermon_multihop_bind(b->binding, b->iref, intermon_bind_continuation_direct, b, b->waitset, b->flags);
        if (err_is_fail(err)) {
            free(b->binding);
            _binding = NULL;
            goto out;
        } else {
            return;
        }
        #else
        // skip non-enabled backend (fall through)
        #endif // CONFIG_FLOUNDER_BACKEND_MULTIHOP
    case 4:
        #ifdef CONFIG_FLOUNDER_BACKEND_MULTIHOP
        if (err_is_ok(err)) {
            goto out;
        } else {
            free(b->binding);
            if (true) {
                goto try_next_4;
            } else {
                // report permanent failure to user
                _binding = NULL;
                goto out;
            }
        }
        try_next_4:
        #endif // CONFIG_FLOUNDER_BACKEND_MULTIHOP
        (b->driver_num)++;
        #ifdef CONFIG_FLOUNDER_BACKEND_UDN
        // try next backend
        b->binding = malloc(sizeof(struct intermon_udn_binding ));
        assert((b->binding) != NULL);
        err = intermon_udn_bind(b->binding, b->iref, intermon_bind_continuation_direct, b, b->waitset, b->flags);
        if (err_is_fail(err)) {
            free(b->binding);
            _binding = NULL;
            goto out;
        } else {
            return;
        }
        #else
        // skip non-enabled backend (fall through)
        #endif // CONFIG_FLOUNDER_BACKEND_UDN
    case 5:
        #ifdef CONFIG_FLOUNDER_BACKEND_UDN
        if (err_is_ok(err)) {
            goto out;
        } else {
            free(b->binding);
            if (!true) {
                _binding = NULL;
                goto out;
            }
        }
        #endif // CONFIG_FLOUNDER_BACKEND_UDN
        err = FLOUNDER_ERR_GENERIC_BIND_NO_MORE_DRIVERS;
        _binding = NULL;
        goto out;
    default:
        assert(!("invalid state"));
    }
    
    out:
    ((intermon_bind_continuation_fn *)(b->callback))(b->st, err, _binding);
    free(b);
}

static  void intermon_bind_contination_multihop(void *st, errval_t err, struct intermon_binding *_binding)
{
    // This bind cont function uses the different backends in the following order:
    // lmp multihop ump_ipi ump udn
    
    struct flounder_generic_bind_attempt *b = st;
    switch (b->driver_num) {
    case 0:
        (b->driver_num)++;
        #ifdef CONFIG_FLOUNDER_BACKEND_LMP
        // try next backend
        b->binding = malloc(sizeof(struct intermon_lmp_binding ));
        assert((b->binding) != NULL);
        err = intermon_lmp_bind(b->binding, b->iref, intermon_bind_contination_multihop, b, b->waitset, b->flags, DEFAULT_LMP_BUF_WORDS);
        if (err_is_fail(err)) {
            free(b->binding);
            _binding = NULL;
            goto out;
        } else {
            return;
        }
        #else
        // skip non-enabled backend (fall through)
        #endif // CONFIG_FLOUNDER_BACKEND_LMP
    case 1:
        #ifdef CONFIG_FLOUNDER_BACKEND_LMP
        if (err_is_ok(err)) {
            goto out;
        } else {
            free(b->binding);
            if (err_no(err) == MON_ERR_IDC_BIND_NOT_SAME_CORE) {
                goto try_next_1;
            } else {
                // report permanent failure to user
                _binding = NULL;
                goto out;
            }
        }
        try_next_1:
        #endif // CONFIG_FLOUNDER_BACKEND_LMP
        (b->driver_num)++;
        #ifdef CONFIG_FLOUNDER_BACKEND_MULTIHOP
        // try next backend
        b->binding = malloc(sizeof(struct intermon_multihop_binding ));
        assert((b->binding) != NULL);
        err = intermon_multihop_bind(b->binding, b->iref, intermon_bind_contination_multihop, b, b->waitset, b->flags);
        if (err_is_fail(err)) {
            free(b->binding);
            _binding = NULL;
            goto out;
        } else {
            return;
        }
        #else
        // skip non-enabled backend (fall through)
        #endif // CONFIG_FLOUNDER_BACKEND_MULTIHOP
    case 2:
        #ifdef CONFIG_FLOUNDER_BACKEND_MULTIHOP
        if (err_is_ok(err)) {
            goto out;
        } else {
            free(b->binding);
            if (true) {
                goto try_next_2;
            } else {
                // report permanent failure to user
                _binding = NULL;
                goto out;
            }
        }
        try_next_2:
        #endif // CONFIG_FLOUNDER_BACKEND_MULTIHOP
        (b->driver_num)++;
        #ifdef CONFIG_FLOUNDER_BACKEND_UMP_IPI
        // try next backend
        b->binding = malloc(sizeof(struct intermon_ump_ipi_binding ));
        assert((b->binding) != NULL);
        err = intermon_ump_ipi_bind(b->binding, b->iref, intermon_bind_contination_multihop, b, b->waitset, b->flags, DEFAULT_UMP_BUFLEN, DEFAULT_UMP_BUFLEN);
        if (err_is_fail(err)) {
            free(b->binding);
            _binding = NULL;
            goto out;
        } else {
            return;
        }
        #else
        // skip non-enabled backend (fall through)
        #endif // CONFIG_FLOUNDER_BACKEND_UMP_IPI
    case 3:
        #ifdef CONFIG_FLOUNDER_BACKEND_UMP_IPI
        if (err_is_ok(err)) {
            goto out;
        } else {
            free(b->binding);
            if (true) {
                goto try_next_3;
            } else {
                // report permanent failure to user
                _binding = NULL;
                goto out;
            }
        }
        try_next_3:
        #endif // CONFIG_FLOUNDER_BACKEND_UMP_IPI
        (b->driver_num)++;
        #ifdef CONFIG_FLOUNDER_BACKEND_UMP
        // try next backend
        b->binding = malloc(sizeof(struct intermon_ump_binding ));
        assert((b->binding) != NULL);
        err = intermon_ump_bind(b->binding, b->iref, intermon_bind_contination_multihop, b, b->waitset, b->flags, DEFAULT_UMP_BUFLEN, DEFAULT_UMP_BUFLEN);
        if (err_is_fail(err)) {
            free(b->binding);
            _binding = NULL;
            goto out;
        } else {
            return;
        }
        #else
        // skip non-enabled backend (fall through)
        #endif // CONFIG_FLOUNDER_BACKEND_UMP
    case 4:
        #ifdef CONFIG_FLOUNDER_BACKEND_UMP
        if (err_is_ok(err)) {
            goto out;
        } else {
            free(b->binding);
            if (true) {
                goto try_next_4;
            } else {
                // report permanent failure to user
                _binding = NULL;
                goto out;
            }
        }
        try_next_4:
        #endif // CONFIG_FLOUNDER_BACKEND_UMP
        (b->driver_num)++;
        #ifdef CONFIG_FLOUNDER_BACKEND_UDN
        // try next backend
        b->binding = malloc(sizeof(struct intermon_udn_binding ));
        assert((b->binding) != NULL);
        err = intermon_udn_bind(b->binding, b->iref, intermon_bind_contination_multihop, b, b->waitset, b->flags);
        if (err_is_fail(err)) {
            free(b->binding);
            _binding = NULL;
            goto out;
        } else {
            return;
        }
        #else
        // skip non-enabled backend (fall through)
        #endif // CONFIG_FLOUNDER_BACKEND_UDN
    case 5:
        #ifdef CONFIG_FLOUNDER_BACKEND_UDN
        if (err_is_ok(err)) {
            goto out;
        } else {
            free(b->binding);
            if (!true) {
                _binding = NULL;
                goto out;
            }
        }
        #endif // CONFIG_FLOUNDER_BACKEND_UDN
        err = FLOUNDER_ERR_GENERIC_BIND_NO_MORE_DRIVERS;
        _binding = NULL;
        goto out;
    default:
        assert(!("invalid state"));
    }
    
    out:
    ((intermon_bind_continuation_fn *)(b->callback))(b->st, err, _binding);
    free(b);
}

 errval_t intermon_bind(iref_t iref, intermon_bind_continuation_fn *_continuation, void *st, struct waitset *waitset, idc_bind_flags_t flags)
{
    // allocate state
    struct flounder_generic_bind_attempt *b = malloc(sizeof(struct flounder_generic_bind_attempt ));
    if (b == NULL) {
        return(LIB_ERR_MALLOC_FAIL);
    }
    
    // fill in binding state
    b->iref = iref;
    b->waitset = waitset;
    b->driver_num = 0;
    b->callback = _continuation;
    b->st = st;
    b->flags = flags;
    
    if (flags & IDC_BIND_FLAG_MULTIHOP) {
        intermon_bind_contination_multihop(b, SYS_ERR_OK, NULL);
    } else {
        intermon_bind_continuation_direct(b, SYS_ERR_OK, NULL);
    }
    
    return(SYS_ERR_OK);
}

/*
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * INTERFACE NAME: intermon
 * INTEFACE FILE: /home/andreas/barrelfish/new_test2/if/intermon.if
 * INTERFACE DESCRIPTION: The Interface between monitors
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr.6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY FLOUNDER: DO NOT EDIT!
 */

/*
 * Generated Stub for LMP on tilepro
 */

#include <string.h>
#include <barrelfish/barrelfish.h>
#include <flounder/flounder_support.h>
#include <flounder/flounder_support_lmp.h>
#include <if/intermon_defs.h>

/*
 * Send handler functions
 */
static  void intermon_spawnd_image_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, intermon_spawnd_image_request__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_spawnd_image_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_spawnd_image_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send4(&(b->chan), b->flags, NULL_CAP, intermon_spawnd_image_reply__msgnum, ((_binding->tx_union).spawnd_image_reply).base, (((_binding->tx_union).spawnd_image_reply).base) >> 32, ((_binding->tx_union).spawnd_image_reply).bytes);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_spawnd_image_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_monitor_initialized__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, intermon_monitor_initialized__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_monitor_initialized__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_trace_caps_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, intermon_trace_caps_request__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_trace_caps_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_trace_caps_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send7(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), NULL_CAP, intermon_trace_caps_reply__msgnum, (((_binding->tx_union).trace_caps_reply).cap).w0, ((((_binding->tx_union).trace_caps_reply).cap).w0) >> 32, (((_binding->tx_union).trace_caps_reply).cap).w1, ((((_binding->tx_union).trace_caps_reply).cap).w1) >> 32, (((_binding->tx_union).trace_caps_reply).cap).w2, ((((_binding->tx_union).trace_caps_reply).cap).w2) >> 32);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, (((_binding->tx_union).trace_caps_reply).cap).w3, ((((_binding->tx_union).trace_caps_reply).cap).w3) >> 32);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_trace_caps_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_mem_serv_iref_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, intermon_mem_serv_iref_request__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_mem_serv_iref_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_mem_serv_iref_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, intermon_mem_serv_iref_reply__msgnum, ((_binding->tx_union).mem_serv_iref_reply).iref);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_mem_serv_iref_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_ramfs_serv_iref_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, intermon_ramfs_serv_iref_request__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_ramfs_serv_iref_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_ramfs_serv_iref_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, intermon_ramfs_serv_iref_reply__msgnum, ((_binding->tx_union).ramfs_serv_iref_reply).iref);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_ramfs_serv_iref_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_name_serv_iref_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, intermon_name_serv_iref_request__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_name_serv_iref_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_name_serv_iref_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, intermon_name_serv_iref_reply__msgnum, ((_binding->tx_union).name_serv_iref_reply).iref);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_name_serv_iref_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_monitor_mem_iref_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, intermon_monitor_mem_iref_request__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_monitor_mem_iref_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_monitor_mem_iref_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, intermon_monitor_mem_iref_reply__msgnum, ((_binding->tx_union).monitor_mem_iref_reply).iref);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_monitor_mem_iref_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_bind_monitor_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send7(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), NULL_CAP, intermon_bind_monitor_request__msgnum | (((uintptr_t )(((_binding->tx_union).bind_monitor_request).core_id)) << 16), (((_binding->tx_union).bind_monitor_request).cap).w0, ((((_binding->tx_union).bind_monitor_request).cap).w0) >> 32, (((_binding->tx_union).bind_monitor_request).cap).w1, ((((_binding->tx_union).bind_monitor_request).cap).w1) >> 32, (((_binding->tx_union).bind_monitor_request).cap).w2, ((((_binding->tx_union).bind_monitor_request).cap).w2) >> 32);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, (((_binding->tx_union).bind_monitor_request).cap).w3, ((((_binding->tx_union).bind_monitor_request).cap).w3) >> 32);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_bind_monitor_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_bind_monitor_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, intermon_bind_monitor_reply__msgnum, ((_binding->tx_union).bind_monitor_reply).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_bind_monitor_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_bind_monitor_proxy__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send7(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), NULL_CAP, intermon_bind_monitor_proxy__msgnum | (((uintptr_t )(((_binding->tx_union).bind_monitor_proxy).dst_core_id)) << 16), (((_binding->tx_union).bind_monitor_proxy).cap).w0, ((((_binding->tx_union).bind_monitor_proxy).cap).w0) >> 32, (((_binding->tx_union).bind_monitor_proxy).cap).w1, ((((_binding->tx_union).bind_monitor_proxy).cap).w1) >> 32, (((_binding->tx_union).bind_monitor_proxy).cap).w2, ((((_binding->tx_union).bind_monitor_proxy).cap).w2) >> 32);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, (((_binding->tx_union).bind_monitor_proxy).cap).w3, ((((_binding->tx_union).bind_monitor_proxy).cap).w3) >> 32);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_bind_monitor_proxy__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_bind_monitor_request_scc__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send7(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), NULL_CAP, intermon_bind_monitor_request_scc__msgnum | ((((uintptr_t )(((_binding->tx_union).bind_monitor_request_scc).core_id)) << 16) | (((uintptr_t )(((_binding->tx_union).bind_monitor_request_scc).from_core_id)) << 24)), (((_binding->tx_union).bind_monitor_request_scc).cap).w0, ((((_binding->tx_union).bind_monitor_request_scc).cap).w0) >> 32, (((_binding->tx_union).bind_monitor_request_scc).cap).w1, ((((_binding->tx_union).bind_monitor_request_scc).cap).w1) >> 32, (((_binding->tx_union).bind_monitor_request_scc).cap).w2, ((((_binding->tx_union).bind_monitor_request_scc).cap).w2) >> 32);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = lmp_chan_send3(&(b->chan), b->flags, NULL_CAP, (((_binding->tx_union).bind_monitor_request_scc).cap).w3, ((((_binding->tx_union).bind_monitor_request_scc).cap).w3) >> 32, ((_binding->tx_union).bind_monitor_request_scc).chan_id);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_bind_monitor_request_scc__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_bind_monitor_reply_scc__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send3(&(b->chan), b->flags, NULL_CAP, intermon_bind_monitor_reply_scc__msgnum | (((uintptr_t )(((_binding->tx_union).bind_monitor_reply_scc).core_id)) << 16), ((_binding->tx_union).bind_monitor_reply_scc).err, ((_binding->tx_union).bind_monitor_reply_scc).chan_id);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_bind_monitor_reply_scc__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_bind_monitor_proxy_scc__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send7(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), NULL_CAP, intermon_bind_monitor_proxy_scc__msgnum | ((((uintptr_t )(((_binding->tx_union).bind_monitor_proxy_scc).dst_core_id)) << 16) | (((uintptr_t )(((_binding->tx_union).bind_monitor_proxy_scc).core_id)) << 24)), (((_binding->tx_union).bind_monitor_proxy_scc).cap).w0, ((((_binding->tx_union).bind_monitor_proxy_scc).cap).w0) >> 32, (((_binding->tx_union).bind_monitor_proxy_scc).cap).w1, ((((_binding->tx_union).bind_monitor_proxy_scc).cap).w1) >> 32, (((_binding->tx_union).bind_monitor_proxy_scc).cap).w2, ((((_binding->tx_union).bind_monitor_proxy_scc).cap).w2) >> 32);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = lmp_chan_send3(&(b->chan), b->flags, NULL_CAP, (((_binding->tx_union).bind_monitor_proxy_scc).cap).w3, ((((_binding->tx_union).bind_monitor_proxy_scc).cap).w3) >> 32, ((_binding->tx_union).bind_monitor_proxy_scc).chan_id);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_bind_monitor_proxy_scc__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_bind_monitor_request_bmp__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, intermon_bind_monitor_request_bmp__msgnum | ((((uintptr_t )(((_binding->tx_union).bind_monitor_request_bmp).core_id)) << 16) | (((uintptr_t )(((_binding->tx_union).bind_monitor_request_bmp).from_core_id)) << 24)), ((_binding->tx_union).bind_monitor_request_bmp).chan_id);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_bind_monitor_request_bmp__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_bind_monitor_reply_bmp__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send3(&(b->chan), b->flags, NULL_CAP, intermon_bind_monitor_reply_bmp__msgnum | (((uintptr_t )(((_binding->tx_union).bind_monitor_reply_bmp).core_id)) << 16), ((_binding->tx_union).bind_monitor_reply_bmp).err, ((_binding->tx_union).bind_monitor_reply_bmp).chan_id);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_bind_monitor_reply_bmp__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_bind_monitor_proxy_bmp__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, intermon_bind_monitor_proxy_bmp__msgnum | ((((uintptr_t )(((_binding->tx_union).bind_monitor_proxy_bmp).dst_core_id)) << 16) | (((uintptr_t )(((_binding->tx_union).bind_monitor_proxy_bmp).core_id)) << 24)), ((_binding->tx_union).bind_monitor_proxy_bmp).chan_id);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_bind_monitor_proxy_bmp__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_new_monitor_notify__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, intermon_new_monitor_notify__msgnum | (((uintptr_t )(((_binding->tx_union).new_monitor_notify).core_id)) << 16));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_new_monitor_notify__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_bind_ump_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send7(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), NULL_CAP, intermon_bind_ump_request__msgnum | (((uintptr_t )(((_binding->tx_union).bind_ump_request).framebits)) << 16), ((_binding->tx_union).bind_ump_request).iref, ((_binding->tx_union).bind_ump_request).mon_id, (((_binding->tx_union).bind_ump_request).mon_id) >> 32, ((_binding->tx_union).bind_ump_request).channel_length_in, ((_binding->tx_union).bind_ump_request).channel_length_out, ((_binding->tx_union).bind_ump_request).framebase);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = lmp_chan_send7(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), NULL_CAP, (((_binding->tx_union).bind_ump_request).framebase) >> 32, (((_binding->tx_union).bind_ump_request).notify).w0, ((((_binding->tx_union).bind_ump_request).notify).w0) >> 32, (((_binding->tx_union).bind_ump_request).notify).w1, ((((_binding->tx_union).bind_ump_request).notify).w1) >> 32, (((_binding->tx_union).bind_ump_request).notify).w2, ((((_binding->tx_union).bind_ump_request).notify).w2) >> 32);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 2:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, (((_binding->tx_union).bind_ump_request).notify).w3, ((((_binding->tx_union).bind_ump_request).notify).w3) >> 32);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_bind_ump_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_bind_ump_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send7(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), NULL_CAP, intermon_bind_ump_reply__msgnum, ((_binding->tx_union).bind_ump_reply).con_id, (((_binding->tx_union).bind_ump_reply).con_id) >> 32, ((_binding->tx_union).bind_ump_reply).mon_id, (((_binding->tx_union).bind_ump_reply).mon_id) >> 32, ((_binding->tx_union).bind_ump_reply).err, (((_binding->tx_union).bind_ump_reply).notify).w0);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = lmp_chan_send7(&(b->chan), b->flags, NULL_CAP, ((((_binding->tx_union).bind_ump_reply).notify).w0) >> 32, (((_binding->tx_union).bind_ump_reply).notify).w1, ((((_binding->tx_union).bind_ump_reply).notify).w1) >> 32, (((_binding->tx_union).bind_ump_reply).notify).w2, ((((_binding->tx_union).bind_ump_reply).notify).w2) >> 32, (((_binding->tx_union).bind_ump_reply).notify).w3, ((((_binding->tx_union).bind_ump_reply).notify).w3) >> 32);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_bind_ump_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_bind_udn_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send7(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), NULL_CAP, intermon_bind_udn_request__msgnum | ((((uintptr_t )(((_binding->tx_union).bind_udn_request).core_id)) << 16) | (((uintptr_t )(((_binding->tx_union).bind_udn_request).asid)) << 24)), ((_binding->tx_union).bind_udn_request).iref, ((_binding->tx_union).bind_udn_request).mon_id, (((_binding->tx_union).bind_udn_request).mon_id) >> 32, (((_binding->tx_union).bind_udn_request).notify).w0, ((((_binding->tx_union).bind_udn_request).notify).w0) >> 32, (((_binding->tx_union).bind_udn_request).notify).w1);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = lmp_chan_send6(&(b->chan), b->flags, NULL_CAP, ((((_binding->tx_union).bind_udn_request).notify).w1) >> 32, (((_binding->tx_union).bind_udn_request).notify).w2, ((((_binding->tx_union).bind_udn_request).notify).w2) >> 32, (((_binding->tx_union).bind_udn_request).notify).w3, ((((_binding->tx_union).bind_udn_request).notify).w3) >> 32, ((_binding->tx_union).bind_udn_request).chan_id);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_bind_udn_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_bind_udn_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send7(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), NULL_CAP, intermon_bind_udn_reply__msgnum | ((((uintptr_t )(((_binding->tx_union).bind_udn_reply).core_id)) << 16) | (((uintptr_t )(((_binding->tx_union).bind_udn_reply).asid)) << 24)), ((_binding->tx_union).bind_udn_reply).con_id, (((_binding->tx_union).bind_udn_reply).con_id) >> 32, ((_binding->tx_union).bind_udn_reply).mon_id, (((_binding->tx_union).bind_udn_reply).mon_id) >> 32, ((_binding->tx_union).bind_udn_reply).err, (((_binding->tx_union).bind_udn_reply).notify).w0);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = lmp_chan_send7(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), NULL_CAP, ((((_binding->tx_union).bind_udn_reply).notify).w0) >> 32, (((_binding->tx_union).bind_udn_reply).notify).w1, ((((_binding->tx_union).bind_udn_reply).notify).w1) >> 32, (((_binding->tx_union).bind_udn_reply).notify).w2, ((((_binding->tx_union).bind_udn_reply).notify).w2) >> 32, (((_binding->tx_union).bind_udn_reply).notify).w3, ((((_binding->tx_union).bind_udn_reply).notify).w3) >> 32);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 2:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, ((_binding->tx_union).bind_udn_reply).chan_id);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_bind_udn_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_cap_send_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send7(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), NULL_CAP, intermon_cap_send_request__msgnum | ((((uintptr_t )((((_binding->tx_union).cap_send_request).give_away) != false)) << 16) | ((((uintptr_t )((((_binding->tx_union).cap_send_request).has_descendents) != false)) << 17) | (((uintptr_t )((((_binding->tx_union).cap_send_request).null_cap) != false)) << 18))), ((_binding->tx_union).cap_send_request).con_id, (((_binding->tx_union).cap_send_request).con_id) >> 32, ((_binding->tx_union).cap_send_request).capid, (((_binding->tx_union).cap_send_request).cap).w0, ((((_binding->tx_union).cap_send_request).cap).w0) >> 32, (((_binding->tx_union).cap_send_request).cap).w1);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = lmp_chan_send7(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), NULL_CAP, ((((_binding->tx_union).cap_send_request).cap).w1) >> 32, (((_binding->tx_union).cap_send_request).cap).w2, ((((_binding->tx_union).cap_send_request).cap).w2) >> 32, (((_binding->tx_union).cap_send_request).cap).w3, ((((_binding->tx_union).cap_send_request).cap).w3) >> 32, ((_binding->tx_union).cap_send_request).err, (*(((_binding->tx_union).cap_send_request).on_cores))[0]);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 2:
        err = lmp_chan_send7(&(b->chan), b->flags, NULL_CAP, ((*(((_binding->tx_union).cap_send_request).on_cores))[0]) >> 32, (*(((_binding->tx_union).cap_send_request).on_cores))[1], ((*(((_binding->tx_union).cap_send_request).on_cores))[1]) >> 32, (*(((_binding->tx_union).cap_send_request).on_cores))[2], ((*(((_binding->tx_union).cap_send_request).on_cores))[2]) >> 32, (*(((_binding->tx_union).cap_send_request).on_cores))[3], ((*(((_binding->tx_union).cap_send_request).on_cores))[3]) >> 32);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_cap_send_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_span_domain_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send7(&(b->chan), b->flags, NULL_CAP, intermon_span_domain_request__msgnum | (((uintptr_t )(((_binding->tx_union).span_domain_request).framebits)) << 16), ((_binding->tx_union).span_domain_request).state_id, (((_binding->tx_union).span_domain_request).state_id) >> 32, ((_binding->tx_union).span_domain_request).vnodebase, (((_binding->tx_union).span_domain_request).vnodebase) >> 32, ((_binding->tx_union).span_domain_request).framebase, (((_binding->tx_union).span_domain_request).framebase) >> 32);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_span_domain_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_span_domain_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send4(&(b->chan), b->flags, NULL_CAP, intermon_span_domain_reply__msgnum, ((_binding->tx_union).span_domain_reply).state_id, (((_binding->tx_union).span_domain_reply).state_id) >> 32, ((_binding->tx_union).span_domain_reply).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_span_domain_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_rsrc_join__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, intermon_rsrc_join__msgnum | (((uintptr_t )(((_binding->tx_union).rsrc_join).coreid)) << 16), ((_binding->tx_union).rsrc_join).id);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_rsrc_join__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_rsrc_join_complete__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, intermon_rsrc_join_complete__msgnum, ((_binding->tx_union).rsrc_join_complete).id);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_rsrc_join_complete__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_rsrc_phase_data__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send3(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), NULL_CAP, intermon_rsrc_phase_data__msgnum, ((_binding->tx_union).rsrc_phase_data).id, ((_binding->tx_union).rsrc_phase_data).phase);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = flounder_stub_lmp_send_buf(&(b->chan), b->flags, ((_binding->tx_union).rsrc_phase_data).data, ((_binding->tx_union).rsrc_phase_data).len, &(_binding->tx_str_pos));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_rsrc_phase_data__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_rsrc_timer_sync__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send3(&(b->chan), b->flags, NULL_CAP, intermon_rsrc_timer_sync__msgnum, ((_binding->tx_union).rsrc_timer_sync).timestamp, (((_binding->tx_union).rsrc_timer_sync).timestamp) >> 32);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_rsrc_timer_sync__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_rsrc_timer_sync_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, intermon_rsrc_timer_sync_reply__msgnum, ((_binding->tx_union).rsrc_timer_sync_reply).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_rsrc_timer_sync_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_rsrc_phase__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send5(&(b->chan), b->flags, NULL_CAP, intermon_rsrc_phase__msgnum, ((_binding->tx_union).rsrc_phase).id, ((_binding->tx_union).rsrc_phase).phase, ((_binding->tx_union).rsrc_phase).timestamp, (((_binding->tx_union).rsrc_phase).timestamp) >> 32);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_rsrc_phase__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_multihop_routing_table_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, intermon_multihop_routing_table_request__msgnum | (((uintptr_t )(((_binding->tx_union).multihop_routing_table_request).source_coreid)) << 16));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_multihop_routing_table_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_multihop_routing_table_response__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), NULL_CAP, intermon_multihop_routing_table_response__msgnum | ((((uintptr_t )(((_binding->tx_union).multihop_routing_table_response).source_coreid)) << 16) | (((uintptr_t )(((_binding->tx_union).multihop_routing_table_response).max_coreid)) << 24)), ((_binding->tx_union).multihop_routing_table_response).err);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = flounder_stub_lmp_send_buf(&(b->chan), b->flags, ((_binding->tx_union).multihop_routing_table_response).to, ((_binding->tx_union).multihop_routing_table_response).len, &(_binding->tx_str_pos));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_multihop_routing_table_response__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_multihop_routing_table_grow__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), NULL_CAP, intermon_multihop_routing_table_grow__msgnum | (((uintptr_t )(((_binding->tx_union).multihop_routing_table_grow).forwarder)) << 16));
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = flounder_stub_lmp_send_buf(&(b->chan), b->flags, ((_binding->tx_union).multihop_routing_table_grow).destinations, ((_binding->tx_union).multihop_routing_table_grow).len, &(_binding->tx_str_pos));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_multihop_routing_table_grow__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_bind_multihop_intermon_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send4(&(b->chan), b->flags, NULL_CAP, intermon_bind_multihop_intermon_request__msgnum | (((uintptr_t )(((_binding->tx_union).bind_multihop_intermon_request).core_id)) << 16), ((_binding->tx_union).bind_multihop_intermon_request).iref, ((_binding->tx_union).bind_multihop_intermon_request).sender_vci, (((_binding->tx_union).bind_multihop_intermon_request).sender_vci) >> 32);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_bind_multihop_intermon_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_bind_multihop_intermon_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send6(&(b->chan), b->flags, NULL_CAP, intermon_bind_multihop_intermon_reply__msgnum, ((_binding->tx_union).bind_multihop_intermon_reply).receiver_vci, (((_binding->tx_union).bind_multihop_intermon_reply).receiver_vci) >> 32, ((_binding->tx_union).bind_multihop_intermon_reply).sender_vci, (((_binding->tx_union).bind_multihop_intermon_reply).sender_vci) >> 32, ((_binding->tx_union).bind_multihop_intermon_reply).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_bind_multihop_intermon_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_multihop_message__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send4(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), NULL_CAP, intermon_multihop_message__msgnum | ((((uintptr_t )(((_binding->tx_union).multihop_message).direction)) << 16) | (((uintptr_t )(((_binding->tx_union).multihop_message).flags)) << 24)), ((_binding->tx_union).multihop_message).vci, (((_binding->tx_union).multihop_message).vci) >> 32, ((_binding->tx_union).multihop_message).ack);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = flounder_stub_lmp_send_buf(&(b->chan), b->flags, ((_binding->tx_union).multihop_message).payload, ((_binding->tx_union).multihop_message).size, &(_binding->tx_str_pos));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_multihop_message__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_multihop_cap_send__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send7(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), NULL_CAP, intermon_multihop_cap_send__msgnum | ((((uintptr_t )((((_binding->tx_union).multihop_cap_send).null_cap) != false)) << 16) | (((uintptr_t )(((_binding->tx_union).multihop_cap_send).direction)) << 17)), ((_binding->tx_union).multihop_cap_send).vci, (((_binding->tx_union).multihop_cap_send).vci) >> 32, ((_binding->tx_union).multihop_cap_send).capid, ((_binding->tx_union).multihop_cap_send).err, (((_binding->tx_union).multihop_cap_send).cap).w0, ((((_binding->tx_union).multihop_cap_send).cap).w0) >> 32);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = lmp_chan_send6(&(b->chan), b->flags, NULL_CAP, (((_binding->tx_union).multihop_cap_send).cap).w1, ((((_binding->tx_union).multihop_cap_send).cap).w1) >> 32, (((_binding->tx_union).multihop_cap_send).cap).w2, ((((_binding->tx_union).multihop_cap_send).cap).w2) >> 32, (((_binding->tx_union).multihop_cap_send).cap).w3, ((((_binding->tx_union).multihop_cap_send).cap).w3) >> 32);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_multihop_cap_send__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_trace_prepare__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, intermon_trace_prepare__msgnum | (((uintptr_t )(((_binding->tx_union).trace_prepare).origin_core)) << 16));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_trace_prepare__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_trace_prepare_finished__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, intermon_trace_prepare_finished__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_trace_prepare_finished__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_trace_measure__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send3(&(b->chan), b->flags, NULL_CAP, intermon_trace_measure__msgnum | (((uintptr_t )(((_binding->tx_union).trace_measure).origin_core)) << 16), ((_binding->tx_union).trace_measure).t0, (((_binding->tx_union).trace_measure).t0) >> 32);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_trace_measure__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_trace_measure_ack__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send7(&(b->chan), b->flags, NULL_CAP, intermon_trace_measure_ack__msgnum | (((uintptr_t )(((_binding->tx_union).trace_measure_ack).origin_core)) << 16), ((_binding->tx_union).trace_measure_ack).t0, (((_binding->tx_union).trace_measure_ack).t0) >> 32, ((_binding->tx_union).trace_measure_ack).t1, (((_binding->tx_union).trace_measure_ack).t1) >> 32, ((_binding->tx_union).trace_measure_ack).t2, (((_binding->tx_union).trace_measure_ack).t2) >> 32);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_trace_measure_ack__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_bfscope_flush_send_forward__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, intermon_bfscope_flush_send_forward__msgnum, ((_binding->tx_union).bfscope_flush_send_forward).iref);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_bfscope_flush_send_forward__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void intermon_bfscope_flush_ack_forward__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, intermon_bfscope_flush_ack_forward__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = intermon_bfscope_flush_ack_forward__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}


/*
 * Message sender functions
 */
static  errval_t intermon_spawnd_image_request__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_spawnd_image_request__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX intermon.spawnd_image_request\n");
    
    // try to send!
    intermon_spawnd_image_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_spawnd_image_reply__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_genpaddr_t base, uint32_t bytes)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_spawnd_image_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).spawnd_image_reply).base = base;
    ((_binding->tx_union).spawnd_image_reply).bytes = bytes;
    FL_DEBUG("lmp TX intermon.spawnd_image_reply\n");
    
    // try to send!
    intermon_spawnd_image_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_monitor_initialized__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_monitor_initialized__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX intermon.monitor_initialized\n");
    
    // try to send!
    intermon_monitor_initialized__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_trace_caps_request__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_trace_caps_request__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX intermon.trace_caps_request\n");
    
    // try to send!
    intermon_trace_caps_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_trace_caps_reply__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_caprep_t cap)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_trace_caps_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).trace_caps_reply).cap = cap;
    FL_DEBUG("lmp TX intermon.trace_caps_reply\n");
    
    // try to send!
    intermon_trace_caps_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_mem_serv_iref_request__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_mem_serv_iref_request__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX intermon.mem_serv_iref_request\n");
    
    // try to send!
    intermon_mem_serv_iref_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_mem_serv_iref_reply__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, iref_t iref)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_mem_serv_iref_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).mem_serv_iref_reply).iref = iref;
    FL_DEBUG("lmp TX intermon.mem_serv_iref_reply\n");
    
    // try to send!
    intermon_mem_serv_iref_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_ramfs_serv_iref_request__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_ramfs_serv_iref_request__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX intermon.ramfs_serv_iref_request\n");
    
    // try to send!
    intermon_ramfs_serv_iref_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_ramfs_serv_iref_reply__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, iref_t iref)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_ramfs_serv_iref_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).ramfs_serv_iref_reply).iref = iref;
    FL_DEBUG("lmp TX intermon.ramfs_serv_iref_reply\n");
    
    // try to send!
    intermon_ramfs_serv_iref_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_name_serv_iref_request__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_name_serv_iref_request__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX intermon.name_serv_iref_request\n");
    
    // try to send!
    intermon_name_serv_iref_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_name_serv_iref_reply__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, iref_t iref)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_name_serv_iref_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).name_serv_iref_reply).iref = iref;
    FL_DEBUG("lmp TX intermon.name_serv_iref_reply\n");
    
    // try to send!
    intermon_name_serv_iref_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_monitor_mem_iref_request__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_monitor_mem_iref_request__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX intermon.monitor_mem_iref_request\n");
    
    // try to send!
    intermon_monitor_mem_iref_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_monitor_mem_iref_reply__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, iref_t iref)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_monitor_mem_iref_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).monitor_mem_iref_reply).iref = iref;
    FL_DEBUG("lmp TX intermon.monitor_mem_iref_reply\n");
    
    // try to send!
    intermon_monitor_mem_iref_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_monitor_request__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_coreid_t_t core_id, intermon_caprep_t cap)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_monitor_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_monitor_request).core_id = core_id;
    ((_binding->tx_union).bind_monitor_request).cap = cap;
    FL_DEBUG("lmp TX intermon.bind_monitor_request\n");
    
    // try to send!
    intermon_bind_monitor_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_monitor_reply__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_errval_t err)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_monitor_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_monitor_reply).err = err;
    FL_DEBUG("lmp TX intermon.bind_monitor_reply\n");
    
    // try to send!
    intermon_bind_monitor_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_monitor_proxy__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_coreid_t_t dst_core_id, intermon_caprep_t cap)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_monitor_proxy__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_monitor_proxy).dst_core_id = dst_core_id;
    ((_binding->tx_union).bind_monitor_proxy).cap = cap;
    FL_DEBUG("lmp TX intermon.bind_monitor_proxy\n");
    
    // try to send!
    intermon_bind_monitor_proxy__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_monitor_request_scc__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_coreid_t_t core_id, intermon_caprep_t cap, intermon_chanid_t_t chan_id, intermon_coreid_t_t from_core_id)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_monitor_request_scc__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_monitor_request_scc).core_id = core_id;
    ((_binding->tx_union).bind_monitor_request_scc).cap = cap;
    ((_binding->tx_union).bind_monitor_request_scc).chan_id = chan_id;
    ((_binding->tx_union).bind_monitor_request_scc).from_core_id = from_core_id;
    FL_DEBUG("lmp TX intermon.bind_monitor_request_scc\n");
    
    // try to send!
    intermon_bind_monitor_request_scc__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_monitor_reply_scc__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_errval_t err, intermon_chanid_t_t chan_id, intermon_coreid_t_t core_id)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_monitor_reply_scc__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_monitor_reply_scc).err = err;
    ((_binding->tx_union).bind_monitor_reply_scc).chan_id = chan_id;
    ((_binding->tx_union).bind_monitor_reply_scc).core_id = core_id;
    FL_DEBUG("lmp TX intermon.bind_monitor_reply_scc\n");
    
    // try to send!
    intermon_bind_monitor_reply_scc__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_monitor_proxy_scc__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_coreid_t_t dst_core_id, intermon_caprep_t cap, intermon_chanid_t_t chan_id, intermon_coreid_t_t core_id)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_monitor_proxy_scc__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_monitor_proxy_scc).dst_core_id = dst_core_id;
    ((_binding->tx_union).bind_monitor_proxy_scc).cap = cap;
    ((_binding->tx_union).bind_monitor_proxy_scc).chan_id = chan_id;
    ((_binding->tx_union).bind_monitor_proxy_scc).core_id = core_id;
    FL_DEBUG("lmp TX intermon.bind_monitor_proxy_scc\n");
    
    // try to send!
    intermon_bind_monitor_proxy_scc__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_monitor_request_bmp__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_coreid_t_t core_id, intermon_chanid_t_t chan_id, intermon_coreid_t_t from_core_id)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_monitor_request_bmp__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_monitor_request_bmp).core_id = core_id;
    ((_binding->tx_union).bind_monitor_request_bmp).chan_id = chan_id;
    ((_binding->tx_union).bind_monitor_request_bmp).from_core_id = from_core_id;
    FL_DEBUG("lmp TX intermon.bind_monitor_request_bmp\n");
    
    // try to send!
    intermon_bind_monitor_request_bmp__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_monitor_reply_bmp__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_errval_t err, intermon_chanid_t_t chan_id, intermon_coreid_t_t core_id)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_monitor_reply_bmp__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_monitor_reply_bmp).err = err;
    ((_binding->tx_union).bind_monitor_reply_bmp).chan_id = chan_id;
    ((_binding->tx_union).bind_monitor_reply_bmp).core_id = core_id;
    FL_DEBUG("lmp TX intermon.bind_monitor_reply_bmp\n");
    
    // try to send!
    intermon_bind_monitor_reply_bmp__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_monitor_proxy_bmp__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_coreid_t_t dst_core_id, intermon_chanid_t_t chan_id, intermon_coreid_t_t core_id)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_monitor_proxy_bmp__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_monitor_proxy_bmp).dst_core_id = dst_core_id;
    ((_binding->tx_union).bind_monitor_proxy_bmp).chan_id = chan_id;
    ((_binding->tx_union).bind_monitor_proxy_bmp).core_id = core_id;
    FL_DEBUG("lmp TX intermon.bind_monitor_proxy_bmp\n");
    
    // try to send!
    intermon_bind_monitor_proxy_bmp__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_new_monitor_notify__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_coreid_t_t core_id)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_new_monitor_notify__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).new_monitor_notify).core_id = core_id;
    FL_DEBUG("lmp TX intermon.new_monitor_notify\n");
    
    // try to send!
    intermon_new_monitor_notify__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_ump_request__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, iref_t iref, intermon_mon_id_t_t mon_id, uint32_t channel_length_in, uint32_t channel_length_out, intermon_genpaddr_t framebase, uint8_t framebits, intermon_caprep_t notify)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_ump_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_ump_request).iref = iref;
    ((_binding->tx_union).bind_ump_request).mon_id = mon_id;
    ((_binding->tx_union).bind_ump_request).channel_length_in = channel_length_in;
    ((_binding->tx_union).bind_ump_request).channel_length_out = channel_length_out;
    ((_binding->tx_union).bind_ump_request).framebase = framebase;
    ((_binding->tx_union).bind_ump_request).framebits = framebits;
    ((_binding->tx_union).bind_ump_request).notify = notify;
    FL_DEBUG("lmp TX intermon.bind_ump_request\n");
    
    // try to send!
    intermon_bind_ump_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_ump_reply__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_con_id_t_t con_id, intermon_mon_id_t_t mon_id, intermon_errval_t err, intermon_caprep_t notify)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_ump_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_ump_reply).con_id = con_id;
    ((_binding->tx_union).bind_ump_reply).mon_id = mon_id;
    ((_binding->tx_union).bind_ump_reply).err = err;
    ((_binding->tx_union).bind_ump_reply).notify = notify;
    FL_DEBUG("lmp TX intermon.bind_ump_reply\n");
    
    // try to send!
    intermon_bind_ump_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_udn_request__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, iref_t iref, intermon_mon_id_t_t mon_id, intermon_caprep_t notify, intermon_coreid_t_t core_id, intermon_chanid_t_t chan_id, uint8_t asid)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_udn_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_udn_request).iref = iref;
    ((_binding->tx_union).bind_udn_request).mon_id = mon_id;
    ((_binding->tx_union).bind_udn_request).notify = notify;
    ((_binding->tx_union).bind_udn_request).core_id = core_id;
    ((_binding->tx_union).bind_udn_request).chan_id = chan_id;
    ((_binding->tx_union).bind_udn_request).asid = asid;
    FL_DEBUG("lmp TX intermon.bind_udn_request\n");
    
    // try to send!
    intermon_bind_udn_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_udn_reply__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_con_id_t_t con_id, intermon_mon_id_t_t mon_id, intermon_errval_t err, intermon_caprep_t notify, intermon_coreid_t_t core_id, intermon_chanid_t_t chan_id, uint8_t asid)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_udn_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_udn_reply).con_id = con_id;
    ((_binding->tx_union).bind_udn_reply).mon_id = mon_id;
    ((_binding->tx_union).bind_udn_reply).err = err;
    ((_binding->tx_union).bind_udn_reply).notify = notify;
    ((_binding->tx_union).bind_udn_reply).core_id = core_id;
    ((_binding->tx_union).bind_udn_reply).chan_id = chan_id;
    ((_binding->tx_union).bind_udn_reply).asid = asid;
    FL_DEBUG("lmp TX intermon.bind_udn_reply\n");
    
    // try to send!
    intermon_bind_udn_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_cap_send_request__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_con_id_t_t con_id, intermon_capid_t_t capid, intermon_caprep_t cap, intermon_errval_t err, bool give_away, bool has_descendents, intermon_coremask_t on_cores, bool null_cap)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_cap_send_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).cap_send_request).con_id = con_id;
    ((_binding->tx_union).cap_send_request).capid = capid;
    ((_binding->tx_union).cap_send_request).cap = cap;
    ((_binding->tx_union).cap_send_request).err = err;
    ((_binding->tx_union).cap_send_request).give_away = give_away;
    ((_binding->tx_union).cap_send_request).has_descendents = has_descendents;
    ((_binding->tx_union).cap_send_request).on_cores = ((intermon_coremask_t *)(on_cores));
    ((_binding->tx_union).cap_send_request).null_cap = null_cap;
    FL_DEBUG("lmp TX intermon.cap_send_request\n");
    
    // try to send!
    intermon_cap_send_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_span_domain_request__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_state_id_t_t state_id, intermon_genpaddr_t vnodebase, intermon_genpaddr_t framebase, uint8_t framebits)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_span_domain_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).span_domain_request).state_id = state_id;
    ((_binding->tx_union).span_domain_request).vnodebase = vnodebase;
    ((_binding->tx_union).span_domain_request).framebase = framebase;
    ((_binding->tx_union).span_domain_request).framebits = framebits;
    FL_DEBUG("lmp TX intermon.span_domain_request\n");
    
    // try to send!
    intermon_span_domain_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_span_domain_reply__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_state_id_t_t state_id, intermon_errval_t err)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_span_domain_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).span_domain_reply).state_id = state_id;
    ((_binding->tx_union).span_domain_reply).err = err;
    FL_DEBUG("lmp TX intermon.span_domain_reply\n");
    
    // try to send!
    intermon_span_domain_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_rsrc_join__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_rsrcid_t id, intermon_coreid_t_t coreid)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_rsrc_join__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).rsrc_join).id = id;
    ((_binding->tx_union).rsrc_join).coreid = coreid;
    FL_DEBUG("lmp TX intermon.rsrc_join\n");
    
    // try to send!
    intermon_rsrc_join__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_rsrc_join_complete__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_rsrcid_t id)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_rsrc_join_complete__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).rsrc_join_complete).id = id;
    FL_DEBUG("lmp TX intermon.rsrc_join_complete\n");
    
    // try to send!
    intermon_rsrc_join_complete__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_rsrc_phase_data__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_rsrcid_t id, uint32_t phase, const uint8_t *data, size_t len)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_rsrc_phase_data__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).rsrc_phase_data).id = id;
    ((_binding->tx_union).rsrc_phase_data).phase = phase;
    ((_binding->tx_union).rsrc_phase_data).data = ((uint8_t *)(data));
    ((_binding->tx_union).rsrc_phase_data).len = len;
    FL_DEBUG("lmp TX intermon.rsrc_phase_data\n");
    
    // try to send!
    intermon_rsrc_phase_data__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_rsrc_timer_sync__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, uint64_t timestamp)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_rsrc_timer_sync__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).rsrc_timer_sync).timestamp = timestamp;
    FL_DEBUG("lmp TX intermon.rsrc_timer_sync\n");
    
    // try to send!
    intermon_rsrc_timer_sync__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_rsrc_timer_sync_reply__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_errval_t err)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_rsrc_timer_sync_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).rsrc_timer_sync_reply).err = err;
    FL_DEBUG("lmp TX intermon.rsrc_timer_sync_reply\n");
    
    // try to send!
    intermon_rsrc_timer_sync_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_rsrc_phase__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_rsrcid_t id, uint32_t phase, uint64_t timestamp)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_rsrc_phase__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).rsrc_phase).id = id;
    ((_binding->tx_union).rsrc_phase).phase = phase;
    ((_binding->tx_union).rsrc_phase).timestamp = timestamp;
    FL_DEBUG("lmp TX intermon.rsrc_phase\n");
    
    // try to send!
    intermon_rsrc_phase__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_multihop_routing_table_request__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_coreid_t source_coreid)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_multihop_routing_table_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).multihop_routing_table_request).source_coreid = source_coreid;
    FL_DEBUG("lmp TX intermon.multihop_routing_table_request\n");
    
    // try to send!
    intermon_multihop_routing_table_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_multihop_routing_table_response__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_errval_t err, intermon_coreid_t source_coreid, intermon_coreid_t max_coreid, const intermon_coreid_t *to, size_t len)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_multihop_routing_table_response__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).multihop_routing_table_response).err = err;
    ((_binding->tx_union).multihop_routing_table_response).source_coreid = source_coreid;
    ((_binding->tx_union).multihop_routing_table_response).max_coreid = max_coreid;
    ((_binding->tx_union).multihop_routing_table_response).to = ((intermon_coreid_t *)(to));
    ((_binding->tx_union).multihop_routing_table_response).len = len;
    FL_DEBUG("lmp TX intermon.multihop_routing_table_response\n");
    
    // try to send!
    intermon_multihop_routing_table_response__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_multihop_routing_table_grow__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_coreid_t forwarder, const intermon_coreid_t *destinations, size_t len)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_multihop_routing_table_grow__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).multihop_routing_table_grow).forwarder = forwarder;
    ((_binding->tx_union).multihop_routing_table_grow).destinations = ((intermon_coreid_t *)(destinations));
    ((_binding->tx_union).multihop_routing_table_grow).len = len;
    FL_DEBUG("lmp TX intermon.multihop_routing_table_grow\n");
    
    // try to send!
    intermon_multihop_routing_table_grow__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_multihop_intermon_request__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, iref_t iref, intermon_vci_t_t sender_vci, intermon_coreid_t core_id)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_multihop_intermon_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_multihop_intermon_request).iref = iref;
    ((_binding->tx_union).bind_multihop_intermon_request).sender_vci = sender_vci;
    ((_binding->tx_union).bind_multihop_intermon_request).core_id = core_id;
    FL_DEBUG("lmp TX intermon.bind_multihop_intermon_request\n");
    
    // try to send!
    intermon_bind_multihop_intermon_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_multihop_intermon_reply__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_vci_t_t receiver_vci, intermon_vci_t_t sender_vci, intermon_errval_t err)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_multihop_intermon_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_multihop_intermon_reply).receiver_vci = receiver_vci;
    ((_binding->tx_union).bind_multihop_intermon_reply).sender_vci = sender_vci;
    ((_binding->tx_union).bind_multihop_intermon_reply).err = err;
    FL_DEBUG("lmp TX intermon.bind_multihop_intermon_reply\n");
    
    // try to send!
    intermon_bind_multihop_intermon_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_multihop_message__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_vci_t_t vci, uint8_t direction, uint8_t flags, uint32_t ack, const uint8_t *payload, size_t size)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_multihop_message__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).multihop_message).vci = vci;
    ((_binding->tx_union).multihop_message).direction = direction;
    ((_binding->tx_union).multihop_message).flags = flags;
    ((_binding->tx_union).multihop_message).ack = ack;
    ((_binding->tx_union).multihop_message).payload = ((uint8_t *)(payload));
    ((_binding->tx_union).multihop_message).size = size;
    FL_DEBUG("lmp TX intermon.multihop_message\n");
    
    // try to send!
    intermon_multihop_message__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_multihop_cap_send__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_vci_t_t vci, uint8_t direction, intermon_capid_t_t capid, intermon_errval_t err, intermon_caprep_t cap, bool null_cap)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_multihop_cap_send__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).multihop_cap_send).vci = vci;
    ((_binding->tx_union).multihop_cap_send).direction = direction;
    ((_binding->tx_union).multihop_cap_send).capid = capid;
    ((_binding->tx_union).multihop_cap_send).err = err;
    ((_binding->tx_union).multihop_cap_send).cap = cap;
    ((_binding->tx_union).multihop_cap_send).null_cap = null_cap;
    FL_DEBUG("lmp TX intermon.multihop_cap_send\n");
    
    // try to send!
    intermon_multihop_cap_send__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_trace_prepare__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_coreid_t origin_core)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_trace_prepare__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).trace_prepare).origin_core = origin_core;
    FL_DEBUG("lmp TX intermon.trace_prepare\n");
    
    // try to send!
    intermon_trace_prepare__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_trace_prepare_finished__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_trace_prepare_finished__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX intermon.trace_prepare_finished\n");
    
    // try to send!
    intermon_trace_prepare_finished__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_trace_measure__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_coreid_t_t origin_core, uint64_t t0)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_trace_measure__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).trace_measure).origin_core = origin_core;
    ((_binding->tx_union).trace_measure).t0 = t0;
    FL_DEBUG("lmp TX intermon.trace_measure\n");
    
    // try to send!
    intermon_trace_measure__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_trace_measure_ack__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_coreid_t origin_core, uint64_t t0, uint64_t t1, uint64_t t2)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_trace_measure_ack__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).trace_measure_ack).origin_core = origin_core;
    ((_binding->tx_union).trace_measure_ack).t0 = t0;
    ((_binding->tx_union).trace_measure_ack).t1 = t1;
    ((_binding->tx_union).trace_measure_ack).t2 = t2;
    FL_DEBUG("lmp TX intermon.trace_measure_ack\n");
    
    // try to send!
    intermon_trace_measure_ack__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bfscope_flush_send_forward__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation, iref_t iref)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bfscope_flush_send_forward__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bfscope_flush_send_forward).iref = iref;
    FL_DEBUG("lmp TX intermon.bfscope_flush_send_forward\n");
    
    // try to send!
    intermon_bfscope_flush_send_forward__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bfscope_flush_ack_forward__lmp_send(struct intermon_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bfscope_flush_ack_forward__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX intermon.bfscope_flush_ack_forward\n");
    
    // try to send!
    intermon_bfscope_flush_ack_forward__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}


/*
 * Send vtable
 */
static  struct intermon_tx_vtbl intermon_lmp_tx_vtbl = {
    .spawnd_image_request = intermon_spawnd_image_request__lmp_send,
    .spawnd_image_reply = intermon_spawnd_image_reply__lmp_send,
    .monitor_initialized = intermon_monitor_initialized__lmp_send,
    .trace_caps_request = intermon_trace_caps_request__lmp_send,
    .trace_caps_reply = intermon_trace_caps_reply__lmp_send,
    .mem_serv_iref_request = intermon_mem_serv_iref_request__lmp_send,
    .mem_serv_iref_reply = intermon_mem_serv_iref_reply__lmp_send,
    .ramfs_serv_iref_request = intermon_ramfs_serv_iref_request__lmp_send,
    .ramfs_serv_iref_reply = intermon_ramfs_serv_iref_reply__lmp_send,
    .name_serv_iref_request = intermon_name_serv_iref_request__lmp_send,
    .name_serv_iref_reply = intermon_name_serv_iref_reply__lmp_send,
    .monitor_mem_iref_request = intermon_monitor_mem_iref_request__lmp_send,
    .monitor_mem_iref_reply = intermon_monitor_mem_iref_reply__lmp_send,
    .bind_monitor_request = intermon_bind_monitor_request__lmp_send,
    .bind_monitor_reply = intermon_bind_monitor_reply__lmp_send,
    .bind_monitor_proxy = intermon_bind_monitor_proxy__lmp_send,
    .bind_monitor_request_scc = intermon_bind_monitor_request_scc__lmp_send,
    .bind_monitor_reply_scc = intermon_bind_monitor_reply_scc__lmp_send,
    .bind_monitor_proxy_scc = intermon_bind_monitor_proxy_scc__lmp_send,
    .bind_monitor_request_bmp = intermon_bind_monitor_request_bmp__lmp_send,
    .bind_monitor_reply_bmp = intermon_bind_monitor_reply_bmp__lmp_send,
    .bind_monitor_proxy_bmp = intermon_bind_monitor_proxy_bmp__lmp_send,
    .new_monitor_notify = intermon_new_monitor_notify__lmp_send,
    .bind_ump_request = intermon_bind_ump_request__lmp_send,
    .bind_ump_reply = intermon_bind_ump_reply__lmp_send,
    .bind_udn_request = intermon_bind_udn_request__lmp_send,
    .bind_udn_reply = intermon_bind_udn_reply__lmp_send,
    .cap_send_request = intermon_cap_send_request__lmp_send,
    .span_domain_request = intermon_span_domain_request__lmp_send,
    .span_domain_reply = intermon_span_domain_reply__lmp_send,
    .rsrc_join = intermon_rsrc_join__lmp_send,
    .rsrc_join_complete = intermon_rsrc_join_complete__lmp_send,
    .rsrc_phase_data = intermon_rsrc_phase_data__lmp_send,
    .rsrc_timer_sync = intermon_rsrc_timer_sync__lmp_send,
    .rsrc_timer_sync_reply = intermon_rsrc_timer_sync_reply__lmp_send,
    .rsrc_phase = intermon_rsrc_phase__lmp_send,
    .multihop_routing_table_request = intermon_multihop_routing_table_request__lmp_send,
    .multihop_routing_table_response = intermon_multihop_routing_table_response__lmp_send,
    .multihop_routing_table_grow = intermon_multihop_routing_table_grow__lmp_send,
    .bind_multihop_intermon_request = intermon_bind_multihop_intermon_request__lmp_send,
    .bind_multihop_intermon_reply = intermon_bind_multihop_intermon_reply__lmp_send,
    .multihop_message = intermon_multihop_message__lmp_send,
    .multihop_cap_send = intermon_multihop_cap_send__lmp_send,
    .trace_prepare = intermon_trace_prepare__lmp_send,
    .trace_prepare_finished = intermon_trace_prepare_finished__lmp_send,
    .trace_measure = intermon_trace_measure__lmp_send,
    .trace_measure_ack = intermon_trace_measure_ack__lmp_send,
    .bfscope_flush_send_forward = intermon_bfscope_flush_send_forward__lmp_send,
    .bfscope_flush_ack_forward = intermon_bfscope_flush_ack_forward__lmp_send,
};
/*
 * Receive handler
 */
 void intermon_lmp_rx_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_lmp_binding *b = arg;
    errval_t err;
    
    struct lmp_recv_msg msg = LMP_RECV_MSG_INIT;
    struct capref cap;
    struct event_closure recv_closure = (struct event_closure){  .handler = intermon_lmp_rx_handler,  .arg = arg };
    
    do {
        // try to retrieve a message from the channel
        err = lmp_chan_recv(&(b->chan), &msg, &cap);
        // check if we succeeded
        if (err_is_fail(err)) {
            if (err_no(err) == LIB_ERR_NO_LMP_MSG) {
                // no message
                break;
            } else {
                // real error
                (_binding->error_handler)(_binding, err_push(err, LIB_ERR_LMP_CHAN_RECV));
                return;
            }
        }
        
        // allocate a new receive slot if needed
        if (!capref_is_null(cap)) {
            err = lmp_chan_alloc_recv_slot(&(b->chan));
            if (err_is_fail(err)) {
                (_binding->error_handler)(_binding, err_push(err, LIB_ERR_LMP_ALLOC_RECV_SLOT));
            }
        }
        
        // is this the start of a new message?
        if ((_binding->rx_msgnum) == 0) {
            // check message length
            if (((msg.buf).msglen) == 0) {
                (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_EMPTY_MSG);
                break;
            }
            // unmarshall message number from first word, set fragment to 0
            _binding->rx_msgnum = (((msg.words)[0]) & 0xffff);
            _binding->rx_msg_fragment = 0;
        }
        
        // switch on message number and fragment number
        switch (_binding->rx_msgnum) {
        case intermon_spawnd_image_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 1) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX intermon.spawnd_image_request\n");
                assert(((_binding->rx_vtbl).spawnd_image_request) != NULL);
                ((_binding->rx_vtbl).spawnd_image_request)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_spawnd_image_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).spawnd_image_reply).base = ((msg.words)[1]);
                ((_binding->rx_union).spawnd_image_reply).base = ((((_binding->rx_union).spawnd_image_reply).base) | (((uint64_t )((msg.words)[2])) << 32));
                ((_binding->rx_union).spawnd_image_reply).bytes = ((msg.words)[3]);
                
                FL_DEBUG("lmp RX intermon.spawnd_image_reply\n");
                assert(((_binding->rx_vtbl).spawnd_image_reply) != NULL);
                ((_binding->rx_vtbl).spawnd_image_reply)(_binding, ((_binding->rx_union).spawnd_image_reply).base, ((_binding->rx_union).spawnd_image_reply).bytes);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_monitor_initialized__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 1) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX intermon.monitor_initialized\n");
                assert(((_binding->rx_vtbl).monitor_initialized) != NULL);
                ((_binding->rx_vtbl).monitor_initialized)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_trace_caps_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 1) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX intermon.trace_caps_request\n");
                assert(((_binding->rx_vtbl).trace_caps_request) != NULL);
                ((_binding->rx_vtbl).trace_caps_request)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_trace_caps_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 7) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                (((_binding->rx_union).trace_caps_reply).cap).w0 = ((msg.words)[1]);
                (((_binding->rx_union).trace_caps_reply).cap).w0 = (((((_binding->rx_union).trace_caps_reply).cap).w0) | (((uint64_t )((msg.words)[2])) << 32));
                (((_binding->rx_union).trace_caps_reply).cap).w1 = ((msg.words)[3]);
                (((_binding->rx_union).trace_caps_reply).cap).w1 = (((((_binding->rx_union).trace_caps_reply).cap).w1) | (((uint64_t )((msg.words)[4])) << 32));
                (((_binding->rx_union).trace_caps_reply).cap).w2 = ((msg.words)[5]);
                (((_binding->rx_union).trace_caps_reply).cap).w2 = (((((_binding->rx_union).trace_caps_reply).cap).w2) | (((uint64_t )((msg.words)[6])) << 32));
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                // check length
                if (((msg.buf).msglen) != 2) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                (((_binding->rx_union).trace_caps_reply).cap).w3 = ((msg.words)[0]);
                (((_binding->rx_union).trace_caps_reply).cap).w3 = (((((_binding->rx_union).trace_caps_reply).cap).w3) | (((uint64_t )((msg.words)[1])) << 32));
                
                FL_DEBUG("lmp RX intermon.trace_caps_reply\n");
                assert(((_binding->rx_vtbl).trace_caps_reply) != NULL);
                ((_binding->rx_vtbl).trace_caps_reply)(_binding, ((_binding->rx_union).trace_caps_reply).cap);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_mem_serv_iref_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 1) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX intermon.mem_serv_iref_request\n");
                assert(((_binding->rx_vtbl).mem_serv_iref_request) != NULL);
                ((_binding->rx_vtbl).mem_serv_iref_request)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_mem_serv_iref_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 2) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).mem_serv_iref_reply).iref = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX intermon.mem_serv_iref_reply\n");
                assert(((_binding->rx_vtbl).mem_serv_iref_reply) != NULL);
                ((_binding->rx_vtbl).mem_serv_iref_reply)(_binding, ((_binding->rx_union).mem_serv_iref_reply).iref);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_ramfs_serv_iref_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 1) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX intermon.ramfs_serv_iref_request\n");
                assert(((_binding->rx_vtbl).ramfs_serv_iref_request) != NULL);
                ((_binding->rx_vtbl).ramfs_serv_iref_request)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_ramfs_serv_iref_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 2) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).ramfs_serv_iref_reply).iref = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX intermon.ramfs_serv_iref_reply\n");
                assert(((_binding->rx_vtbl).ramfs_serv_iref_reply) != NULL);
                ((_binding->rx_vtbl).ramfs_serv_iref_reply)(_binding, ((_binding->rx_union).ramfs_serv_iref_reply).iref);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_name_serv_iref_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 1) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX intermon.name_serv_iref_request\n");
                assert(((_binding->rx_vtbl).name_serv_iref_request) != NULL);
                ((_binding->rx_vtbl).name_serv_iref_request)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_name_serv_iref_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 2) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).name_serv_iref_reply).iref = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX intermon.name_serv_iref_reply\n");
                assert(((_binding->rx_vtbl).name_serv_iref_reply) != NULL);
                ((_binding->rx_vtbl).name_serv_iref_reply)(_binding, ((_binding->rx_union).name_serv_iref_reply).iref);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_monitor_mem_iref_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 1) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX intermon.monitor_mem_iref_request\n");
                assert(((_binding->rx_vtbl).monitor_mem_iref_request) != NULL);
                ((_binding->rx_vtbl).monitor_mem_iref_request)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_monitor_mem_iref_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 2) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).monitor_mem_iref_reply).iref = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX intermon.monitor_mem_iref_reply\n");
                assert(((_binding->rx_vtbl).monitor_mem_iref_reply) != NULL);
                ((_binding->rx_vtbl).monitor_mem_iref_reply)(_binding, ((_binding->rx_union).monitor_mem_iref_reply).iref);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_monitor_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 7) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_monitor_request).core_id = ((((msg.words)[0]) >> 16) & 0xff);
                (((_binding->rx_union).bind_monitor_request).cap).w0 = ((msg.words)[1]);
                (((_binding->rx_union).bind_monitor_request).cap).w0 = (((((_binding->rx_union).bind_monitor_request).cap).w0) | (((uint64_t )((msg.words)[2])) << 32));
                (((_binding->rx_union).bind_monitor_request).cap).w1 = ((msg.words)[3]);
                (((_binding->rx_union).bind_monitor_request).cap).w1 = (((((_binding->rx_union).bind_monitor_request).cap).w1) | (((uint64_t )((msg.words)[4])) << 32));
                (((_binding->rx_union).bind_monitor_request).cap).w2 = ((msg.words)[5]);
                (((_binding->rx_union).bind_monitor_request).cap).w2 = (((((_binding->rx_union).bind_monitor_request).cap).w2) | (((uint64_t )((msg.words)[6])) << 32));
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                // check length
                if (((msg.buf).msglen) != 2) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                (((_binding->rx_union).bind_monitor_request).cap).w3 = ((msg.words)[0]);
                (((_binding->rx_union).bind_monitor_request).cap).w3 = (((((_binding->rx_union).bind_monitor_request).cap).w3) | (((uint64_t )((msg.words)[1])) << 32));
                
                FL_DEBUG("lmp RX intermon.bind_monitor_request\n");
                assert(((_binding->rx_vtbl).bind_monitor_request) != NULL);
                ((_binding->rx_vtbl).bind_monitor_request)(_binding, ((_binding->rx_union).bind_monitor_request).core_id, ((_binding->rx_union).bind_monitor_request).cap);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_monitor_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 2) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_monitor_reply).err = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX intermon.bind_monitor_reply\n");
                assert(((_binding->rx_vtbl).bind_monitor_reply) != NULL);
                ((_binding->rx_vtbl).bind_monitor_reply)(_binding, ((_binding->rx_union).bind_monitor_reply).err);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_monitor_proxy__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 7) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_monitor_proxy).dst_core_id = ((((msg.words)[0]) >> 16) & 0xff);
                (((_binding->rx_union).bind_monitor_proxy).cap).w0 = ((msg.words)[1]);
                (((_binding->rx_union).bind_monitor_proxy).cap).w0 = (((((_binding->rx_union).bind_monitor_proxy).cap).w0) | (((uint64_t )((msg.words)[2])) << 32));
                (((_binding->rx_union).bind_monitor_proxy).cap).w1 = ((msg.words)[3]);
                (((_binding->rx_union).bind_monitor_proxy).cap).w1 = (((((_binding->rx_union).bind_monitor_proxy).cap).w1) | (((uint64_t )((msg.words)[4])) << 32));
                (((_binding->rx_union).bind_monitor_proxy).cap).w2 = ((msg.words)[5]);
                (((_binding->rx_union).bind_monitor_proxy).cap).w2 = (((((_binding->rx_union).bind_monitor_proxy).cap).w2) | (((uint64_t )((msg.words)[6])) << 32));
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                // check length
                if (((msg.buf).msglen) != 2) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                (((_binding->rx_union).bind_monitor_proxy).cap).w3 = ((msg.words)[0]);
                (((_binding->rx_union).bind_monitor_proxy).cap).w3 = (((((_binding->rx_union).bind_monitor_proxy).cap).w3) | (((uint64_t )((msg.words)[1])) << 32));
                
                FL_DEBUG("lmp RX intermon.bind_monitor_proxy\n");
                assert(((_binding->rx_vtbl).bind_monitor_proxy) != NULL);
                ((_binding->rx_vtbl).bind_monitor_proxy)(_binding, ((_binding->rx_union).bind_monitor_proxy).dst_core_id, ((_binding->rx_union).bind_monitor_proxy).cap);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_monitor_request_scc__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 7) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_monitor_request_scc).core_id = ((((msg.words)[0]) >> 16) & 0xff);
                ((_binding->rx_union).bind_monitor_request_scc).from_core_id = ((((msg.words)[0]) >> 24) & 0xff);
                (((_binding->rx_union).bind_monitor_request_scc).cap).w0 = ((msg.words)[1]);
                (((_binding->rx_union).bind_monitor_request_scc).cap).w0 = (((((_binding->rx_union).bind_monitor_request_scc).cap).w0) | (((uint64_t )((msg.words)[2])) << 32));
                (((_binding->rx_union).bind_monitor_request_scc).cap).w1 = ((msg.words)[3]);
                (((_binding->rx_union).bind_monitor_request_scc).cap).w1 = (((((_binding->rx_union).bind_monitor_request_scc).cap).w1) | (((uint64_t )((msg.words)[4])) << 32));
                (((_binding->rx_union).bind_monitor_request_scc).cap).w2 = ((msg.words)[5]);
                (((_binding->rx_union).bind_monitor_request_scc).cap).w2 = (((((_binding->rx_union).bind_monitor_request_scc).cap).w2) | (((uint64_t )((msg.words)[6])) << 32));
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                // check length
                if (((msg.buf).msglen) != 3) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                (((_binding->rx_union).bind_monitor_request_scc).cap).w3 = ((msg.words)[0]);
                (((_binding->rx_union).bind_monitor_request_scc).cap).w3 = (((((_binding->rx_union).bind_monitor_request_scc).cap).w3) | (((uint64_t )((msg.words)[1])) << 32));
                ((_binding->rx_union).bind_monitor_request_scc).chan_id = ((msg.words)[2]);
                
                FL_DEBUG("lmp RX intermon.bind_monitor_request_scc\n");
                assert(((_binding->rx_vtbl).bind_monitor_request_scc) != NULL);
                ((_binding->rx_vtbl).bind_monitor_request_scc)(_binding, ((_binding->rx_union).bind_monitor_request_scc).core_id, ((_binding->rx_union).bind_monitor_request_scc).cap, ((_binding->rx_union).bind_monitor_request_scc).chan_id, ((_binding->rx_union).bind_monitor_request_scc).from_core_id);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_monitor_reply_scc__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 3) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_monitor_reply_scc).core_id = ((((msg.words)[0]) >> 16) & 0xff);
                ((_binding->rx_union).bind_monitor_reply_scc).err = ((msg.words)[1]);
                ((_binding->rx_union).bind_monitor_reply_scc).chan_id = ((msg.words)[2]);
                
                FL_DEBUG("lmp RX intermon.bind_monitor_reply_scc\n");
                assert(((_binding->rx_vtbl).bind_monitor_reply_scc) != NULL);
                ((_binding->rx_vtbl).bind_monitor_reply_scc)(_binding, ((_binding->rx_union).bind_monitor_reply_scc).err, ((_binding->rx_union).bind_monitor_reply_scc).chan_id, ((_binding->rx_union).bind_monitor_reply_scc).core_id);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_monitor_proxy_scc__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 7) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_monitor_proxy_scc).dst_core_id = ((((msg.words)[0]) >> 16) & 0xff);
                ((_binding->rx_union).bind_monitor_proxy_scc).core_id = ((((msg.words)[0]) >> 24) & 0xff);
                (((_binding->rx_union).bind_monitor_proxy_scc).cap).w0 = ((msg.words)[1]);
                (((_binding->rx_union).bind_monitor_proxy_scc).cap).w0 = (((((_binding->rx_union).bind_monitor_proxy_scc).cap).w0) | (((uint64_t )((msg.words)[2])) << 32));
                (((_binding->rx_union).bind_monitor_proxy_scc).cap).w1 = ((msg.words)[3]);
                (((_binding->rx_union).bind_monitor_proxy_scc).cap).w1 = (((((_binding->rx_union).bind_monitor_proxy_scc).cap).w1) | (((uint64_t )((msg.words)[4])) << 32));
                (((_binding->rx_union).bind_monitor_proxy_scc).cap).w2 = ((msg.words)[5]);
                (((_binding->rx_union).bind_monitor_proxy_scc).cap).w2 = (((((_binding->rx_union).bind_monitor_proxy_scc).cap).w2) | (((uint64_t )((msg.words)[6])) << 32));
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                // check length
                if (((msg.buf).msglen) != 3) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                (((_binding->rx_union).bind_monitor_proxy_scc).cap).w3 = ((msg.words)[0]);
                (((_binding->rx_union).bind_monitor_proxy_scc).cap).w3 = (((((_binding->rx_union).bind_monitor_proxy_scc).cap).w3) | (((uint64_t )((msg.words)[1])) << 32));
                ((_binding->rx_union).bind_monitor_proxy_scc).chan_id = ((msg.words)[2]);
                
                FL_DEBUG("lmp RX intermon.bind_monitor_proxy_scc\n");
                assert(((_binding->rx_vtbl).bind_monitor_proxy_scc) != NULL);
                ((_binding->rx_vtbl).bind_monitor_proxy_scc)(_binding, ((_binding->rx_union).bind_monitor_proxy_scc).dst_core_id, ((_binding->rx_union).bind_monitor_proxy_scc).cap, ((_binding->rx_union).bind_monitor_proxy_scc).chan_id, ((_binding->rx_union).bind_monitor_proxy_scc).core_id);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_monitor_request_bmp__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 2) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_monitor_request_bmp).core_id = ((((msg.words)[0]) >> 16) & 0xff);
                ((_binding->rx_union).bind_monitor_request_bmp).from_core_id = ((((msg.words)[0]) >> 24) & 0xff);
                ((_binding->rx_union).bind_monitor_request_bmp).chan_id = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX intermon.bind_monitor_request_bmp\n");
                assert(((_binding->rx_vtbl).bind_monitor_request_bmp) != NULL);
                ((_binding->rx_vtbl).bind_monitor_request_bmp)(_binding, ((_binding->rx_union).bind_monitor_request_bmp).core_id, ((_binding->rx_union).bind_monitor_request_bmp).chan_id, ((_binding->rx_union).bind_monitor_request_bmp).from_core_id);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_monitor_reply_bmp__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 3) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_monitor_reply_bmp).core_id = ((((msg.words)[0]) >> 16) & 0xff);
                ((_binding->rx_union).bind_monitor_reply_bmp).err = ((msg.words)[1]);
                ((_binding->rx_union).bind_monitor_reply_bmp).chan_id = ((msg.words)[2]);
                
                FL_DEBUG("lmp RX intermon.bind_monitor_reply_bmp\n");
                assert(((_binding->rx_vtbl).bind_monitor_reply_bmp) != NULL);
                ((_binding->rx_vtbl).bind_monitor_reply_bmp)(_binding, ((_binding->rx_union).bind_monitor_reply_bmp).err, ((_binding->rx_union).bind_monitor_reply_bmp).chan_id, ((_binding->rx_union).bind_monitor_reply_bmp).core_id);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_monitor_proxy_bmp__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 2) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_monitor_proxy_bmp).dst_core_id = ((((msg.words)[0]) >> 16) & 0xff);
                ((_binding->rx_union).bind_monitor_proxy_bmp).core_id = ((((msg.words)[0]) >> 24) & 0xff);
                ((_binding->rx_union).bind_monitor_proxy_bmp).chan_id = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX intermon.bind_monitor_proxy_bmp\n");
                assert(((_binding->rx_vtbl).bind_monitor_proxy_bmp) != NULL);
                ((_binding->rx_vtbl).bind_monitor_proxy_bmp)(_binding, ((_binding->rx_union).bind_monitor_proxy_bmp).dst_core_id, ((_binding->rx_union).bind_monitor_proxy_bmp).chan_id, ((_binding->rx_union).bind_monitor_proxy_bmp).core_id);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_new_monitor_notify__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 1) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).new_monitor_notify).core_id = ((((msg.words)[0]) >> 16) & 0xff);
                
                FL_DEBUG("lmp RX intermon.new_monitor_notify\n");
                assert(((_binding->rx_vtbl).new_monitor_notify) != NULL);
                ((_binding->rx_vtbl).new_monitor_notify)(_binding, ((_binding->rx_union).new_monitor_notify).core_id);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_ump_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 7) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_ump_request).framebits = ((((msg.words)[0]) >> 16) & 0xff);
                ((_binding->rx_union).bind_ump_request).iref = ((msg.words)[1]);
                ((_binding->rx_union).bind_ump_request).mon_id = ((msg.words)[2]);
                ((_binding->rx_union).bind_ump_request).mon_id = ((((_binding->rx_union).bind_ump_request).mon_id) | (((uint64_t )((msg.words)[3])) << 32));
                ((_binding->rx_union).bind_ump_request).channel_length_in = ((msg.words)[4]);
                ((_binding->rx_union).bind_ump_request).channel_length_out = ((msg.words)[5]);
                ((_binding->rx_union).bind_ump_request).framebase = ((msg.words)[6]);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                // check length
                if (((msg.buf).msglen) != 7) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_ump_request).framebase = ((((_binding->rx_union).bind_ump_request).framebase) | (((uint64_t )((msg.words)[0])) << 32));
                (((_binding->rx_union).bind_ump_request).notify).w0 = ((msg.words)[1]);
                (((_binding->rx_union).bind_ump_request).notify).w0 = (((((_binding->rx_union).bind_ump_request).notify).w0) | (((uint64_t )((msg.words)[2])) << 32));
                (((_binding->rx_union).bind_ump_request).notify).w1 = ((msg.words)[3]);
                (((_binding->rx_union).bind_ump_request).notify).w1 = (((((_binding->rx_union).bind_ump_request).notify).w1) | (((uint64_t )((msg.words)[4])) << 32));
                (((_binding->rx_union).bind_ump_request).notify).w2 = ((msg.words)[5]);
                (((_binding->rx_union).bind_ump_request).notify).w2 = (((((_binding->rx_union).bind_ump_request).notify).w2) | (((uint64_t )((msg.words)[6])) << 32));
                
                (_binding->rx_msg_fragment)++;
                break;
            case 2:
                // check length
                if (((msg.buf).msglen) != 2) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                (((_binding->rx_union).bind_ump_request).notify).w3 = ((msg.words)[0]);
                (((_binding->rx_union).bind_ump_request).notify).w3 = (((((_binding->rx_union).bind_ump_request).notify).w3) | (((uint64_t )((msg.words)[1])) << 32));
                
                FL_DEBUG("lmp RX intermon.bind_ump_request\n");
                assert(((_binding->rx_vtbl).bind_ump_request) != NULL);
                ((_binding->rx_vtbl).bind_ump_request)(_binding, ((_binding->rx_union).bind_ump_request).iref, ((_binding->rx_union).bind_ump_request).mon_id, ((_binding->rx_union).bind_ump_request).channel_length_in, ((_binding->rx_union).bind_ump_request).channel_length_out, ((_binding->rx_union).bind_ump_request).framebase, ((_binding->rx_union).bind_ump_request).framebits, ((_binding->rx_union).bind_ump_request).notify);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_ump_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 7) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_ump_reply).con_id = ((msg.words)[1]);
                ((_binding->rx_union).bind_ump_reply).con_id = ((((_binding->rx_union).bind_ump_reply).con_id) | (((uint64_t )((msg.words)[2])) << 32));
                ((_binding->rx_union).bind_ump_reply).mon_id = ((msg.words)[3]);
                ((_binding->rx_union).bind_ump_reply).mon_id = ((((_binding->rx_union).bind_ump_reply).mon_id) | (((uint64_t )((msg.words)[4])) << 32));
                ((_binding->rx_union).bind_ump_reply).err = ((msg.words)[5]);
                (((_binding->rx_union).bind_ump_reply).notify).w0 = ((msg.words)[6]);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                // check length
                if (((msg.buf).msglen) != 7) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                (((_binding->rx_union).bind_ump_reply).notify).w0 = (((((_binding->rx_union).bind_ump_reply).notify).w0) | (((uint64_t )((msg.words)[0])) << 32));
                (((_binding->rx_union).bind_ump_reply).notify).w1 = ((msg.words)[1]);
                (((_binding->rx_union).bind_ump_reply).notify).w1 = (((((_binding->rx_union).bind_ump_reply).notify).w1) | (((uint64_t )((msg.words)[2])) << 32));
                (((_binding->rx_union).bind_ump_reply).notify).w2 = ((msg.words)[3]);
                (((_binding->rx_union).bind_ump_reply).notify).w2 = (((((_binding->rx_union).bind_ump_reply).notify).w2) | (((uint64_t )((msg.words)[4])) << 32));
                (((_binding->rx_union).bind_ump_reply).notify).w3 = ((msg.words)[5]);
                (((_binding->rx_union).bind_ump_reply).notify).w3 = (((((_binding->rx_union).bind_ump_reply).notify).w3) | (((uint64_t )((msg.words)[6])) << 32));
                
                FL_DEBUG("lmp RX intermon.bind_ump_reply\n");
                assert(((_binding->rx_vtbl).bind_ump_reply) != NULL);
                ((_binding->rx_vtbl).bind_ump_reply)(_binding, ((_binding->rx_union).bind_ump_reply).con_id, ((_binding->rx_union).bind_ump_reply).mon_id, ((_binding->rx_union).bind_ump_reply).err, ((_binding->rx_union).bind_ump_reply).notify);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_udn_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 7) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_udn_request).core_id = ((((msg.words)[0]) >> 16) & 0xff);
                ((_binding->rx_union).bind_udn_request).asid = ((((msg.words)[0]) >> 24) & 0xff);
                ((_binding->rx_union).bind_udn_request).iref = ((msg.words)[1]);
                ((_binding->rx_union).bind_udn_request).mon_id = ((msg.words)[2]);
                ((_binding->rx_union).bind_udn_request).mon_id = ((((_binding->rx_union).bind_udn_request).mon_id) | (((uint64_t )((msg.words)[3])) << 32));
                (((_binding->rx_union).bind_udn_request).notify).w0 = ((msg.words)[4]);
                (((_binding->rx_union).bind_udn_request).notify).w0 = (((((_binding->rx_union).bind_udn_request).notify).w0) | (((uint64_t )((msg.words)[5])) << 32));
                (((_binding->rx_union).bind_udn_request).notify).w1 = ((msg.words)[6]);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                // check length
                if (((msg.buf).msglen) != 6) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                (((_binding->rx_union).bind_udn_request).notify).w1 = (((((_binding->rx_union).bind_udn_request).notify).w1) | (((uint64_t )((msg.words)[0])) << 32));
                (((_binding->rx_union).bind_udn_request).notify).w2 = ((msg.words)[1]);
                (((_binding->rx_union).bind_udn_request).notify).w2 = (((((_binding->rx_union).bind_udn_request).notify).w2) | (((uint64_t )((msg.words)[2])) << 32));
                (((_binding->rx_union).bind_udn_request).notify).w3 = ((msg.words)[3]);
                (((_binding->rx_union).bind_udn_request).notify).w3 = (((((_binding->rx_union).bind_udn_request).notify).w3) | (((uint64_t )((msg.words)[4])) << 32));
                ((_binding->rx_union).bind_udn_request).chan_id = ((msg.words)[5]);
                
                FL_DEBUG("lmp RX intermon.bind_udn_request\n");
                assert(((_binding->rx_vtbl).bind_udn_request) != NULL);
                ((_binding->rx_vtbl).bind_udn_request)(_binding, ((_binding->rx_union).bind_udn_request).iref, ((_binding->rx_union).bind_udn_request).mon_id, ((_binding->rx_union).bind_udn_request).notify, ((_binding->rx_union).bind_udn_request).core_id, ((_binding->rx_union).bind_udn_request).chan_id, ((_binding->rx_union).bind_udn_request).asid);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_udn_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 7) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_udn_reply).core_id = ((((msg.words)[0]) >> 16) & 0xff);
                ((_binding->rx_union).bind_udn_reply).asid = ((((msg.words)[0]) >> 24) & 0xff);
                ((_binding->rx_union).bind_udn_reply).con_id = ((msg.words)[1]);
                ((_binding->rx_union).bind_udn_reply).con_id = ((((_binding->rx_union).bind_udn_reply).con_id) | (((uint64_t )((msg.words)[2])) << 32));
                ((_binding->rx_union).bind_udn_reply).mon_id = ((msg.words)[3]);
                ((_binding->rx_union).bind_udn_reply).mon_id = ((((_binding->rx_union).bind_udn_reply).mon_id) | (((uint64_t )((msg.words)[4])) << 32));
                ((_binding->rx_union).bind_udn_reply).err = ((msg.words)[5]);
                (((_binding->rx_union).bind_udn_reply).notify).w0 = ((msg.words)[6]);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                // check length
                if (((msg.buf).msglen) != 7) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                (((_binding->rx_union).bind_udn_reply).notify).w0 = (((((_binding->rx_union).bind_udn_reply).notify).w0) | (((uint64_t )((msg.words)[0])) << 32));
                (((_binding->rx_union).bind_udn_reply).notify).w1 = ((msg.words)[1]);
                (((_binding->rx_union).bind_udn_reply).notify).w1 = (((((_binding->rx_union).bind_udn_reply).notify).w1) | (((uint64_t )((msg.words)[2])) << 32));
                (((_binding->rx_union).bind_udn_reply).notify).w2 = ((msg.words)[3]);
                (((_binding->rx_union).bind_udn_reply).notify).w2 = (((((_binding->rx_union).bind_udn_reply).notify).w2) | (((uint64_t )((msg.words)[4])) << 32));
                (((_binding->rx_union).bind_udn_reply).notify).w3 = ((msg.words)[5]);
                (((_binding->rx_union).bind_udn_reply).notify).w3 = (((((_binding->rx_union).bind_udn_reply).notify).w3) | (((uint64_t )((msg.words)[6])) << 32));
                
                (_binding->rx_msg_fragment)++;
                break;
            case 2:
                // check length
                if (((msg.buf).msglen) != 1) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_udn_reply).chan_id = ((msg.words)[0]);
                
                FL_DEBUG("lmp RX intermon.bind_udn_reply\n");
                assert(((_binding->rx_vtbl).bind_udn_reply) != NULL);
                ((_binding->rx_vtbl).bind_udn_reply)(_binding, ((_binding->rx_union).bind_udn_reply).con_id, ((_binding->rx_union).bind_udn_reply).mon_id, ((_binding->rx_union).bind_udn_reply).err, ((_binding->rx_union).bind_udn_reply).notify, ((_binding->rx_union).bind_udn_reply).core_id, ((_binding->rx_union).bind_udn_reply).chan_id, ((_binding->rx_union).bind_udn_reply).asid);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_cap_send_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).cap_send_request).on_cores = malloc(sizeof(intermon_coremask_t ));
                assert((((_binding->rx_union).cap_send_request).on_cores) != NULL);
                // check length
                if (((msg.buf).msglen) != 7) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).cap_send_request).give_away = ((((msg.words)[0]) >> 16) & 0x1);
                ((_binding->rx_union).cap_send_request).has_descendents = ((((msg.words)[0]) >> 17) & 0x1);
                ((_binding->rx_union).cap_send_request).null_cap = ((((msg.words)[0]) >> 18) & 0x1);
                ((_binding->rx_union).cap_send_request).con_id = ((msg.words)[1]);
                ((_binding->rx_union).cap_send_request).con_id = ((((_binding->rx_union).cap_send_request).con_id) | (((uint64_t )((msg.words)[2])) << 32));
                ((_binding->rx_union).cap_send_request).capid = ((msg.words)[3]);
                (((_binding->rx_union).cap_send_request).cap).w0 = ((msg.words)[4]);
                (((_binding->rx_union).cap_send_request).cap).w0 = (((((_binding->rx_union).cap_send_request).cap).w0) | (((uint64_t )((msg.words)[5])) << 32));
                (((_binding->rx_union).cap_send_request).cap).w1 = ((msg.words)[6]);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                // check length
                if (((msg.buf).msglen) != 7) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                (((_binding->rx_union).cap_send_request).cap).w1 = (((((_binding->rx_union).cap_send_request).cap).w1) | (((uint64_t )((msg.words)[0])) << 32));
                (((_binding->rx_union).cap_send_request).cap).w2 = ((msg.words)[1]);
                (((_binding->rx_union).cap_send_request).cap).w2 = (((((_binding->rx_union).cap_send_request).cap).w2) | (((uint64_t )((msg.words)[2])) << 32));
                (((_binding->rx_union).cap_send_request).cap).w3 = ((msg.words)[3]);
                (((_binding->rx_union).cap_send_request).cap).w3 = (((((_binding->rx_union).cap_send_request).cap).w3) | (((uint64_t )((msg.words)[4])) << 32));
                ((_binding->rx_union).cap_send_request).err = ((msg.words)[5]);
                (*(((_binding->rx_union).cap_send_request).on_cores))[0] = ((msg.words)[6]);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 2:
                // check length
                if (((msg.buf).msglen) != 7) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                (*(((_binding->rx_union).cap_send_request).on_cores))[0] = (((*(((_binding->rx_union).cap_send_request).on_cores))[0]) | (((uint64_t )((msg.words)[0])) << 32));
                (*(((_binding->rx_union).cap_send_request).on_cores))[1] = ((msg.words)[1]);
                (*(((_binding->rx_union).cap_send_request).on_cores))[1] = (((*(((_binding->rx_union).cap_send_request).on_cores))[1]) | (((uint64_t )((msg.words)[2])) << 32));
                (*(((_binding->rx_union).cap_send_request).on_cores))[2] = ((msg.words)[3]);
                (*(((_binding->rx_union).cap_send_request).on_cores))[2] = (((*(((_binding->rx_union).cap_send_request).on_cores))[2]) | (((uint64_t )((msg.words)[4])) << 32));
                (*(((_binding->rx_union).cap_send_request).on_cores))[3] = ((msg.words)[5]);
                (*(((_binding->rx_union).cap_send_request).on_cores))[3] = (((*(((_binding->rx_union).cap_send_request).on_cores))[3]) | (((uint64_t )((msg.words)[6])) << 32));
                
                FL_DEBUG("lmp RX intermon.cap_send_request\n");
                assert(((_binding->rx_vtbl).cap_send_request) != NULL);
                ((_binding->rx_vtbl).cap_send_request)(_binding, ((_binding->rx_union).cap_send_request).con_id, ((_binding->rx_union).cap_send_request).capid, ((_binding->rx_union).cap_send_request).cap, ((_binding->rx_union).cap_send_request).err, ((_binding->rx_union).cap_send_request).give_away, ((_binding->rx_union).cap_send_request).has_descendents, *(((_binding->rx_union).cap_send_request).on_cores), ((_binding->rx_union).cap_send_request).null_cap);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_span_domain_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 7) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).span_domain_request).framebits = ((((msg.words)[0]) >> 16) & 0xff);
                ((_binding->rx_union).span_domain_request).state_id = ((msg.words)[1]);
                ((_binding->rx_union).span_domain_request).state_id = ((((_binding->rx_union).span_domain_request).state_id) | (((uint64_t )((msg.words)[2])) << 32));
                ((_binding->rx_union).span_domain_request).vnodebase = ((msg.words)[3]);
                ((_binding->rx_union).span_domain_request).vnodebase = ((((_binding->rx_union).span_domain_request).vnodebase) | (((uint64_t )((msg.words)[4])) << 32));
                ((_binding->rx_union).span_domain_request).framebase = ((msg.words)[5]);
                ((_binding->rx_union).span_domain_request).framebase = ((((_binding->rx_union).span_domain_request).framebase) | (((uint64_t )((msg.words)[6])) << 32));
                
                FL_DEBUG("lmp RX intermon.span_domain_request\n");
                assert(((_binding->rx_vtbl).span_domain_request) != NULL);
                ((_binding->rx_vtbl).span_domain_request)(_binding, ((_binding->rx_union).span_domain_request).state_id, ((_binding->rx_union).span_domain_request).vnodebase, ((_binding->rx_union).span_domain_request).framebase, ((_binding->rx_union).span_domain_request).framebits);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_span_domain_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).span_domain_reply).state_id = ((msg.words)[1]);
                ((_binding->rx_union).span_domain_reply).state_id = ((((_binding->rx_union).span_domain_reply).state_id) | (((uint64_t )((msg.words)[2])) << 32));
                ((_binding->rx_union).span_domain_reply).err = ((msg.words)[3]);
                
                FL_DEBUG("lmp RX intermon.span_domain_reply\n");
                assert(((_binding->rx_vtbl).span_domain_reply) != NULL);
                ((_binding->rx_vtbl).span_domain_reply)(_binding, ((_binding->rx_union).span_domain_reply).state_id, ((_binding->rx_union).span_domain_reply).err);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_rsrc_join__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 2) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).rsrc_join).coreid = ((((msg.words)[0]) >> 16) & 0xff);
                ((_binding->rx_union).rsrc_join).id = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX intermon.rsrc_join\n");
                assert(((_binding->rx_vtbl).rsrc_join) != NULL);
                ((_binding->rx_vtbl).rsrc_join)(_binding, ((_binding->rx_union).rsrc_join).id, ((_binding->rx_union).rsrc_join).coreid);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_rsrc_join_complete__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 2) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).rsrc_join_complete).id = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX intermon.rsrc_join_complete\n");
                assert(((_binding->rx_vtbl).rsrc_join_complete) != NULL);
                ((_binding->rx_vtbl).rsrc_join_complete)(_binding, ((_binding->rx_union).rsrc_join_complete).id);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_rsrc_phase_data__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 3) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).rsrc_phase_data).id = ((msg.words)[1]);
                ((_binding->rx_union).rsrc_phase_data).phase = ((msg.words)[2]);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                err = flounder_stub_lmp_recv_buf(&msg, (void **)(&(((_binding->rx_union).rsrc_phase_data).data)), &(((_binding->rx_union).rsrc_phase_data).len), &(_binding->rx_str_pos));
                if (err_is_ok(err)) {
                    FL_DEBUG("lmp RX intermon.rsrc_phase_data\n");
                    assert(((_binding->rx_vtbl).rsrc_phase_data) != NULL);
                    ((_binding->rx_vtbl).rsrc_phase_data)(_binding, ((_binding->rx_union).rsrc_phase_data).id, ((_binding->rx_union).rsrc_phase_data).phase, ((_binding->rx_union).rsrc_phase_data).data, ((_binding->rx_union).rsrc_phase_data).len);
                    _binding->rx_msgnum = 0;
                } else {
                    if (err_no(err) != FLOUNDER_ERR_BUF_RECV_MORE) {
                        (_binding->error_handler)(_binding, err);
                    }
                }
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_rsrc_timer_sync__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 3) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).rsrc_timer_sync).timestamp = ((msg.words)[1]);
                ((_binding->rx_union).rsrc_timer_sync).timestamp = ((((_binding->rx_union).rsrc_timer_sync).timestamp) | (((uint64_t )((msg.words)[2])) << 32));
                
                FL_DEBUG("lmp RX intermon.rsrc_timer_sync\n");
                assert(((_binding->rx_vtbl).rsrc_timer_sync) != NULL);
                ((_binding->rx_vtbl).rsrc_timer_sync)(_binding, ((_binding->rx_union).rsrc_timer_sync).timestamp);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_rsrc_timer_sync_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 2) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).rsrc_timer_sync_reply).err = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX intermon.rsrc_timer_sync_reply\n");
                assert(((_binding->rx_vtbl).rsrc_timer_sync_reply) != NULL);
                ((_binding->rx_vtbl).rsrc_timer_sync_reply)(_binding, ((_binding->rx_union).rsrc_timer_sync_reply).err);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_rsrc_phase__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 5) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).rsrc_phase).id = ((msg.words)[1]);
                ((_binding->rx_union).rsrc_phase).phase = ((msg.words)[2]);
                ((_binding->rx_union).rsrc_phase).timestamp = ((msg.words)[3]);
                ((_binding->rx_union).rsrc_phase).timestamp = ((((_binding->rx_union).rsrc_phase).timestamp) | (((uint64_t )((msg.words)[4])) << 32));
                
                FL_DEBUG("lmp RX intermon.rsrc_phase\n");
                assert(((_binding->rx_vtbl).rsrc_phase) != NULL);
                ((_binding->rx_vtbl).rsrc_phase)(_binding, ((_binding->rx_union).rsrc_phase).id, ((_binding->rx_union).rsrc_phase).phase, ((_binding->rx_union).rsrc_phase).timestamp);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_multihop_routing_table_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 1) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).multihop_routing_table_request).source_coreid = ((((msg.words)[0]) >> 16) & 0xff);
                
                FL_DEBUG("lmp RX intermon.multihop_routing_table_request\n");
                assert(((_binding->rx_vtbl).multihop_routing_table_request) != NULL);
                ((_binding->rx_vtbl).multihop_routing_table_request)(_binding, ((_binding->rx_union).multihop_routing_table_request).source_coreid);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_multihop_routing_table_response__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 2) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).multihop_routing_table_response).source_coreid = ((((msg.words)[0]) >> 16) & 0xff);
                ((_binding->rx_union).multihop_routing_table_response).max_coreid = ((((msg.words)[0]) >> 24) & 0xff);
                ((_binding->rx_union).multihop_routing_table_response).err = ((msg.words)[1]);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                err = flounder_stub_lmp_recv_buf(&msg, (void **)(&(((_binding->rx_union).multihop_routing_table_response).to)), &(((_binding->rx_union).multihop_routing_table_response).len), &(_binding->rx_str_pos));
                if (err_is_ok(err)) {
                    FL_DEBUG("lmp RX intermon.multihop_routing_table_response\n");
                    assert(((_binding->rx_vtbl).multihop_routing_table_response) != NULL);
                    ((_binding->rx_vtbl).multihop_routing_table_response)(_binding, ((_binding->rx_union).multihop_routing_table_response).err, ((_binding->rx_union).multihop_routing_table_response).source_coreid, ((_binding->rx_union).multihop_routing_table_response).max_coreid, ((_binding->rx_union).multihop_routing_table_response).to, ((_binding->rx_union).multihop_routing_table_response).len);
                    _binding->rx_msgnum = 0;
                } else {
                    if (err_no(err) != FLOUNDER_ERR_BUF_RECV_MORE) {
                        (_binding->error_handler)(_binding, err);
                    }
                }
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_multihop_routing_table_grow__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 1) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).multihop_routing_table_grow).forwarder = ((((msg.words)[0]) >> 16) & 0xff);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                err = flounder_stub_lmp_recv_buf(&msg, (void **)(&(((_binding->rx_union).multihop_routing_table_grow).destinations)), &(((_binding->rx_union).multihop_routing_table_grow).len), &(_binding->rx_str_pos));
                if (err_is_ok(err)) {
                    FL_DEBUG("lmp RX intermon.multihop_routing_table_grow\n");
                    assert(((_binding->rx_vtbl).multihop_routing_table_grow) != NULL);
                    ((_binding->rx_vtbl).multihop_routing_table_grow)(_binding, ((_binding->rx_union).multihop_routing_table_grow).forwarder, ((_binding->rx_union).multihop_routing_table_grow).destinations, ((_binding->rx_union).multihop_routing_table_grow).len);
                    _binding->rx_msgnum = 0;
                } else {
                    if (err_no(err) != FLOUNDER_ERR_BUF_RECV_MORE) {
                        (_binding->error_handler)(_binding, err);
                    }
                }
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_multihop_intermon_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_multihop_intermon_request).core_id = ((((msg.words)[0]) >> 16) & 0xff);
                ((_binding->rx_union).bind_multihop_intermon_request).iref = ((msg.words)[1]);
                ((_binding->rx_union).bind_multihop_intermon_request).sender_vci = ((msg.words)[2]);
                ((_binding->rx_union).bind_multihop_intermon_request).sender_vci = ((((_binding->rx_union).bind_multihop_intermon_request).sender_vci) | (((uint64_t )((msg.words)[3])) << 32));
                
                FL_DEBUG("lmp RX intermon.bind_multihop_intermon_request\n");
                assert(((_binding->rx_vtbl).bind_multihop_intermon_request) != NULL);
                ((_binding->rx_vtbl).bind_multihop_intermon_request)(_binding, ((_binding->rx_union).bind_multihop_intermon_request).iref, ((_binding->rx_union).bind_multihop_intermon_request).sender_vci, ((_binding->rx_union).bind_multihop_intermon_request).core_id);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_multihop_intermon_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 6) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_multihop_intermon_reply).receiver_vci = ((msg.words)[1]);
                ((_binding->rx_union).bind_multihop_intermon_reply).receiver_vci = ((((_binding->rx_union).bind_multihop_intermon_reply).receiver_vci) | (((uint64_t )((msg.words)[2])) << 32));
                ((_binding->rx_union).bind_multihop_intermon_reply).sender_vci = ((msg.words)[3]);
                ((_binding->rx_union).bind_multihop_intermon_reply).sender_vci = ((((_binding->rx_union).bind_multihop_intermon_reply).sender_vci) | (((uint64_t )((msg.words)[4])) << 32));
                ((_binding->rx_union).bind_multihop_intermon_reply).err = ((msg.words)[5]);
                
                FL_DEBUG("lmp RX intermon.bind_multihop_intermon_reply\n");
                assert(((_binding->rx_vtbl).bind_multihop_intermon_reply) != NULL);
                ((_binding->rx_vtbl).bind_multihop_intermon_reply)(_binding, ((_binding->rx_union).bind_multihop_intermon_reply).receiver_vci, ((_binding->rx_union).bind_multihop_intermon_reply).sender_vci, ((_binding->rx_union).bind_multihop_intermon_reply).err);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_multihop_message__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).multihop_message).direction = ((((msg.words)[0]) >> 16) & 0xff);
                ((_binding->rx_union).multihop_message).flags = ((((msg.words)[0]) >> 24) & 0xff);
                ((_binding->rx_union).multihop_message).vci = ((msg.words)[1]);
                ((_binding->rx_union).multihop_message).vci = ((((_binding->rx_union).multihop_message).vci) | (((uint64_t )((msg.words)[2])) << 32));
                ((_binding->rx_union).multihop_message).ack = ((msg.words)[3]);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                err = flounder_stub_lmp_recv_buf(&msg, (void **)(&(((_binding->rx_union).multihop_message).payload)), &(((_binding->rx_union).multihop_message).size), &(_binding->rx_str_pos));
                if (err_is_ok(err)) {
                    FL_DEBUG("lmp RX intermon.multihop_message\n");
                    assert(((_binding->rx_vtbl).multihop_message) != NULL);
                    ((_binding->rx_vtbl).multihop_message)(_binding, ((_binding->rx_union).multihop_message).vci, ((_binding->rx_union).multihop_message).direction, ((_binding->rx_union).multihop_message).flags, ((_binding->rx_union).multihop_message).ack, ((_binding->rx_union).multihop_message).payload, ((_binding->rx_union).multihop_message).size);
                    _binding->rx_msgnum = 0;
                } else {
                    if (err_no(err) != FLOUNDER_ERR_BUF_RECV_MORE) {
                        (_binding->error_handler)(_binding, err);
                    }
                }
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_multihop_cap_send__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 7) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).multihop_cap_send).null_cap = ((((msg.words)[0]) >> 16) & 0x1);
                ((_binding->rx_union).multihop_cap_send).direction = ((((msg.words)[0]) >> 17) & 0xff);
                ((_binding->rx_union).multihop_cap_send).vci = ((msg.words)[1]);
                ((_binding->rx_union).multihop_cap_send).vci = ((((_binding->rx_union).multihop_cap_send).vci) | (((uint64_t )((msg.words)[2])) << 32));
                ((_binding->rx_union).multihop_cap_send).capid = ((msg.words)[3]);
                ((_binding->rx_union).multihop_cap_send).err = ((msg.words)[4]);
                (((_binding->rx_union).multihop_cap_send).cap).w0 = ((msg.words)[5]);
                (((_binding->rx_union).multihop_cap_send).cap).w0 = (((((_binding->rx_union).multihop_cap_send).cap).w0) | (((uint64_t )((msg.words)[6])) << 32));
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                // check length
                if (((msg.buf).msglen) != 6) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                (((_binding->rx_union).multihop_cap_send).cap).w1 = ((msg.words)[0]);
                (((_binding->rx_union).multihop_cap_send).cap).w1 = (((((_binding->rx_union).multihop_cap_send).cap).w1) | (((uint64_t )((msg.words)[1])) << 32));
                (((_binding->rx_union).multihop_cap_send).cap).w2 = ((msg.words)[2]);
                (((_binding->rx_union).multihop_cap_send).cap).w2 = (((((_binding->rx_union).multihop_cap_send).cap).w2) | (((uint64_t )((msg.words)[3])) << 32));
                (((_binding->rx_union).multihop_cap_send).cap).w3 = ((msg.words)[4]);
                (((_binding->rx_union).multihop_cap_send).cap).w3 = (((((_binding->rx_union).multihop_cap_send).cap).w3) | (((uint64_t )((msg.words)[5])) << 32));
                
                FL_DEBUG("lmp RX intermon.multihop_cap_send\n");
                assert(((_binding->rx_vtbl).multihop_cap_send) != NULL);
                ((_binding->rx_vtbl).multihop_cap_send)(_binding, ((_binding->rx_union).multihop_cap_send).vci, ((_binding->rx_union).multihop_cap_send).direction, ((_binding->rx_union).multihop_cap_send).capid, ((_binding->rx_union).multihop_cap_send).err, ((_binding->rx_union).multihop_cap_send).cap, ((_binding->rx_union).multihop_cap_send).null_cap);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_trace_prepare__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 1) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).trace_prepare).origin_core = ((((msg.words)[0]) >> 16) & 0xff);
                
                FL_DEBUG("lmp RX intermon.trace_prepare\n");
                assert(((_binding->rx_vtbl).trace_prepare) != NULL);
                ((_binding->rx_vtbl).trace_prepare)(_binding, ((_binding->rx_union).trace_prepare).origin_core);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_trace_prepare_finished__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 1) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX intermon.trace_prepare_finished\n");
                assert(((_binding->rx_vtbl).trace_prepare_finished) != NULL);
                ((_binding->rx_vtbl).trace_prepare_finished)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_trace_measure__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 3) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).trace_measure).origin_core = ((((msg.words)[0]) >> 16) & 0xff);
                ((_binding->rx_union).trace_measure).t0 = ((msg.words)[1]);
                ((_binding->rx_union).trace_measure).t0 = ((((_binding->rx_union).trace_measure).t0) | (((uint64_t )((msg.words)[2])) << 32));
                
                FL_DEBUG("lmp RX intermon.trace_measure\n");
                assert(((_binding->rx_vtbl).trace_measure) != NULL);
                ((_binding->rx_vtbl).trace_measure)(_binding, ((_binding->rx_union).trace_measure).origin_core, ((_binding->rx_union).trace_measure).t0);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_trace_measure_ack__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 7) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).trace_measure_ack).origin_core = ((((msg.words)[0]) >> 16) & 0xff);
                ((_binding->rx_union).trace_measure_ack).t0 = ((msg.words)[1]);
                ((_binding->rx_union).trace_measure_ack).t0 = ((((_binding->rx_union).trace_measure_ack).t0) | (((uint64_t )((msg.words)[2])) << 32));
                ((_binding->rx_union).trace_measure_ack).t1 = ((msg.words)[3]);
                ((_binding->rx_union).trace_measure_ack).t1 = ((((_binding->rx_union).trace_measure_ack).t1) | (((uint64_t )((msg.words)[4])) << 32));
                ((_binding->rx_union).trace_measure_ack).t2 = ((msg.words)[5]);
                ((_binding->rx_union).trace_measure_ack).t2 = ((((_binding->rx_union).trace_measure_ack).t2) | (((uint64_t )((msg.words)[6])) << 32));
                
                FL_DEBUG("lmp RX intermon.trace_measure_ack\n");
                assert(((_binding->rx_vtbl).trace_measure_ack) != NULL);
                ((_binding->rx_vtbl).trace_measure_ack)(_binding, ((_binding->rx_union).trace_measure_ack).origin_core, ((_binding->rx_union).trace_measure_ack).t0, ((_binding->rx_union).trace_measure_ack).t1, ((_binding->rx_union).trace_measure_ack).t2);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bfscope_flush_send_forward__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 2) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bfscope_flush_send_forward).iref = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX intermon.bfscope_flush_send_forward\n");
                assert(((_binding->rx_vtbl).bfscope_flush_send_forward) != NULL);
                ((_binding->rx_vtbl).bfscope_flush_send_forward)(_binding, ((_binding->rx_union).bfscope_flush_send_forward).iref);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bfscope_flush_ack_forward__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 1) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX intermon.bfscope_flush_ack_forward\n");
                assert(((_binding->rx_vtbl).bfscope_flush_ack_forward) != NULL);
                ((_binding->rx_vtbl).bfscope_flush_ack_forward)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        default:
            (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_MSGNUM);
            goto out;
        }
    } while (err_is_ok(err));
    out:
    // re-register for another receive notification
    err = lmp_chan_register_recv(&(b->chan), _binding->waitset, recv_closure);
    assert(err_is_ok(err));
}


/*
 * Control functions
 */
static  bool intermon_lmp_can_send(struct intermon_binding *b)
{
    return((b->tx_msgnum) == 0);
}

static  errval_t intermon_lmp_register_send(struct intermon_binding *b, struct waitset *ws, struct event_closure _continuation)
{
    return(flounder_support_register(ws, &(b->register_chanstate), _continuation, intermon_lmp_can_send(b)));
}

static  void intermon_lmp_default_error_handler(struct intermon_binding *b, errval_t err)
{
    DEBUG_ERR(err, "asynchronous error in Flounder-generated intermon lmp binding (default handler)");
    abort();
}

static  errval_t intermon_lmp_change_waitset(struct intermon_binding *_binding, struct waitset *ws)
{
    struct intermon_lmp_binding *b = (void *)(_binding);
    
    // Migrate register and TX continuation notifications
    flounder_support_migrate_notify(&(_binding->register_chanstate), ws);
    flounder_support_migrate_notify(&(_binding->tx_cont_chanstate), ws);
    
    // change waitset on binding
    _binding->waitset = ws;
    
    // Migrate send and receive notifications
    lmp_chan_migrate_recv(&(b->chan), ws);
    lmp_chan_migrate_send(&(b->chan), ws);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_lmp_control(struct intermon_binding *_binding, idc_control_t control)
{
    struct intermon_lmp_binding *b = (void *)(_binding);
    
    b->flags = idc_control_to_lmp_flags(control, b->flags);
    
    return(SYS_ERR_OK);
}

/*
 * Functions to initialise/destroy the binding state
 */
 void intermon_lmp_init(struct intermon_lmp_binding *b, struct waitset *waitset)
{
    (b->b).st = NULL;
    (b->b).waitset = waitset;
    event_mutex_init(&((b->b).mutex), waitset);
    (b->b).can_send = intermon_lmp_can_send;
    (b->b).register_send = intermon_lmp_register_send;
    (b->b).error_handler = intermon_lmp_default_error_handler;
    (b->b).tx_vtbl = intermon_lmp_tx_vtbl;
    memset(&((b->b).rx_vtbl), 0, sizeof((b->b).rx_vtbl));
    flounder_support_waitset_chanstate_init(&((b->b).register_chanstate));
    flounder_support_waitset_chanstate_init(&((b->b).tx_cont_chanstate));
    (b->b).tx_msgnum = 0;
    (b->b).rx_msgnum = 0;
    (b->b).tx_msg_fragment = 0;
    (b->b).rx_msg_fragment = 0;
    (b->b).tx_str_pos = 0;
    (b->b).rx_str_pos = 0;
    (b->b).tx_str_len = 0;
    (b->b).rx_str_len = 0;
    (b->b).bind_cont = NULL;
    lmp_chan_init(&(b->chan));
    (b->b).change_waitset = intermon_lmp_change_waitset;
    (b->b).control = intermon_lmp_control;
    b->flags = LMP_SEND_FLAGS_DEFAULT;
}

 void intermon_lmp_destroy(struct intermon_lmp_binding *b)
{
    flounder_support_waitset_chanstate_destroy(&((b->b).register_chanstate));
    flounder_support_waitset_chanstate_destroy(&((b->b).tx_cont_chanstate));
    lmp_chan_destroy(&(b->chan));
}


/*
 * Bind function
 */
static  void intermon_lmp_bind_continuation(void *st, errval_t err, struct lmp_chan *chan)
{
    struct intermon_lmp_binding *b = st;
    
    if (err_is_ok(err)) {
        // allocate a cap receive slot
        err = lmp_chan_alloc_recv_slot(chan);
        if (err_is_fail(err)) {
            err = err_push(err, LIB_ERR_LMP_ALLOC_RECV_SLOT);
            goto fail;
        }
        
        // register for receive
        err = lmp_chan_register_recv(chan, (b->b).waitset, (struct event_closure){  .handler = intermon_lmp_rx_handler,  .arg = b });
        if (err_is_fail(err)) {
            err = err_push(err, LIB_ERR_CHAN_REGISTER_RECV);
            goto fail;
        }
    } else {
        fail:
        intermon_lmp_destroy(b);
    }
    
    ((b->b).bind_cont)((b->b).st, err, &(b->b));
}

 errval_t intermon_lmp_bind(struct intermon_lmp_binding *b, iref_t iref, intermon_bind_continuation_fn *_continuation, void *st, struct waitset *waitset, idc_bind_flags_t flags, size_t lmp_buflen)
{
    errval_t err;
    intermon_lmp_init(b, waitset);
    (b->b).st = st;
    (b->b).bind_cont = _continuation;
    err = lmp_chan_bind(&(b->chan), (struct lmp_bind_continuation){  .handler = intermon_lmp_bind_continuation,  .st = b }, &((b->b).event_qnode), iref, lmp_buflen);
    if (err_is_fail(err)) {
        intermon_lmp_destroy(b);
    }
    return(err);
}


/*
 * Connect callback for export
 */
 errval_t intermon_lmp_connect_handler(void *st, size_t buflen_words, struct capref endpoint, struct lmp_chan **retchan)
{
    struct intermon_export *e = st;
    errval_t err;
    
    // allocate storage for binding
    struct intermon_lmp_binding *b = malloc(sizeof(struct intermon_lmp_binding ));
    if (b == NULL) {
        return(LIB_ERR_MALLOC_FAIL);
    }
    
    struct intermon_binding *_binding = &(b->b);
    intermon_lmp_init(b, e->waitset);
    
    // run user's connect handler
    err = ((e->connect_cb)(e->st, _binding));
    if (err_is_fail(err)) {
        // connection refused
        intermon_lmp_destroy(b);
        return(err);
    }
    
    // accept the connection and setup the channel
    // FIXME: user policy needed to decide on the size of the message buffer?
    err = lmp_chan_accept(&(b->chan), buflen_words, endpoint);
    if (err_is_fail(err)) {
        err = err_push(err, LIB_ERR_LMP_CHAN_ACCEPT);
        (_binding->error_handler)(_binding, err);
        return(err);
    }
    
    // allocate a cap receive slot
    err = lmp_chan_alloc_recv_slot(&(b->chan));
    if (err_is_fail(err)) {
        err = err_push(err, LIB_ERR_LMP_ALLOC_RECV_SLOT);
        (_binding->error_handler)(_binding, err);
        return(err);
    }
    
    // register for receive
    err = lmp_chan_register_recv(&(b->chan), _binding->waitset, (struct event_closure){  .handler = intermon_lmp_rx_handler,  .arg = b });
    if (err_is_fail(err)) {
        err = err_push(err, LIB_ERR_CHAN_REGISTER_RECV);
        (_binding->error_handler)(_binding, err);
        return(err);
    }
    
    *retchan = (&(b->chan));
    
    return(SYS_ERR_OK);
}

/*
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * INTERFACE NAME: intermon
 * INTEFACE FILE: /home/andreas/barrelfish/new_test2/if/intermon.if
 * INTERFACE DESCRIPTION: The Interface between monitors
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr.6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY FLOUNDER: DO NOT EDIT!
 */

#ifdef CONFIG_FLOUNDER_BACKEND_UDN

/*
 * Generated Stub for UDN
 */

#include <barrelfish/barrelfish.h>
#include <barrelfish/monitor_client.h>
#include <flounder/flounder_support.h>
#include <flounder/flounder_support_udn.h>
#include <if/intermon_defs.h>

/*
 * Send handler function
 */
static  void intermon_udn_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_udn_binding *b = arg;
    errval_t err;
    err = SYS_ERR_OK;
    
    struct udn_message msg;
    bool tx_notify = false;
    
    // do we need to (and can we) send a cap ack?
    if ((((b->udn_state).capst).tx_cap_ack) && flounder_stub_udn_can_send(&(b->udn_state))) {
        flounder_stub_udn_send_cap_ack(&(b->udn_state));
        ((b->udn_state).capst).tx_cap_ack = false;
        tx_notify = true;
    }
    
    // Switch on current outgoing message number
    switch (_binding->tx_msgnum) {
    case 0:
        break;
    case intermon_spawnd_image_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg.data_len = 0;
            msg.type = intermon_spawnd_image_request__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_spawnd_image_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).spawnd_image_reply).base);
            (msg.data)[1] = ((((_binding->tx_union).spawnd_image_reply).base) >> 32);
            (msg.data)[2] = (((_binding->tx_union).spawnd_image_reply).bytes);
            msg.data_len = 3;
            msg.type = intermon_spawnd_image_reply__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_monitor_initialized__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg.data_len = 0;
            msg.type = intermon_monitor_initialized__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_trace_caps_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg.data_len = 0;
            msg.type = intermon_trace_caps_request__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_trace_caps_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = ((((_binding->tx_union).trace_caps_reply).cap).w0);
            (msg.data)[1] = (((((_binding->tx_union).trace_caps_reply).cap).w0) >> 32);
            (msg.data)[2] = ((((_binding->tx_union).trace_caps_reply).cap).w1);
            (msg.data)[3] = (((((_binding->tx_union).trace_caps_reply).cap).w1) >> 32);
            (msg.data)[4] = ((((_binding->tx_union).trace_caps_reply).cap).w2);
            (msg.data)[5] = (((((_binding->tx_union).trace_caps_reply).cap).w2) >> 32);
            (msg.data)[6] = ((((_binding->tx_union).trace_caps_reply).cap).w3);
            (msg.data)[7] = (((((_binding->tx_union).trace_caps_reply).cap).w3) >> 32);
            msg.data_len = 8;
            msg.type = intermon_trace_caps_reply__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_mem_serv_iref_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg.data_len = 0;
            msg.type = intermon_mem_serv_iref_request__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_mem_serv_iref_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).mem_serv_iref_reply).iref);
            msg.data_len = 1;
            msg.type = intermon_mem_serv_iref_reply__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_ramfs_serv_iref_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg.data_len = 0;
            msg.type = intermon_ramfs_serv_iref_request__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_ramfs_serv_iref_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).ramfs_serv_iref_reply).iref);
            msg.data_len = 1;
            msg.type = intermon_ramfs_serv_iref_reply__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_name_serv_iref_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg.data_len = 0;
            msg.type = intermon_name_serv_iref_request__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_name_serv_iref_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).name_serv_iref_reply).iref);
            msg.data_len = 1;
            msg.type = intermon_name_serv_iref_reply__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_monitor_mem_iref_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg.data_len = 0;
            msg.type = intermon_monitor_mem_iref_request__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_monitor_mem_iref_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).monitor_mem_iref_reply).iref);
            msg.data_len = 1;
            msg.type = intermon_monitor_mem_iref_reply__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_bind_monitor_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).bind_monitor_request).core_id);
            (msg.data)[1] = ((((_binding->tx_union).bind_monitor_request).cap).w0);
            (msg.data)[2] = (((((_binding->tx_union).bind_monitor_request).cap).w0) >> 32);
            (msg.data)[3] = ((((_binding->tx_union).bind_monitor_request).cap).w1);
            (msg.data)[4] = (((((_binding->tx_union).bind_monitor_request).cap).w1) >> 32);
            (msg.data)[5] = ((((_binding->tx_union).bind_monitor_request).cap).w2);
            (msg.data)[6] = (((((_binding->tx_union).bind_monitor_request).cap).w2) >> 32);
            (msg.data)[7] = ((((_binding->tx_union).bind_monitor_request).cap).w3);
            (msg.data)[8] = (((((_binding->tx_union).bind_monitor_request).cap).w3) >> 32);
            msg.data_len = 9;
            msg.type = intermon_bind_monitor_request__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_bind_monitor_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).bind_monitor_reply).err);
            msg.data_len = 1;
            msg.type = intermon_bind_monitor_reply__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_bind_monitor_proxy__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).bind_monitor_proxy).dst_core_id);
            (msg.data)[1] = ((((_binding->tx_union).bind_monitor_proxy).cap).w0);
            (msg.data)[2] = (((((_binding->tx_union).bind_monitor_proxy).cap).w0) >> 32);
            (msg.data)[3] = ((((_binding->tx_union).bind_monitor_proxy).cap).w1);
            (msg.data)[4] = (((((_binding->tx_union).bind_monitor_proxy).cap).w1) >> 32);
            (msg.data)[5] = ((((_binding->tx_union).bind_monitor_proxy).cap).w2);
            (msg.data)[6] = (((((_binding->tx_union).bind_monitor_proxy).cap).w2) >> 32);
            (msg.data)[7] = ((((_binding->tx_union).bind_monitor_proxy).cap).w3);
            (msg.data)[8] = (((((_binding->tx_union).bind_monitor_proxy).cap).w3) >> 32);
            msg.data_len = 9;
            msg.type = intermon_bind_monitor_proxy__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_bind_monitor_request_scc__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = ((((_binding->tx_union).bind_monitor_request_scc).core_id) | (((uintptr_t )(((_binding->tx_union).bind_monitor_request_scc).from_core_id)) << 8));
            (msg.data)[1] = ((((_binding->tx_union).bind_monitor_request_scc).cap).w0);
            (msg.data)[2] = (((((_binding->tx_union).bind_monitor_request_scc).cap).w0) >> 32);
            (msg.data)[3] = ((((_binding->tx_union).bind_monitor_request_scc).cap).w1);
            (msg.data)[4] = (((((_binding->tx_union).bind_monitor_request_scc).cap).w1) >> 32);
            (msg.data)[5] = ((((_binding->tx_union).bind_monitor_request_scc).cap).w2);
            (msg.data)[6] = (((((_binding->tx_union).bind_monitor_request_scc).cap).w2) >> 32);
            (msg.data)[7] = ((((_binding->tx_union).bind_monitor_request_scc).cap).w3);
            (msg.data)[8] = (((((_binding->tx_union).bind_monitor_request_scc).cap).w3) >> 32);
            (msg.data)[9] = (((_binding->tx_union).bind_monitor_request_scc).chan_id);
            msg.data_len = 10;
            msg.type = intermon_bind_monitor_request_scc__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_bind_monitor_reply_scc__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).bind_monitor_reply_scc).core_id);
            (msg.data)[1] = (((_binding->tx_union).bind_monitor_reply_scc).err);
            (msg.data)[2] = (((_binding->tx_union).bind_monitor_reply_scc).chan_id);
            msg.data_len = 3;
            msg.type = intermon_bind_monitor_reply_scc__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_bind_monitor_proxy_scc__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = ((((_binding->tx_union).bind_monitor_proxy_scc).dst_core_id) | (((uintptr_t )(((_binding->tx_union).bind_monitor_proxy_scc).core_id)) << 8));
            (msg.data)[1] = ((((_binding->tx_union).bind_monitor_proxy_scc).cap).w0);
            (msg.data)[2] = (((((_binding->tx_union).bind_monitor_proxy_scc).cap).w0) >> 32);
            (msg.data)[3] = ((((_binding->tx_union).bind_monitor_proxy_scc).cap).w1);
            (msg.data)[4] = (((((_binding->tx_union).bind_monitor_proxy_scc).cap).w1) >> 32);
            (msg.data)[5] = ((((_binding->tx_union).bind_monitor_proxy_scc).cap).w2);
            (msg.data)[6] = (((((_binding->tx_union).bind_monitor_proxy_scc).cap).w2) >> 32);
            (msg.data)[7] = ((((_binding->tx_union).bind_monitor_proxy_scc).cap).w3);
            (msg.data)[8] = (((((_binding->tx_union).bind_monitor_proxy_scc).cap).w3) >> 32);
            (msg.data)[9] = (((_binding->tx_union).bind_monitor_proxy_scc).chan_id);
            msg.data_len = 10;
            msg.type = intermon_bind_monitor_proxy_scc__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_bind_monitor_request_bmp__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = ((((_binding->tx_union).bind_monitor_request_bmp).core_id) | (((uintptr_t )(((_binding->tx_union).bind_monitor_request_bmp).from_core_id)) << 8));
            (msg.data)[1] = (((_binding->tx_union).bind_monitor_request_bmp).chan_id);
            msg.data_len = 2;
            msg.type = intermon_bind_monitor_request_bmp__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_bind_monitor_reply_bmp__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).bind_monitor_reply_bmp).core_id);
            (msg.data)[1] = (((_binding->tx_union).bind_monitor_reply_bmp).err);
            (msg.data)[2] = (((_binding->tx_union).bind_monitor_reply_bmp).chan_id);
            msg.data_len = 3;
            msg.type = intermon_bind_monitor_reply_bmp__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_bind_monitor_proxy_bmp__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = ((((_binding->tx_union).bind_monitor_proxy_bmp).dst_core_id) | (((uintptr_t )(((_binding->tx_union).bind_monitor_proxy_bmp).core_id)) << 8));
            (msg.data)[1] = (((_binding->tx_union).bind_monitor_proxy_bmp).chan_id);
            msg.data_len = 2;
            msg.type = intermon_bind_monitor_proxy_bmp__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_new_monitor_notify__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).new_monitor_notify).core_id);
            msg.data_len = 1;
            msg.type = intermon_new_monitor_notify__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_bind_ump_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).bind_ump_request).framebits);
            (msg.data)[1] = (((_binding->tx_union).bind_ump_request).iref);
            (msg.data)[2] = (((_binding->tx_union).bind_ump_request).mon_id);
            (msg.data)[3] = ((((_binding->tx_union).bind_ump_request).mon_id) >> 32);
            (msg.data)[4] = (((_binding->tx_union).bind_ump_request).channel_length_in);
            (msg.data)[5] = (((_binding->tx_union).bind_ump_request).channel_length_out);
            (msg.data)[6] = (((_binding->tx_union).bind_ump_request).framebase);
            (msg.data)[7] = ((((_binding->tx_union).bind_ump_request).framebase) >> 32);
            (msg.data)[8] = ((((_binding->tx_union).bind_ump_request).notify).w0);
            (msg.data)[9] = (((((_binding->tx_union).bind_ump_request).notify).w0) >> 32);
            (msg.data)[10] = ((((_binding->tx_union).bind_ump_request).notify).w1);
            (msg.data)[11] = (((((_binding->tx_union).bind_ump_request).notify).w1) >> 32);
            (msg.data)[12] = ((((_binding->tx_union).bind_ump_request).notify).w2);
            (msg.data)[13] = (((((_binding->tx_union).bind_ump_request).notify).w2) >> 32);
            msg.data_len = 14;
            msg.type = intermon_bind_ump_request__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        case 1:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = ((((_binding->tx_union).bind_ump_request).notify).w3);
            (msg.data)[1] = (((((_binding->tx_union).bind_ump_request).notify).w3) >> 32);
            msg.data_len = 2;
            msg.type = intermon_bind_ump_request__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 2:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_bind_ump_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).bind_ump_reply).con_id);
            (msg.data)[1] = ((((_binding->tx_union).bind_ump_reply).con_id) >> 32);
            (msg.data)[2] = (((_binding->tx_union).bind_ump_reply).mon_id);
            (msg.data)[3] = ((((_binding->tx_union).bind_ump_reply).mon_id) >> 32);
            (msg.data)[4] = (((_binding->tx_union).bind_ump_reply).err);
            (msg.data)[5] = ((((_binding->tx_union).bind_ump_reply).notify).w0);
            (msg.data)[6] = (((((_binding->tx_union).bind_ump_reply).notify).w0) >> 32);
            (msg.data)[7] = ((((_binding->tx_union).bind_ump_reply).notify).w1);
            (msg.data)[8] = (((((_binding->tx_union).bind_ump_reply).notify).w1) >> 32);
            (msg.data)[9] = ((((_binding->tx_union).bind_ump_reply).notify).w2);
            (msg.data)[10] = (((((_binding->tx_union).bind_ump_reply).notify).w2) >> 32);
            (msg.data)[11] = ((((_binding->tx_union).bind_ump_reply).notify).w3);
            (msg.data)[12] = (((((_binding->tx_union).bind_ump_reply).notify).w3) >> 32);
            msg.data_len = 13;
            msg.type = intermon_bind_ump_reply__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_bind_udn_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = ((((_binding->tx_union).bind_udn_request).core_id) | (((uintptr_t )(((_binding->tx_union).bind_udn_request).asid)) << 8));
            (msg.data)[1] = (((_binding->tx_union).bind_udn_request).iref);
            (msg.data)[2] = (((_binding->tx_union).bind_udn_request).mon_id);
            (msg.data)[3] = ((((_binding->tx_union).bind_udn_request).mon_id) >> 32);
            (msg.data)[4] = ((((_binding->tx_union).bind_udn_request).notify).w0);
            (msg.data)[5] = (((((_binding->tx_union).bind_udn_request).notify).w0) >> 32);
            (msg.data)[6] = ((((_binding->tx_union).bind_udn_request).notify).w1);
            (msg.data)[7] = (((((_binding->tx_union).bind_udn_request).notify).w1) >> 32);
            (msg.data)[8] = ((((_binding->tx_union).bind_udn_request).notify).w2);
            (msg.data)[9] = (((((_binding->tx_union).bind_udn_request).notify).w2) >> 32);
            (msg.data)[10] = ((((_binding->tx_union).bind_udn_request).notify).w3);
            (msg.data)[11] = (((((_binding->tx_union).bind_udn_request).notify).w3) >> 32);
            (msg.data)[12] = (((_binding->tx_union).bind_udn_request).chan_id);
            msg.data_len = 13;
            msg.type = intermon_bind_udn_request__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_bind_udn_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = ((((_binding->tx_union).bind_udn_reply).core_id) | (((uintptr_t )(((_binding->tx_union).bind_udn_reply).asid)) << 8));
            (msg.data)[1] = (((_binding->tx_union).bind_udn_reply).con_id);
            (msg.data)[2] = ((((_binding->tx_union).bind_udn_reply).con_id) >> 32);
            (msg.data)[3] = (((_binding->tx_union).bind_udn_reply).mon_id);
            (msg.data)[4] = ((((_binding->tx_union).bind_udn_reply).mon_id) >> 32);
            (msg.data)[5] = (((_binding->tx_union).bind_udn_reply).err);
            (msg.data)[6] = ((((_binding->tx_union).bind_udn_reply).notify).w0);
            (msg.data)[7] = (((((_binding->tx_union).bind_udn_reply).notify).w0) >> 32);
            (msg.data)[8] = ((((_binding->tx_union).bind_udn_reply).notify).w1);
            (msg.data)[9] = (((((_binding->tx_union).bind_udn_reply).notify).w1) >> 32);
            (msg.data)[10] = ((((_binding->tx_union).bind_udn_reply).notify).w2);
            (msg.data)[11] = (((((_binding->tx_union).bind_udn_reply).notify).w2) >> 32);
            (msg.data)[12] = ((((_binding->tx_union).bind_udn_reply).notify).w3);
            (msg.data)[13] = (((((_binding->tx_union).bind_udn_reply).notify).w3) >> 32);
            msg.data_len = 14;
            msg.type = intermon_bind_udn_reply__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        case 1:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).bind_udn_reply).chan_id);
            msg.data_len = 1;
            msg.type = intermon_bind_udn_reply__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 2:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_cap_send_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((((_binding->tx_union).cap_send_request).give_away) != false) | ((((uintptr_t )((((_binding->tx_union).cap_send_request).has_descendents) != false)) << 1) | (((uintptr_t )((((_binding->tx_union).cap_send_request).null_cap) != false)) << 2)));
            (msg.data)[1] = (((_binding->tx_union).cap_send_request).con_id);
            (msg.data)[2] = ((((_binding->tx_union).cap_send_request).con_id) >> 32);
            (msg.data)[3] = (((_binding->tx_union).cap_send_request).capid);
            (msg.data)[4] = ((((_binding->tx_union).cap_send_request).cap).w0);
            (msg.data)[5] = (((((_binding->tx_union).cap_send_request).cap).w0) >> 32);
            (msg.data)[6] = ((((_binding->tx_union).cap_send_request).cap).w1);
            (msg.data)[7] = (((((_binding->tx_union).cap_send_request).cap).w1) >> 32);
            (msg.data)[8] = ((((_binding->tx_union).cap_send_request).cap).w2);
            (msg.data)[9] = (((((_binding->tx_union).cap_send_request).cap).w2) >> 32);
            (msg.data)[10] = ((((_binding->tx_union).cap_send_request).cap).w3);
            (msg.data)[11] = (((((_binding->tx_union).cap_send_request).cap).w3) >> 32);
            (msg.data)[12] = (((_binding->tx_union).cap_send_request).err);
            (msg.data)[13] = ((*(((_binding->tx_union).cap_send_request).on_cores))[0]);
            msg.data_len = 14;
            msg.type = intermon_cap_send_request__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        case 1:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((*(((_binding->tx_union).cap_send_request).on_cores))[0]) >> 32);
            (msg.data)[1] = ((*(((_binding->tx_union).cap_send_request).on_cores))[1]);
            (msg.data)[2] = (((*(((_binding->tx_union).cap_send_request).on_cores))[1]) >> 32);
            (msg.data)[3] = ((*(((_binding->tx_union).cap_send_request).on_cores))[2]);
            (msg.data)[4] = (((*(((_binding->tx_union).cap_send_request).on_cores))[2]) >> 32);
            (msg.data)[5] = ((*(((_binding->tx_union).cap_send_request).on_cores))[3]);
            (msg.data)[6] = (((*(((_binding->tx_union).cap_send_request).on_cores))[3]) >> 32);
            msg.data_len = 7;
            msg.type = intermon_cap_send_request__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 2:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_span_domain_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).span_domain_request).framebits);
            (msg.data)[1] = (((_binding->tx_union).span_domain_request).state_id);
            (msg.data)[2] = ((((_binding->tx_union).span_domain_request).state_id) >> 32);
            (msg.data)[3] = (((_binding->tx_union).span_domain_request).vnodebase);
            (msg.data)[4] = ((((_binding->tx_union).span_domain_request).vnodebase) >> 32);
            (msg.data)[5] = (((_binding->tx_union).span_domain_request).framebase);
            (msg.data)[6] = ((((_binding->tx_union).span_domain_request).framebase) >> 32);
            msg.data_len = 7;
            msg.type = intermon_span_domain_request__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_span_domain_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).span_domain_reply).state_id);
            (msg.data)[1] = ((((_binding->tx_union).span_domain_reply).state_id) >> 32);
            (msg.data)[2] = (((_binding->tx_union).span_domain_reply).err);
            msg.data_len = 3;
            msg.type = intermon_span_domain_reply__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_rsrc_join__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).rsrc_join).coreid);
            (msg.data)[1] = (((_binding->tx_union).rsrc_join).id);
            msg.data_len = 2;
            msg.type = intermon_rsrc_join__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_rsrc_join_complete__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).rsrc_join_complete).id);
            msg.data_len = 1;
            msg.type = intermon_rsrc_join_complete__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_rsrc_phase_data__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).rsrc_phase_data).id);
            (msg.data)[1] = (((_binding->tx_union).rsrc_phase_data).phase);
            msg.data_len = 2;
            msg.type = intermon_rsrc_phase_data__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        case 1:
            err = flounder_stub_udn_send_buf(&(b->udn_state), intermon_rsrc_phase_data__msgnum, ((_binding->tx_union).rsrc_phase_data).data, ((_binding->tx_union).rsrc_phase_data).len, &(_binding->tx_str_pos));
            if (err_is_fail(err)) {
                if (err_no(err) == FLOUNDER_ERR_BUF_SEND_MORE) {
                    tx_notify = true;
                } else {
                    // Permanent error, report to user
                    (_binding->error_handler)(_binding, err);
                    _binding->tx_msgnum = 0;
                    flounder_support_trigger_chan(&(_binding->register_chanstate));
                    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
                }
                break;
            }
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 2:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_rsrc_timer_sync__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).rsrc_timer_sync).timestamp);
            (msg.data)[1] = ((((_binding->tx_union).rsrc_timer_sync).timestamp) >> 32);
            msg.data_len = 2;
            msg.type = intermon_rsrc_timer_sync__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_rsrc_timer_sync_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).rsrc_timer_sync_reply).err);
            msg.data_len = 1;
            msg.type = intermon_rsrc_timer_sync_reply__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_rsrc_phase__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).rsrc_phase).id);
            (msg.data)[1] = (((_binding->tx_union).rsrc_phase).phase);
            (msg.data)[2] = (((_binding->tx_union).rsrc_phase).timestamp);
            (msg.data)[3] = ((((_binding->tx_union).rsrc_phase).timestamp) >> 32);
            msg.data_len = 4;
            msg.type = intermon_rsrc_phase__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_multihop_routing_table_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).multihop_routing_table_request).source_coreid);
            msg.data_len = 1;
            msg.type = intermon_multihop_routing_table_request__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_multihop_routing_table_response__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = ((((_binding->tx_union).multihop_routing_table_response).source_coreid) | (((uintptr_t )(((_binding->tx_union).multihop_routing_table_response).max_coreid)) << 8));
            (msg.data)[1] = (((_binding->tx_union).multihop_routing_table_response).err);
            msg.data_len = 2;
            msg.type = intermon_multihop_routing_table_response__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        case 1:
            err = flounder_stub_udn_send_buf(&(b->udn_state), intermon_multihop_routing_table_response__msgnum, ((_binding->tx_union).multihop_routing_table_response).to, ((_binding->tx_union).multihop_routing_table_response).len, &(_binding->tx_str_pos));
            if (err_is_fail(err)) {
                if (err_no(err) == FLOUNDER_ERR_BUF_SEND_MORE) {
                    tx_notify = true;
                } else {
                    // Permanent error, report to user
                    (_binding->error_handler)(_binding, err);
                    _binding->tx_msgnum = 0;
                    flounder_support_trigger_chan(&(_binding->register_chanstate));
                    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
                }
                break;
            }
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 2:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_multihop_routing_table_grow__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).multihop_routing_table_grow).forwarder);
            msg.data_len = 1;
            msg.type = intermon_multihop_routing_table_grow__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        case 1:
            err = flounder_stub_udn_send_buf(&(b->udn_state), intermon_multihop_routing_table_grow__msgnum, ((_binding->tx_union).multihop_routing_table_grow).destinations, ((_binding->tx_union).multihop_routing_table_grow).len, &(_binding->tx_str_pos));
            if (err_is_fail(err)) {
                if (err_no(err) == FLOUNDER_ERR_BUF_SEND_MORE) {
                    tx_notify = true;
                } else {
                    // Permanent error, report to user
                    (_binding->error_handler)(_binding, err);
                    _binding->tx_msgnum = 0;
                    flounder_support_trigger_chan(&(_binding->register_chanstate));
                    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
                }
                break;
            }
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 2:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_bind_multihop_intermon_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).bind_multihop_intermon_request).core_id);
            (msg.data)[1] = (((_binding->tx_union).bind_multihop_intermon_request).iref);
            (msg.data)[2] = (((_binding->tx_union).bind_multihop_intermon_request).sender_vci);
            (msg.data)[3] = ((((_binding->tx_union).bind_multihop_intermon_request).sender_vci) >> 32);
            msg.data_len = 4;
            msg.type = intermon_bind_multihop_intermon_request__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_bind_multihop_intermon_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).bind_multihop_intermon_reply).receiver_vci);
            (msg.data)[1] = ((((_binding->tx_union).bind_multihop_intermon_reply).receiver_vci) >> 32);
            (msg.data)[2] = (((_binding->tx_union).bind_multihop_intermon_reply).sender_vci);
            (msg.data)[3] = ((((_binding->tx_union).bind_multihop_intermon_reply).sender_vci) >> 32);
            (msg.data)[4] = (((_binding->tx_union).bind_multihop_intermon_reply).err);
            msg.data_len = 5;
            msg.type = intermon_bind_multihop_intermon_reply__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_multihop_message__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = ((((_binding->tx_union).multihop_message).direction) | (((uintptr_t )(((_binding->tx_union).multihop_message).flags)) << 8));
            (msg.data)[1] = (((_binding->tx_union).multihop_message).vci);
            (msg.data)[2] = ((((_binding->tx_union).multihop_message).vci) >> 32);
            (msg.data)[3] = (((_binding->tx_union).multihop_message).ack);
            msg.data_len = 4;
            msg.type = intermon_multihop_message__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        case 1:
            err = flounder_stub_udn_send_buf(&(b->udn_state), intermon_multihop_message__msgnum, ((_binding->tx_union).multihop_message).payload, ((_binding->tx_union).multihop_message).size, &(_binding->tx_str_pos));
            if (err_is_fail(err)) {
                if (err_no(err) == FLOUNDER_ERR_BUF_SEND_MORE) {
                    tx_notify = true;
                } else {
                    // Permanent error, report to user
                    (_binding->error_handler)(_binding, err);
                    _binding->tx_msgnum = 0;
                    flounder_support_trigger_chan(&(_binding->register_chanstate));
                    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
                }
                break;
            }
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 2:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_multihop_cap_send__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((((_binding->tx_union).multihop_cap_send).null_cap) != false) | (((uintptr_t )(((_binding->tx_union).multihop_cap_send).direction)) << 1));
            (msg.data)[1] = (((_binding->tx_union).multihop_cap_send).vci);
            (msg.data)[2] = ((((_binding->tx_union).multihop_cap_send).vci) >> 32);
            (msg.data)[3] = (((_binding->tx_union).multihop_cap_send).capid);
            (msg.data)[4] = (((_binding->tx_union).multihop_cap_send).err);
            (msg.data)[5] = ((((_binding->tx_union).multihop_cap_send).cap).w0);
            (msg.data)[6] = (((((_binding->tx_union).multihop_cap_send).cap).w0) >> 32);
            (msg.data)[7] = ((((_binding->tx_union).multihop_cap_send).cap).w1);
            (msg.data)[8] = (((((_binding->tx_union).multihop_cap_send).cap).w1) >> 32);
            (msg.data)[9] = ((((_binding->tx_union).multihop_cap_send).cap).w2);
            (msg.data)[10] = (((((_binding->tx_union).multihop_cap_send).cap).w2) >> 32);
            (msg.data)[11] = ((((_binding->tx_union).multihop_cap_send).cap).w3);
            (msg.data)[12] = (((((_binding->tx_union).multihop_cap_send).cap).w3) >> 32);
            msg.data_len = 13;
            msg.type = intermon_multihop_cap_send__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_trace_prepare__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).trace_prepare).origin_core);
            msg.data_len = 1;
            msg.type = intermon_trace_prepare__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_trace_prepare_finished__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg.data_len = 0;
            msg.type = intermon_trace_prepare_finished__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_trace_measure__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).trace_measure).origin_core);
            (msg.data)[1] = (((_binding->tx_union).trace_measure).t0);
            (msg.data)[2] = ((((_binding->tx_union).trace_measure).t0) >> 32);
            msg.data_len = 3;
            msg.type = intermon_trace_measure__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_trace_measure_ack__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).trace_measure_ack).origin_core);
            (msg.data)[1] = (((_binding->tx_union).trace_measure_ack).t0);
            (msg.data)[2] = ((((_binding->tx_union).trace_measure_ack).t0) >> 32);
            (msg.data)[3] = (((_binding->tx_union).trace_measure_ack).t1);
            (msg.data)[4] = ((((_binding->tx_union).trace_measure_ack).t1) >> 32);
            (msg.data)[5] = (((_binding->tx_union).trace_measure_ack).t2);
            (msg.data)[6] = ((((_binding->tx_union).trace_measure_ack).t2) >> 32);
            msg.data_len = 7;
            msg.type = intermon_trace_measure_ack__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_bfscope_flush_send_forward__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            (msg.data)[0] = (((_binding->tx_union).bfscope_flush_send_forward).iref);
            msg.data_len = 1;
            msg.type = intermon_bfscope_flush_send_forward__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case intermon_bfscope_flush_ack_forward__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_udn_can_send(&(b->udn_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg.data_len = 0;
            msg.type = intermon_bfscope_flush_ack_forward__msgnum;
            udn_impl_send_msg(&(((b->udn_state).chan).send_chan), &msg);
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->udn_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    default:
        assert(!("invalid msgnum"));
        (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
    }
    
    // Send a notification if necessary
    if (tx_notify) {
    }
}


/*
 * Capability sender function
 */
static  void intermon_udn_cap_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_udn_binding *b = arg;
    errval_t err;
    err = SYS_ERR_OK;
    
    assert(((b->udn_state).capst).rx_cap_ack);
    assert(((b->udn_state).capst).monitor_mutex_held);
    
    // Switch on current outgoing message
    switch (_binding->tx_msgnum) {
    default:
        assert(!("invalid message number"));
        (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
    }
}


/*
 * Receive handler
 */
 void intermon_udn_rx_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_udn_binding *b = arg;
    errval_t err;
    err = SYS_ERR_OK;
    
    struct udn_message *msg;
    int msgnum;
    
    while (true) {
        // try to retrieve a message from the channel
        err = udn_chan_recv(&((b->udn_state).chan), &msg);
        // check if we succeeded
        if (err_is_fail(err)) {
            if (err_no(err) == LIB_ERR_NO_UDN_MSG) {
                // no message
                break;
            } else {
                // real error
                (_binding->error_handler)(_binding, err_push(err, LIB_ERR_UDN_CHAN_RECV));
                return;
            }
        }
        
        // get msg num (type)
        msgnum = (msg->type);
        
        // is this a dummy message (ACK)?
        if (msgnum == FL_UDN_ACK) {
            goto loopnext;
        }
        
        // is this a cap ack for a pending tx message
        if (msgnum == FL_UDN_CAP_ACK) {
            assert(!(((b->udn_state).capst).rx_cap_ack));
            ((b->udn_state).capst).rx_cap_ack = true;
            if (((b->udn_state).capst).monitor_mutex_held) {
                intermon_udn_cap_send_handler(b);
            }
            goto loopnext;
        }
        
        // is this the start of a new message?
        if ((_binding->rx_msgnum) == 0) {
            _binding->rx_msgnum = msgnum;
            _binding->rx_msg_fragment = 0;
        }
        
        // switch on message number and fragment number
        switch (_binding->rx_msgnum) {
        case intermon_spawnd_image_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                
                FL_DEBUG("udn RX intermon.spawnd_image_request\n");
                assert(((_binding->rx_vtbl).spawnd_image_request) != NULL);
                ((_binding->rx_vtbl).spawnd_image_request)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_spawnd_image_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).spawnd_image_reply).base = ((msg->data)[0]);
                ((_binding->rx_union).spawnd_image_reply).base = ((((_binding->rx_union).spawnd_image_reply).base) | (((uint64_t )((msg->data)[1])) << 32));
                ((_binding->rx_union).spawnd_image_reply).bytes = ((msg->data)[2]);
                
                FL_DEBUG("udn RX intermon.spawnd_image_reply\n");
                assert(((_binding->rx_vtbl).spawnd_image_reply) != NULL);
                ((_binding->rx_vtbl).spawnd_image_reply)(_binding, ((_binding->rx_union).spawnd_image_reply).base, ((_binding->rx_union).spawnd_image_reply).bytes);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_monitor_initialized__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                
                FL_DEBUG("udn RX intermon.monitor_initialized\n");
                assert(((_binding->rx_vtbl).monitor_initialized) != NULL);
                ((_binding->rx_vtbl).monitor_initialized)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_trace_caps_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                
                FL_DEBUG("udn RX intermon.trace_caps_request\n");
                assert(((_binding->rx_vtbl).trace_caps_request) != NULL);
                ((_binding->rx_vtbl).trace_caps_request)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_trace_caps_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                (((_binding->rx_union).trace_caps_reply).cap).w0 = ((msg->data)[0]);
                (((_binding->rx_union).trace_caps_reply).cap).w0 = (((((_binding->rx_union).trace_caps_reply).cap).w0) | (((uint64_t )((msg->data)[1])) << 32));
                (((_binding->rx_union).trace_caps_reply).cap).w1 = ((msg->data)[2]);
                (((_binding->rx_union).trace_caps_reply).cap).w1 = (((((_binding->rx_union).trace_caps_reply).cap).w1) | (((uint64_t )((msg->data)[3])) << 32));
                (((_binding->rx_union).trace_caps_reply).cap).w2 = ((msg->data)[4]);
                (((_binding->rx_union).trace_caps_reply).cap).w2 = (((((_binding->rx_union).trace_caps_reply).cap).w2) | (((uint64_t )((msg->data)[5])) << 32));
                (((_binding->rx_union).trace_caps_reply).cap).w3 = ((msg->data)[6]);
                (((_binding->rx_union).trace_caps_reply).cap).w3 = (((((_binding->rx_union).trace_caps_reply).cap).w3) | (((uint64_t )((msg->data)[7])) << 32));
                
                FL_DEBUG("udn RX intermon.trace_caps_reply\n");
                assert(((_binding->rx_vtbl).trace_caps_reply) != NULL);
                ((_binding->rx_vtbl).trace_caps_reply)(_binding, ((_binding->rx_union).trace_caps_reply).cap);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_mem_serv_iref_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                
                FL_DEBUG("udn RX intermon.mem_serv_iref_request\n");
                assert(((_binding->rx_vtbl).mem_serv_iref_request) != NULL);
                ((_binding->rx_vtbl).mem_serv_iref_request)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_mem_serv_iref_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).mem_serv_iref_reply).iref = ((msg->data)[0]);
                
                FL_DEBUG("udn RX intermon.mem_serv_iref_reply\n");
                assert(((_binding->rx_vtbl).mem_serv_iref_reply) != NULL);
                ((_binding->rx_vtbl).mem_serv_iref_reply)(_binding, ((_binding->rx_union).mem_serv_iref_reply).iref);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_ramfs_serv_iref_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                
                FL_DEBUG("udn RX intermon.ramfs_serv_iref_request\n");
                assert(((_binding->rx_vtbl).ramfs_serv_iref_request) != NULL);
                ((_binding->rx_vtbl).ramfs_serv_iref_request)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_ramfs_serv_iref_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).ramfs_serv_iref_reply).iref = ((msg->data)[0]);
                
                FL_DEBUG("udn RX intermon.ramfs_serv_iref_reply\n");
                assert(((_binding->rx_vtbl).ramfs_serv_iref_reply) != NULL);
                ((_binding->rx_vtbl).ramfs_serv_iref_reply)(_binding, ((_binding->rx_union).ramfs_serv_iref_reply).iref);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_name_serv_iref_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                
                FL_DEBUG("udn RX intermon.name_serv_iref_request\n");
                assert(((_binding->rx_vtbl).name_serv_iref_request) != NULL);
                ((_binding->rx_vtbl).name_serv_iref_request)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_name_serv_iref_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).name_serv_iref_reply).iref = ((msg->data)[0]);
                
                FL_DEBUG("udn RX intermon.name_serv_iref_reply\n");
                assert(((_binding->rx_vtbl).name_serv_iref_reply) != NULL);
                ((_binding->rx_vtbl).name_serv_iref_reply)(_binding, ((_binding->rx_union).name_serv_iref_reply).iref);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_monitor_mem_iref_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                
                FL_DEBUG("udn RX intermon.monitor_mem_iref_request\n");
                assert(((_binding->rx_vtbl).monitor_mem_iref_request) != NULL);
                ((_binding->rx_vtbl).monitor_mem_iref_request)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_monitor_mem_iref_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).monitor_mem_iref_reply).iref = ((msg->data)[0]);
                
                FL_DEBUG("udn RX intermon.monitor_mem_iref_reply\n");
                assert(((_binding->rx_vtbl).monitor_mem_iref_reply) != NULL);
                ((_binding->rx_vtbl).monitor_mem_iref_reply)(_binding, ((_binding->rx_union).monitor_mem_iref_reply).iref);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_monitor_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).bind_monitor_request).core_id = (((msg->data)[0]) & 0xff);
                (((_binding->rx_union).bind_monitor_request).cap).w0 = ((msg->data)[1]);
                (((_binding->rx_union).bind_monitor_request).cap).w0 = (((((_binding->rx_union).bind_monitor_request).cap).w0) | (((uint64_t )((msg->data)[2])) << 32));
                (((_binding->rx_union).bind_monitor_request).cap).w1 = ((msg->data)[3]);
                (((_binding->rx_union).bind_monitor_request).cap).w1 = (((((_binding->rx_union).bind_monitor_request).cap).w1) | (((uint64_t )((msg->data)[4])) << 32));
                (((_binding->rx_union).bind_monitor_request).cap).w2 = ((msg->data)[5]);
                (((_binding->rx_union).bind_monitor_request).cap).w2 = (((((_binding->rx_union).bind_monitor_request).cap).w2) | (((uint64_t )((msg->data)[6])) << 32));
                (((_binding->rx_union).bind_monitor_request).cap).w3 = ((msg->data)[7]);
                (((_binding->rx_union).bind_monitor_request).cap).w3 = (((((_binding->rx_union).bind_monitor_request).cap).w3) | (((uint64_t )((msg->data)[8])) << 32));
                
                FL_DEBUG("udn RX intermon.bind_monitor_request\n");
                assert(((_binding->rx_vtbl).bind_monitor_request) != NULL);
                ((_binding->rx_vtbl).bind_monitor_request)(_binding, ((_binding->rx_union).bind_monitor_request).core_id, ((_binding->rx_union).bind_monitor_request).cap);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_monitor_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).bind_monitor_reply).err = ((msg->data)[0]);
                
                FL_DEBUG("udn RX intermon.bind_monitor_reply\n");
                assert(((_binding->rx_vtbl).bind_monitor_reply) != NULL);
                ((_binding->rx_vtbl).bind_monitor_reply)(_binding, ((_binding->rx_union).bind_monitor_reply).err);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_monitor_proxy__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).bind_monitor_proxy).dst_core_id = (((msg->data)[0]) & 0xff);
                (((_binding->rx_union).bind_monitor_proxy).cap).w0 = ((msg->data)[1]);
                (((_binding->rx_union).bind_monitor_proxy).cap).w0 = (((((_binding->rx_union).bind_monitor_proxy).cap).w0) | (((uint64_t )((msg->data)[2])) << 32));
                (((_binding->rx_union).bind_monitor_proxy).cap).w1 = ((msg->data)[3]);
                (((_binding->rx_union).bind_monitor_proxy).cap).w1 = (((((_binding->rx_union).bind_monitor_proxy).cap).w1) | (((uint64_t )((msg->data)[4])) << 32));
                (((_binding->rx_union).bind_monitor_proxy).cap).w2 = ((msg->data)[5]);
                (((_binding->rx_union).bind_monitor_proxy).cap).w2 = (((((_binding->rx_union).bind_monitor_proxy).cap).w2) | (((uint64_t )((msg->data)[6])) << 32));
                (((_binding->rx_union).bind_monitor_proxy).cap).w3 = ((msg->data)[7]);
                (((_binding->rx_union).bind_monitor_proxy).cap).w3 = (((((_binding->rx_union).bind_monitor_proxy).cap).w3) | (((uint64_t )((msg->data)[8])) << 32));
                
                FL_DEBUG("udn RX intermon.bind_monitor_proxy\n");
                assert(((_binding->rx_vtbl).bind_monitor_proxy) != NULL);
                ((_binding->rx_vtbl).bind_monitor_proxy)(_binding, ((_binding->rx_union).bind_monitor_proxy).dst_core_id, ((_binding->rx_union).bind_monitor_proxy).cap);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_monitor_request_scc__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).bind_monitor_request_scc).core_id = (((msg->data)[0]) & 0xff);
                ((_binding->rx_union).bind_monitor_request_scc).from_core_id = ((((msg->data)[0]) >> 8) & 0xff);
                (((_binding->rx_union).bind_monitor_request_scc).cap).w0 = ((msg->data)[1]);
                (((_binding->rx_union).bind_monitor_request_scc).cap).w0 = (((((_binding->rx_union).bind_monitor_request_scc).cap).w0) | (((uint64_t )((msg->data)[2])) << 32));
                (((_binding->rx_union).bind_monitor_request_scc).cap).w1 = ((msg->data)[3]);
                (((_binding->rx_union).bind_monitor_request_scc).cap).w1 = (((((_binding->rx_union).bind_monitor_request_scc).cap).w1) | (((uint64_t )((msg->data)[4])) << 32));
                (((_binding->rx_union).bind_monitor_request_scc).cap).w2 = ((msg->data)[5]);
                (((_binding->rx_union).bind_monitor_request_scc).cap).w2 = (((((_binding->rx_union).bind_monitor_request_scc).cap).w2) | (((uint64_t )((msg->data)[6])) << 32));
                (((_binding->rx_union).bind_monitor_request_scc).cap).w3 = ((msg->data)[7]);
                (((_binding->rx_union).bind_monitor_request_scc).cap).w3 = (((((_binding->rx_union).bind_monitor_request_scc).cap).w3) | (((uint64_t )((msg->data)[8])) << 32));
                ((_binding->rx_union).bind_monitor_request_scc).chan_id = ((msg->data)[9]);
                
                FL_DEBUG("udn RX intermon.bind_monitor_request_scc\n");
                assert(((_binding->rx_vtbl).bind_monitor_request_scc) != NULL);
                ((_binding->rx_vtbl).bind_monitor_request_scc)(_binding, ((_binding->rx_union).bind_monitor_request_scc).core_id, ((_binding->rx_union).bind_monitor_request_scc).cap, ((_binding->rx_union).bind_monitor_request_scc).chan_id, ((_binding->rx_union).bind_monitor_request_scc).from_core_id);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_monitor_reply_scc__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).bind_monitor_reply_scc).core_id = (((msg->data)[0]) & 0xff);
                ((_binding->rx_union).bind_monitor_reply_scc).err = ((msg->data)[1]);
                ((_binding->rx_union).bind_monitor_reply_scc).chan_id = ((msg->data)[2]);
                
                FL_DEBUG("udn RX intermon.bind_monitor_reply_scc\n");
                assert(((_binding->rx_vtbl).bind_monitor_reply_scc) != NULL);
                ((_binding->rx_vtbl).bind_monitor_reply_scc)(_binding, ((_binding->rx_union).bind_monitor_reply_scc).err, ((_binding->rx_union).bind_monitor_reply_scc).chan_id, ((_binding->rx_union).bind_monitor_reply_scc).core_id);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_monitor_proxy_scc__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).bind_monitor_proxy_scc).dst_core_id = (((msg->data)[0]) & 0xff);
                ((_binding->rx_union).bind_monitor_proxy_scc).core_id = ((((msg->data)[0]) >> 8) & 0xff);
                (((_binding->rx_union).bind_monitor_proxy_scc).cap).w0 = ((msg->data)[1]);
                (((_binding->rx_union).bind_monitor_proxy_scc).cap).w0 = (((((_binding->rx_union).bind_monitor_proxy_scc).cap).w0) | (((uint64_t )((msg->data)[2])) << 32));
                (((_binding->rx_union).bind_monitor_proxy_scc).cap).w1 = ((msg->data)[3]);
                (((_binding->rx_union).bind_monitor_proxy_scc).cap).w1 = (((((_binding->rx_union).bind_monitor_proxy_scc).cap).w1) | (((uint64_t )((msg->data)[4])) << 32));
                (((_binding->rx_union).bind_monitor_proxy_scc).cap).w2 = ((msg->data)[5]);
                (((_binding->rx_union).bind_monitor_proxy_scc).cap).w2 = (((((_binding->rx_union).bind_monitor_proxy_scc).cap).w2) | (((uint64_t )((msg->data)[6])) << 32));
                (((_binding->rx_union).bind_monitor_proxy_scc).cap).w3 = ((msg->data)[7]);
                (((_binding->rx_union).bind_monitor_proxy_scc).cap).w3 = (((((_binding->rx_union).bind_monitor_proxy_scc).cap).w3) | (((uint64_t )((msg->data)[8])) << 32));
                ((_binding->rx_union).bind_monitor_proxy_scc).chan_id = ((msg->data)[9]);
                
                FL_DEBUG("udn RX intermon.bind_monitor_proxy_scc\n");
                assert(((_binding->rx_vtbl).bind_monitor_proxy_scc) != NULL);
                ((_binding->rx_vtbl).bind_monitor_proxy_scc)(_binding, ((_binding->rx_union).bind_monitor_proxy_scc).dst_core_id, ((_binding->rx_union).bind_monitor_proxy_scc).cap, ((_binding->rx_union).bind_monitor_proxy_scc).chan_id, ((_binding->rx_union).bind_monitor_proxy_scc).core_id);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_monitor_request_bmp__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).bind_monitor_request_bmp).core_id = (((msg->data)[0]) & 0xff);
                ((_binding->rx_union).bind_monitor_request_bmp).from_core_id = ((((msg->data)[0]) >> 8) & 0xff);
                ((_binding->rx_union).bind_monitor_request_bmp).chan_id = ((msg->data)[1]);
                
                FL_DEBUG("udn RX intermon.bind_monitor_request_bmp\n");
                assert(((_binding->rx_vtbl).bind_monitor_request_bmp) != NULL);
                ((_binding->rx_vtbl).bind_monitor_request_bmp)(_binding, ((_binding->rx_union).bind_monitor_request_bmp).core_id, ((_binding->rx_union).bind_monitor_request_bmp).chan_id, ((_binding->rx_union).bind_monitor_request_bmp).from_core_id);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_monitor_reply_bmp__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).bind_monitor_reply_bmp).core_id = (((msg->data)[0]) & 0xff);
                ((_binding->rx_union).bind_monitor_reply_bmp).err = ((msg->data)[1]);
                ((_binding->rx_union).bind_monitor_reply_bmp).chan_id = ((msg->data)[2]);
                
                FL_DEBUG("udn RX intermon.bind_monitor_reply_bmp\n");
                assert(((_binding->rx_vtbl).bind_monitor_reply_bmp) != NULL);
                ((_binding->rx_vtbl).bind_monitor_reply_bmp)(_binding, ((_binding->rx_union).bind_monitor_reply_bmp).err, ((_binding->rx_union).bind_monitor_reply_bmp).chan_id, ((_binding->rx_union).bind_monitor_reply_bmp).core_id);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_monitor_proxy_bmp__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).bind_monitor_proxy_bmp).dst_core_id = (((msg->data)[0]) & 0xff);
                ((_binding->rx_union).bind_monitor_proxy_bmp).core_id = ((((msg->data)[0]) >> 8) & 0xff);
                ((_binding->rx_union).bind_monitor_proxy_bmp).chan_id = ((msg->data)[1]);
                
                FL_DEBUG("udn RX intermon.bind_monitor_proxy_bmp\n");
                assert(((_binding->rx_vtbl).bind_monitor_proxy_bmp) != NULL);
                ((_binding->rx_vtbl).bind_monitor_proxy_bmp)(_binding, ((_binding->rx_union).bind_monitor_proxy_bmp).dst_core_id, ((_binding->rx_union).bind_monitor_proxy_bmp).chan_id, ((_binding->rx_union).bind_monitor_proxy_bmp).core_id);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_new_monitor_notify__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).new_monitor_notify).core_id = (((msg->data)[0]) & 0xff);
                
                FL_DEBUG("udn RX intermon.new_monitor_notify\n");
                assert(((_binding->rx_vtbl).new_monitor_notify) != NULL);
                ((_binding->rx_vtbl).new_monitor_notify)(_binding, ((_binding->rx_union).new_monitor_notify).core_id);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_ump_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).bind_ump_request).framebits = (((msg->data)[0]) & 0xff);
                ((_binding->rx_union).bind_ump_request).iref = ((msg->data)[1]);
                ((_binding->rx_union).bind_ump_request).mon_id = ((msg->data)[2]);
                ((_binding->rx_union).bind_ump_request).mon_id = ((((_binding->rx_union).bind_ump_request).mon_id) | (((uint64_t )((msg->data)[3])) << 32));
                ((_binding->rx_union).bind_ump_request).channel_length_in = ((msg->data)[4]);
                ((_binding->rx_union).bind_ump_request).channel_length_out = ((msg->data)[5]);
                ((_binding->rx_union).bind_ump_request).framebase = ((msg->data)[6]);
                ((_binding->rx_union).bind_ump_request).framebase = ((((_binding->rx_union).bind_ump_request).framebase) | (((uint64_t )((msg->data)[7])) << 32));
                (((_binding->rx_union).bind_ump_request).notify).w0 = ((msg->data)[8]);
                (((_binding->rx_union).bind_ump_request).notify).w0 = (((((_binding->rx_union).bind_ump_request).notify).w0) | (((uint64_t )((msg->data)[9])) << 32));
                (((_binding->rx_union).bind_ump_request).notify).w1 = ((msg->data)[10]);
                (((_binding->rx_union).bind_ump_request).notify).w1 = (((((_binding->rx_union).bind_ump_request).notify).w1) | (((uint64_t )((msg->data)[11])) << 32));
                (((_binding->rx_union).bind_ump_request).notify).w2 = ((msg->data)[12]);
                (((_binding->rx_union).bind_ump_request).notify).w2 = (((((_binding->rx_union).bind_ump_request).notify).w2) | (((uint64_t )((msg->data)[13])) << 32));
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                (((_binding->rx_union).bind_ump_request).notify).w3 = ((msg->data)[0]);
                (((_binding->rx_union).bind_ump_request).notify).w3 = (((((_binding->rx_union).bind_ump_request).notify).w3) | (((uint64_t )((msg->data)[1])) << 32));
                
                FL_DEBUG("udn RX intermon.bind_ump_request\n");
                assert(((_binding->rx_vtbl).bind_ump_request) != NULL);
                ((_binding->rx_vtbl).bind_ump_request)(_binding, ((_binding->rx_union).bind_ump_request).iref, ((_binding->rx_union).bind_ump_request).mon_id, ((_binding->rx_union).bind_ump_request).channel_length_in, ((_binding->rx_union).bind_ump_request).channel_length_out, ((_binding->rx_union).bind_ump_request).framebase, ((_binding->rx_union).bind_ump_request).framebits, ((_binding->rx_union).bind_ump_request).notify);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_ump_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).bind_ump_reply).con_id = ((msg->data)[0]);
                ((_binding->rx_union).bind_ump_reply).con_id = ((((_binding->rx_union).bind_ump_reply).con_id) | (((uint64_t )((msg->data)[1])) << 32));
                ((_binding->rx_union).bind_ump_reply).mon_id = ((msg->data)[2]);
                ((_binding->rx_union).bind_ump_reply).mon_id = ((((_binding->rx_union).bind_ump_reply).mon_id) | (((uint64_t )((msg->data)[3])) << 32));
                ((_binding->rx_union).bind_ump_reply).err = ((msg->data)[4]);
                (((_binding->rx_union).bind_ump_reply).notify).w0 = ((msg->data)[5]);
                (((_binding->rx_union).bind_ump_reply).notify).w0 = (((((_binding->rx_union).bind_ump_reply).notify).w0) | (((uint64_t )((msg->data)[6])) << 32));
                (((_binding->rx_union).bind_ump_reply).notify).w1 = ((msg->data)[7]);
                (((_binding->rx_union).bind_ump_reply).notify).w1 = (((((_binding->rx_union).bind_ump_reply).notify).w1) | (((uint64_t )((msg->data)[8])) << 32));
                (((_binding->rx_union).bind_ump_reply).notify).w2 = ((msg->data)[9]);
                (((_binding->rx_union).bind_ump_reply).notify).w2 = (((((_binding->rx_union).bind_ump_reply).notify).w2) | (((uint64_t )((msg->data)[10])) << 32));
                (((_binding->rx_union).bind_ump_reply).notify).w3 = ((msg->data)[11]);
                (((_binding->rx_union).bind_ump_reply).notify).w3 = (((((_binding->rx_union).bind_ump_reply).notify).w3) | (((uint64_t )((msg->data)[12])) << 32));
                
                FL_DEBUG("udn RX intermon.bind_ump_reply\n");
                assert(((_binding->rx_vtbl).bind_ump_reply) != NULL);
                ((_binding->rx_vtbl).bind_ump_reply)(_binding, ((_binding->rx_union).bind_ump_reply).con_id, ((_binding->rx_union).bind_ump_reply).mon_id, ((_binding->rx_union).bind_ump_reply).err, ((_binding->rx_union).bind_ump_reply).notify);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_udn_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).bind_udn_request).core_id = (((msg->data)[0]) & 0xff);
                ((_binding->rx_union).bind_udn_request).asid = ((((msg->data)[0]) >> 8) & 0xff);
                ((_binding->rx_union).bind_udn_request).iref = ((msg->data)[1]);
                ((_binding->rx_union).bind_udn_request).mon_id = ((msg->data)[2]);
                ((_binding->rx_union).bind_udn_request).mon_id = ((((_binding->rx_union).bind_udn_request).mon_id) | (((uint64_t )((msg->data)[3])) << 32));
                (((_binding->rx_union).bind_udn_request).notify).w0 = ((msg->data)[4]);
                (((_binding->rx_union).bind_udn_request).notify).w0 = (((((_binding->rx_union).bind_udn_request).notify).w0) | (((uint64_t )((msg->data)[5])) << 32));
                (((_binding->rx_union).bind_udn_request).notify).w1 = ((msg->data)[6]);
                (((_binding->rx_union).bind_udn_request).notify).w1 = (((((_binding->rx_union).bind_udn_request).notify).w1) | (((uint64_t )((msg->data)[7])) << 32));
                (((_binding->rx_union).bind_udn_request).notify).w2 = ((msg->data)[8]);
                (((_binding->rx_union).bind_udn_request).notify).w2 = (((((_binding->rx_union).bind_udn_request).notify).w2) | (((uint64_t )((msg->data)[9])) << 32));
                (((_binding->rx_union).bind_udn_request).notify).w3 = ((msg->data)[10]);
                (((_binding->rx_union).bind_udn_request).notify).w3 = (((((_binding->rx_union).bind_udn_request).notify).w3) | (((uint64_t )((msg->data)[11])) << 32));
                ((_binding->rx_union).bind_udn_request).chan_id = ((msg->data)[12]);
                
                FL_DEBUG("udn RX intermon.bind_udn_request\n");
                assert(((_binding->rx_vtbl).bind_udn_request) != NULL);
                ((_binding->rx_vtbl).bind_udn_request)(_binding, ((_binding->rx_union).bind_udn_request).iref, ((_binding->rx_union).bind_udn_request).mon_id, ((_binding->rx_union).bind_udn_request).notify, ((_binding->rx_union).bind_udn_request).core_id, ((_binding->rx_union).bind_udn_request).chan_id, ((_binding->rx_union).bind_udn_request).asid);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_udn_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).bind_udn_reply).core_id = (((msg->data)[0]) & 0xff);
                ((_binding->rx_union).bind_udn_reply).asid = ((((msg->data)[0]) >> 8) & 0xff);
                ((_binding->rx_union).bind_udn_reply).con_id = ((msg->data)[1]);
                ((_binding->rx_union).bind_udn_reply).con_id = ((((_binding->rx_union).bind_udn_reply).con_id) | (((uint64_t )((msg->data)[2])) << 32));
                ((_binding->rx_union).bind_udn_reply).mon_id = ((msg->data)[3]);
                ((_binding->rx_union).bind_udn_reply).mon_id = ((((_binding->rx_union).bind_udn_reply).mon_id) | (((uint64_t )((msg->data)[4])) << 32));
                ((_binding->rx_union).bind_udn_reply).err = ((msg->data)[5]);
                (((_binding->rx_union).bind_udn_reply).notify).w0 = ((msg->data)[6]);
                (((_binding->rx_union).bind_udn_reply).notify).w0 = (((((_binding->rx_union).bind_udn_reply).notify).w0) | (((uint64_t )((msg->data)[7])) << 32));
                (((_binding->rx_union).bind_udn_reply).notify).w1 = ((msg->data)[8]);
                (((_binding->rx_union).bind_udn_reply).notify).w1 = (((((_binding->rx_union).bind_udn_reply).notify).w1) | (((uint64_t )((msg->data)[9])) << 32));
                (((_binding->rx_union).bind_udn_reply).notify).w2 = ((msg->data)[10]);
                (((_binding->rx_union).bind_udn_reply).notify).w2 = (((((_binding->rx_union).bind_udn_reply).notify).w2) | (((uint64_t )((msg->data)[11])) << 32));
                (((_binding->rx_union).bind_udn_reply).notify).w3 = ((msg->data)[12]);
                (((_binding->rx_union).bind_udn_reply).notify).w3 = (((((_binding->rx_union).bind_udn_reply).notify).w3) | (((uint64_t )((msg->data)[13])) << 32));
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                ((_binding->rx_union).bind_udn_reply).chan_id = ((msg->data)[0]);
                
                FL_DEBUG("udn RX intermon.bind_udn_reply\n");
                assert(((_binding->rx_vtbl).bind_udn_reply) != NULL);
                ((_binding->rx_vtbl).bind_udn_reply)(_binding, ((_binding->rx_union).bind_udn_reply).con_id, ((_binding->rx_union).bind_udn_reply).mon_id, ((_binding->rx_union).bind_udn_reply).err, ((_binding->rx_union).bind_udn_reply).notify, ((_binding->rx_union).bind_udn_reply).core_id, ((_binding->rx_union).bind_udn_reply).chan_id, ((_binding->rx_union).bind_udn_reply).asid);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_cap_send_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).cap_send_request).on_cores = malloc(sizeof(intermon_coremask_t ));
                assert((((_binding->rx_union).cap_send_request).on_cores) != NULL);
                ((_binding->rx_union).cap_send_request).give_away = (((msg->data)[0]) & 0x1);
                ((_binding->rx_union).cap_send_request).has_descendents = ((((msg->data)[0]) >> 1) & 0x1);
                ((_binding->rx_union).cap_send_request).null_cap = ((((msg->data)[0]) >> 2) & 0x1);
                ((_binding->rx_union).cap_send_request).con_id = ((msg->data)[1]);
                ((_binding->rx_union).cap_send_request).con_id = ((((_binding->rx_union).cap_send_request).con_id) | (((uint64_t )((msg->data)[2])) << 32));
                ((_binding->rx_union).cap_send_request).capid = ((msg->data)[3]);
                (((_binding->rx_union).cap_send_request).cap).w0 = ((msg->data)[4]);
                (((_binding->rx_union).cap_send_request).cap).w0 = (((((_binding->rx_union).cap_send_request).cap).w0) | (((uint64_t )((msg->data)[5])) << 32));
                (((_binding->rx_union).cap_send_request).cap).w1 = ((msg->data)[6]);
                (((_binding->rx_union).cap_send_request).cap).w1 = (((((_binding->rx_union).cap_send_request).cap).w1) | (((uint64_t )((msg->data)[7])) << 32));
                (((_binding->rx_union).cap_send_request).cap).w2 = ((msg->data)[8]);
                (((_binding->rx_union).cap_send_request).cap).w2 = (((((_binding->rx_union).cap_send_request).cap).w2) | (((uint64_t )((msg->data)[9])) << 32));
                (((_binding->rx_union).cap_send_request).cap).w3 = ((msg->data)[10]);
                (((_binding->rx_union).cap_send_request).cap).w3 = (((((_binding->rx_union).cap_send_request).cap).w3) | (((uint64_t )((msg->data)[11])) << 32));
                ((_binding->rx_union).cap_send_request).err = ((msg->data)[12]);
                (*(((_binding->rx_union).cap_send_request).on_cores))[0] = ((msg->data)[13]);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                (*(((_binding->rx_union).cap_send_request).on_cores))[0] = (((*(((_binding->rx_union).cap_send_request).on_cores))[0]) | (((uint64_t )((msg->data)[0])) << 32));
                (*(((_binding->rx_union).cap_send_request).on_cores))[1] = ((msg->data)[1]);
                (*(((_binding->rx_union).cap_send_request).on_cores))[1] = (((*(((_binding->rx_union).cap_send_request).on_cores))[1]) | (((uint64_t )((msg->data)[2])) << 32));
                (*(((_binding->rx_union).cap_send_request).on_cores))[2] = ((msg->data)[3]);
                (*(((_binding->rx_union).cap_send_request).on_cores))[2] = (((*(((_binding->rx_union).cap_send_request).on_cores))[2]) | (((uint64_t )((msg->data)[4])) << 32));
                (*(((_binding->rx_union).cap_send_request).on_cores))[3] = ((msg->data)[5]);
                (*(((_binding->rx_union).cap_send_request).on_cores))[3] = (((*(((_binding->rx_union).cap_send_request).on_cores))[3]) | (((uint64_t )((msg->data)[6])) << 32));
                
                FL_DEBUG("udn RX intermon.cap_send_request\n");
                assert(((_binding->rx_vtbl).cap_send_request) != NULL);
                ((_binding->rx_vtbl).cap_send_request)(_binding, ((_binding->rx_union).cap_send_request).con_id, ((_binding->rx_union).cap_send_request).capid, ((_binding->rx_union).cap_send_request).cap, ((_binding->rx_union).cap_send_request).err, ((_binding->rx_union).cap_send_request).give_away, ((_binding->rx_union).cap_send_request).has_descendents, *(((_binding->rx_union).cap_send_request).on_cores), ((_binding->rx_union).cap_send_request).null_cap);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_span_domain_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).span_domain_request).framebits = (((msg->data)[0]) & 0xff);
                ((_binding->rx_union).span_domain_request).state_id = ((msg->data)[1]);
                ((_binding->rx_union).span_domain_request).state_id = ((((_binding->rx_union).span_domain_request).state_id) | (((uint64_t )((msg->data)[2])) << 32));
                ((_binding->rx_union).span_domain_request).vnodebase = ((msg->data)[3]);
                ((_binding->rx_union).span_domain_request).vnodebase = ((((_binding->rx_union).span_domain_request).vnodebase) | (((uint64_t )((msg->data)[4])) << 32));
                ((_binding->rx_union).span_domain_request).framebase = ((msg->data)[5]);
                ((_binding->rx_union).span_domain_request).framebase = ((((_binding->rx_union).span_domain_request).framebase) | (((uint64_t )((msg->data)[6])) << 32));
                
                FL_DEBUG("udn RX intermon.span_domain_request\n");
                assert(((_binding->rx_vtbl).span_domain_request) != NULL);
                ((_binding->rx_vtbl).span_domain_request)(_binding, ((_binding->rx_union).span_domain_request).state_id, ((_binding->rx_union).span_domain_request).vnodebase, ((_binding->rx_union).span_domain_request).framebase, ((_binding->rx_union).span_domain_request).framebits);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_span_domain_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).span_domain_reply).state_id = ((msg->data)[0]);
                ((_binding->rx_union).span_domain_reply).state_id = ((((_binding->rx_union).span_domain_reply).state_id) | (((uint64_t )((msg->data)[1])) << 32));
                ((_binding->rx_union).span_domain_reply).err = ((msg->data)[2]);
                
                FL_DEBUG("udn RX intermon.span_domain_reply\n");
                assert(((_binding->rx_vtbl).span_domain_reply) != NULL);
                ((_binding->rx_vtbl).span_domain_reply)(_binding, ((_binding->rx_union).span_domain_reply).state_id, ((_binding->rx_union).span_domain_reply).err);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_rsrc_join__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).rsrc_join).coreid = (((msg->data)[0]) & 0xff);
                ((_binding->rx_union).rsrc_join).id = ((msg->data)[1]);
                
                FL_DEBUG("udn RX intermon.rsrc_join\n");
                assert(((_binding->rx_vtbl).rsrc_join) != NULL);
                ((_binding->rx_vtbl).rsrc_join)(_binding, ((_binding->rx_union).rsrc_join).id, ((_binding->rx_union).rsrc_join).coreid);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_rsrc_join_complete__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).rsrc_join_complete).id = ((msg->data)[0]);
                
                FL_DEBUG("udn RX intermon.rsrc_join_complete\n");
                assert(((_binding->rx_vtbl).rsrc_join_complete) != NULL);
                ((_binding->rx_vtbl).rsrc_join_complete)(_binding, ((_binding->rx_union).rsrc_join_complete).id);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_rsrc_phase_data__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).rsrc_phase_data).id = ((msg->data)[0]);
                ((_binding->rx_union).rsrc_phase_data).phase = ((msg->data)[1]);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                err = flounder_stub_udn_recv_buf(msg, (void **)(&(((_binding->rx_union).rsrc_phase_data).data)), &(((_binding->rx_union).rsrc_phase_data).len), &(_binding->rx_str_pos));
                if (err_is_ok(err)) {
                    FL_DEBUG("udn RX intermon.rsrc_phase_data\n");
                    assert(((_binding->rx_vtbl).rsrc_phase_data) != NULL);
                    ((_binding->rx_vtbl).rsrc_phase_data)(_binding, ((_binding->rx_union).rsrc_phase_data).id, ((_binding->rx_union).rsrc_phase_data).phase, ((_binding->rx_union).rsrc_phase_data).data, ((_binding->rx_union).rsrc_phase_data).len);
                    _binding->rx_msgnum = 0;
                } else {
                    if (err_no(err) != FLOUNDER_ERR_BUF_RECV_MORE) {
                        (_binding->error_handler)(_binding, err);
                    }
                }
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_rsrc_timer_sync__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).rsrc_timer_sync).timestamp = ((msg->data)[0]);
                ((_binding->rx_union).rsrc_timer_sync).timestamp = ((((_binding->rx_union).rsrc_timer_sync).timestamp) | (((uint64_t )((msg->data)[1])) << 32));
                
                FL_DEBUG("udn RX intermon.rsrc_timer_sync\n");
                assert(((_binding->rx_vtbl).rsrc_timer_sync) != NULL);
                ((_binding->rx_vtbl).rsrc_timer_sync)(_binding, ((_binding->rx_union).rsrc_timer_sync).timestamp);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_rsrc_timer_sync_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).rsrc_timer_sync_reply).err = ((msg->data)[0]);
                
                FL_DEBUG("udn RX intermon.rsrc_timer_sync_reply\n");
                assert(((_binding->rx_vtbl).rsrc_timer_sync_reply) != NULL);
                ((_binding->rx_vtbl).rsrc_timer_sync_reply)(_binding, ((_binding->rx_union).rsrc_timer_sync_reply).err);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_rsrc_phase__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).rsrc_phase).id = ((msg->data)[0]);
                ((_binding->rx_union).rsrc_phase).phase = ((msg->data)[1]);
                ((_binding->rx_union).rsrc_phase).timestamp = ((msg->data)[2]);
                ((_binding->rx_union).rsrc_phase).timestamp = ((((_binding->rx_union).rsrc_phase).timestamp) | (((uint64_t )((msg->data)[3])) << 32));
                
                FL_DEBUG("udn RX intermon.rsrc_phase\n");
                assert(((_binding->rx_vtbl).rsrc_phase) != NULL);
                ((_binding->rx_vtbl).rsrc_phase)(_binding, ((_binding->rx_union).rsrc_phase).id, ((_binding->rx_union).rsrc_phase).phase, ((_binding->rx_union).rsrc_phase).timestamp);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_multihop_routing_table_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).multihop_routing_table_request).source_coreid = (((msg->data)[0]) & 0xff);
                
                FL_DEBUG("udn RX intermon.multihop_routing_table_request\n");
                assert(((_binding->rx_vtbl).multihop_routing_table_request) != NULL);
                ((_binding->rx_vtbl).multihop_routing_table_request)(_binding, ((_binding->rx_union).multihop_routing_table_request).source_coreid);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_multihop_routing_table_response__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).multihop_routing_table_response).source_coreid = (((msg->data)[0]) & 0xff);
                ((_binding->rx_union).multihop_routing_table_response).max_coreid = ((((msg->data)[0]) >> 8) & 0xff);
                ((_binding->rx_union).multihop_routing_table_response).err = ((msg->data)[1]);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                err = flounder_stub_udn_recv_buf(msg, (void **)(&(((_binding->rx_union).multihop_routing_table_response).to)), &(((_binding->rx_union).multihop_routing_table_response).len), &(_binding->rx_str_pos));
                if (err_is_ok(err)) {
                    FL_DEBUG("udn RX intermon.multihop_routing_table_response\n");
                    assert(((_binding->rx_vtbl).multihop_routing_table_response) != NULL);
                    ((_binding->rx_vtbl).multihop_routing_table_response)(_binding, ((_binding->rx_union).multihop_routing_table_response).err, ((_binding->rx_union).multihop_routing_table_response).source_coreid, ((_binding->rx_union).multihop_routing_table_response).max_coreid, ((_binding->rx_union).multihop_routing_table_response).to, ((_binding->rx_union).multihop_routing_table_response).len);
                    _binding->rx_msgnum = 0;
                } else {
                    if (err_no(err) != FLOUNDER_ERR_BUF_RECV_MORE) {
                        (_binding->error_handler)(_binding, err);
                    }
                }
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_multihop_routing_table_grow__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).multihop_routing_table_grow).forwarder = (((msg->data)[0]) & 0xff);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                err = flounder_stub_udn_recv_buf(msg, (void **)(&(((_binding->rx_union).multihop_routing_table_grow).destinations)), &(((_binding->rx_union).multihop_routing_table_grow).len), &(_binding->rx_str_pos));
                if (err_is_ok(err)) {
                    FL_DEBUG("udn RX intermon.multihop_routing_table_grow\n");
                    assert(((_binding->rx_vtbl).multihop_routing_table_grow) != NULL);
                    ((_binding->rx_vtbl).multihop_routing_table_grow)(_binding, ((_binding->rx_union).multihop_routing_table_grow).forwarder, ((_binding->rx_union).multihop_routing_table_grow).destinations, ((_binding->rx_union).multihop_routing_table_grow).len);
                    _binding->rx_msgnum = 0;
                } else {
                    if (err_no(err) != FLOUNDER_ERR_BUF_RECV_MORE) {
                        (_binding->error_handler)(_binding, err);
                    }
                }
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_multihop_intermon_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).bind_multihop_intermon_request).core_id = (((msg->data)[0]) & 0xff);
                ((_binding->rx_union).bind_multihop_intermon_request).iref = ((msg->data)[1]);
                ((_binding->rx_union).bind_multihop_intermon_request).sender_vci = ((msg->data)[2]);
                ((_binding->rx_union).bind_multihop_intermon_request).sender_vci = ((((_binding->rx_union).bind_multihop_intermon_request).sender_vci) | (((uint64_t )((msg->data)[3])) << 32));
                
                FL_DEBUG("udn RX intermon.bind_multihop_intermon_request\n");
                assert(((_binding->rx_vtbl).bind_multihop_intermon_request) != NULL);
                ((_binding->rx_vtbl).bind_multihop_intermon_request)(_binding, ((_binding->rx_union).bind_multihop_intermon_request).iref, ((_binding->rx_union).bind_multihop_intermon_request).sender_vci, ((_binding->rx_union).bind_multihop_intermon_request).core_id);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bind_multihop_intermon_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).bind_multihop_intermon_reply).receiver_vci = ((msg->data)[0]);
                ((_binding->rx_union).bind_multihop_intermon_reply).receiver_vci = ((((_binding->rx_union).bind_multihop_intermon_reply).receiver_vci) | (((uint64_t )((msg->data)[1])) << 32));
                ((_binding->rx_union).bind_multihop_intermon_reply).sender_vci = ((msg->data)[2]);
                ((_binding->rx_union).bind_multihop_intermon_reply).sender_vci = ((((_binding->rx_union).bind_multihop_intermon_reply).sender_vci) | (((uint64_t )((msg->data)[3])) << 32));
                ((_binding->rx_union).bind_multihop_intermon_reply).err = ((msg->data)[4]);
                
                FL_DEBUG("udn RX intermon.bind_multihop_intermon_reply\n");
                assert(((_binding->rx_vtbl).bind_multihop_intermon_reply) != NULL);
                ((_binding->rx_vtbl).bind_multihop_intermon_reply)(_binding, ((_binding->rx_union).bind_multihop_intermon_reply).receiver_vci, ((_binding->rx_union).bind_multihop_intermon_reply).sender_vci, ((_binding->rx_union).bind_multihop_intermon_reply).err);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_multihop_message__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).multihop_message).direction = (((msg->data)[0]) & 0xff);
                ((_binding->rx_union).multihop_message).flags = ((((msg->data)[0]) >> 8) & 0xff);
                ((_binding->rx_union).multihop_message).vci = ((msg->data)[1]);
                ((_binding->rx_union).multihop_message).vci = ((((_binding->rx_union).multihop_message).vci) | (((uint64_t )((msg->data)[2])) << 32));
                ((_binding->rx_union).multihop_message).ack = ((msg->data)[3]);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                err = flounder_stub_udn_recv_buf(msg, (void **)(&(((_binding->rx_union).multihop_message).payload)), &(((_binding->rx_union).multihop_message).size), &(_binding->rx_str_pos));
                if (err_is_ok(err)) {
                    FL_DEBUG("udn RX intermon.multihop_message\n");
                    assert(((_binding->rx_vtbl).multihop_message) != NULL);
                    ((_binding->rx_vtbl).multihop_message)(_binding, ((_binding->rx_union).multihop_message).vci, ((_binding->rx_union).multihop_message).direction, ((_binding->rx_union).multihop_message).flags, ((_binding->rx_union).multihop_message).ack, ((_binding->rx_union).multihop_message).payload, ((_binding->rx_union).multihop_message).size);
                    _binding->rx_msgnum = 0;
                } else {
                    if (err_no(err) != FLOUNDER_ERR_BUF_RECV_MORE) {
                        (_binding->error_handler)(_binding, err);
                    }
                }
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_multihop_cap_send__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).multihop_cap_send).null_cap = (((msg->data)[0]) & 0x1);
                ((_binding->rx_union).multihop_cap_send).direction = ((((msg->data)[0]) >> 1) & 0xff);
                ((_binding->rx_union).multihop_cap_send).vci = ((msg->data)[1]);
                ((_binding->rx_union).multihop_cap_send).vci = ((((_binding->rx_union).multihop_cap_send).vci) | (((uint64_t )((msg->data)[2])) << 32));
                ((_binding->rx_union).multihop_cap_send).capid = ((msg->data)[3]);
                ((_binding->rx_union).multihop_cap_send).err = ((msg->data)[4]);
                (((_binding->rx_union).multihop_cap_send).cap).w0 = ((msg->data)[5]);
                (((_binding->rx_union).multihop_cap_send).cap).w0 = (((((_binding->rx_union).multihop_cap_send).cap).w0) | (((uint64_t )((msg->data)[6])) << 32));
                (((_binding->rx_union).multihop_cap_send).cap).w1 = ((msg->data)[7]);
                (((_binding->rx_union).multihop_cap_send).cap).w1 = (((((_binding->rx_union).multihop_cap_send).cap).w1) | (((uint64_t )((msg->data)[8])) << 32));
                (((_binding->rx_union).multihop_cap_send).cap).w2 = ((msg->data)[9]);
                (((_binding->rx_union).multihop_cap_send).cap).w2 = (((((_binding->rx_union).multihop_cap_send).cap).w2) | (((uint64_t )((msg->data)[10])) << 32));
                (((_binding->rx_union).multihop_cap_send).cap).w3 = ((msg->data)[11]);
                (((_binding->rx_union).multihop_cap_send).cap).w3 = (((((_binding->rx_union).multihop_cap_send).cap).w3) | (((uint64_t )((msg->data)[12])) << 32));
                
                FL_DEBUG("udn RX intermon.multihop_cap_send\n");
                assert(((_binding->rx_vtbl).multihop_cap_send) != NULL);
                ((_binding->rx_vtbl).multihop_cap_send)(_binding, ((_binding->rx_union).multihop_cap_send).vci, ((_binding->rx_union).multihop_cap_send).direction, ((_binding->rx_union).multihop_cap_send).capid, ((_binding->rx_union).multihop_cap_send).err, ((_binding->rx_union).multihop_cap_send).cap, ((_binding->rx_union).multihop_cap_send).null_cap);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_trace_prepare__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).trace_prepare).origin_core = (((msg->data)[0]) & 0xff);
                
                FL_DEBUG("udn RX intermon.trace_prepare\n");
                assert(((_binding->rx_vtbl).trace_prepare) != NULL);
                ((_binding->rx_vtbl).trace_prepare)(_binding, ((_binding->rx_union).trace_prepare).origin_core);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_trace_prepare_finished__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                
                FL_DEBUG("udn RX intermon.trace_prepare_finished\n");
                assert(((_binding->rx_vtbl).trace_prepare_finished) != NULL);
                ((_binding->rx_vtbl).trace_prepare_finished)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_trace_measure__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).trace_measure).origin_core = (((msg->data)[0]) & 0xff);
                ((_binding->rx_union).trace_measure).t0 = ((msg->data)[1]);
                ((_binding->rx_union).trace_measure).t0 = ((((_binding->rx_union).trace_measure).t0) | (((uint64_t )((msg->data)[2])) << 32));
                
                FL_DEBUG("udn RX intermon.trace_measure\n");
                assert(((_binding->rx_vtbl).trace_measure) != NULL);
                ((_binding->rx_vtbl).trace_measure)(_binding, ((_binding->rx_union).trace_measure).origin_core, ((_binding->rx_union).trace_measure).t0);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_trace_measure_ack__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).trace_measure_ack).origin_core = (((msg->data)[0]) & 0xff);
                ((_binding->rx_union).trace_measure_ack).t0 = ((msg->data)[1]);
                ((_binding->rx_union).trace_measure_ack).t0 = ((((_binding->rx_union).trace_measure_ack).t0) | (((uint64_t )((msg->data)[2])) << 32));
                ((_binding->rx_union).trace_measure_ack).t1 = ((msg->data)[3]);
                ((_binding->rx_union).trace_measure_ack).t1 = ((((_binding->rx_union).trace_measure_ack).t1) | (((uint64_t )((msg->data)[4])) << 32));
                ((_binding->rx_union).trace_measure_ack).t2 = ((msg->data)[5]);
                ((_binding->rx_union).trace_measure_ack).t2 = ((((_binding->rx_union).trace_measure_ack).t2) | (((uint64_t )((msg->data)[6])) << 32));
                
                FL_DEBUG("udn RX intermon.trace_measure_ack\n");
                assert(((_binding->rx_vtbl).trace_measure_ack) != NULL);
                ((_binding->rx_vtbl).trace_measure_ack)(_binding, ((_binding->rx_union).trace_measure_ack).origin_core, ((_binding->rx_union).trace_measure_ack).t0, ((_binding->rx_union).trace_measure_ack).t1, ((_binding->rx_union).trace_measure_ack).t2);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bfscope_flush_send_forward__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).bfscope_flush_send_forward).iref = ((msg->data)[0]);
                
                FL_DEBUG("udn RX intermon.bfscope_flush_send_forward\n");
                assert(((_binding->rx_vtbl).bfscope_flush_send_forward) != NULL);
                ((_binding->rx_vtbl).bfscope_flush_send_forward)(_binding, ((_binding->rx_union).bfscope_flush_send_forward).iref);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case intermon_bfscope_flush_ack_forward__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                
                FL_DEBUG("udn RX intermon.bfscope_flush_ack_forward\n");
                assert(((_binding->rx_vtbl).bfscope_flush_ack_forward) != NULL);
                ((_binding->rx_vtbl).bfscope_flush_ack_forward)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        default:
            (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_MSGNUM);
            goto out;
        }
        
        loopnext:
        // send an ack if the channel is now full
        if (flounder_stub_udn_needs_ack(&(b->udn_state))) {
            // run our send process if we need to
            if ((((b->udn_state).capst).tx_cap_ack) || ((_binding->tx_msgnum) != 0)) {
                intermon_udn_send_handler(b);
            } else {
                flounder_stub_udn_send_ack(&(b->udn_state));
            }
        }
    }
    
    out:
    // register for receive notification
    err = udn_chan_register_recv(&((b->udn_state).chan), _binding->waitset, (struct event_closure){  .handler = intermon_udn_rx_handler,  .arg = _binding });
    if (err_is_fail(err)) {
        (_binding->error_handler)(_binding, err_push(err, LIB_ERR_CHAN_REGISTER_RECV));
    }
    
    out_no_reregister:
    __attribute__((unused));
    // run our send process, if we need to
    if ((((b->udn_state).capst).tx_cap_ack) || ((_binding->tx_msgnum) != 0)) {
        intermon_udn_send_handler(b);
    } else {
        // otherwise send a forced ack if the channel is now full
        if (flounder_stub_udn_needs_ack(&(b->udn_state))) {
            flounder_stub_udn_send_ack(&(b->udn_state));
        }
    }
}


/*
 * Cap send/receive handlers
 */
static  void intermon_udn_cap_rx_handler(void *arg, errval_t success, struct capref cap, uint32_t capid)
{
    // Get the binding state from our argument pointer
    struct intermon_binding *_binding = arg;
    struct intermon_udn_binding *b = arg;
    errval_t err;
    err = SYS_ERR_OK;
    
    assert(capid == (((b->udn_state).capst).rx_capnum));
    
    // Check if there's an associated error
    // FIXME: how should we report this to the user? at present we just deliver a NULL capref
    if (err_is_fail(success)) {
        DEBUG_ERR(err, "error in cap transfer");
    }
    
    // Switch on current incoming message
    switch (_binding->rx_msgnum) {
    default:
        assert(!("invalid message number"));
        (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
    }
}


/*
 * Message sender functions
 */
static  errval_t intermon_spawnd_image_request__udn_send(struct intermon_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_spawnd_image_request__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("udn TX intermon.spawnd_image_request\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_spawnd_image_reply__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_genpaddr_t base, uint32_t bytes)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_spawnd_image_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).spawnd_image_reply).base = base;
    ((_binding->tx_union).spawnd_image_reply).bytes = bytes;
    FL_DEBUG("udn TX intermon.spawnd_image_reply\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_monitor_initialized__udn_send(struct intermon_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_monitor_initialized__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("udn TX intermon.monitor_initialized\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_trace_caps_request__udn_send(struct intermon_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_trace_caps_request__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("udn TX intermon.trace_caps_request\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_trace_caps_reply__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_caprep_t cap)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_trace_caps_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).trace_caps_reply).cap = cap;
    FL_DEBUG("udn TX intermon.trace_caps_reply\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_mem_serv_iref_request__udn_send(struct intermon_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_mem_serv_iref_request__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("udn TX intermon.mem_serv_iref_request\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_mem_serv_iref_reply__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, iref_t iref)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_mem_serv_iref_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).mem_serv_iref_reply).iref = iref;
    FL_DEBUG("udn TX intermon.mem_serv_iref_reply\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_ramfs_serv_iref_request__udn_send(struct intermon_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_ramfs_serv_iref_request__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("udn TX intermon.ramfs_serv_iref_request\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_ramfs_serv_iref_reply__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, iref_t iref)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_ramfs_serv_iref_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).ramfs_serv_iref_reply).iref = iref;
    FL_DEBUG("udn TX intermon.ramfs_serv_iref_reply\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_name_serv_iref_request__udn_send(struct intermon_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_name_serv_iref_request__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("udn TX intermon.name_serv_iref_request\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_name_serv_iref_reply__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, iref_t iref)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_name_serv_iref_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).name_serv_iref_reply).iref = iref;
    FL_DEBUG("udn TX intermon.name_serv_iref_reply\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_monitor_mem_iref_request__udn_send(struct intermon_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_monitor_mem_iref_request__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("udn TX intermon.monitor_mem_iref_request\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_monitor_mem_iref_reply__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, iref_t iref)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_monitor_mem_iref_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).monitor_mem_iref_reply).iref = iref;
    FL_DEBUG("udn TX intermon.monitor_mem_iref_reply\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_monitor_request__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_coreid_t_t core_id, intermon_caprep_t cap)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_monitor_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_monitor_request).core_id = core_id;
    ((_binding->tx_union).bind_monitor_request).cap = cap;
    FL_DEBUG("udn TX intermon.bind_monitor_request\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_monitor_reply__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_errval_t err)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_monitor_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_monitor_reply).err = err;
    FL_DEBUG("udn TX intermon.bind_monitor_reply\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_monitor_proxy__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_coreid_t_t dst_core_id, intermon_caprep_t cap)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_monitor_proxy__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_monitor_proxy).dst_core_id = dst_core_id;
    ((_binding->tx_union).bind_monitor_proxy).cap = cap;
    FL_DEBUG("udn TX intermon.bind_monitor_proxy\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_monitor_request_scc__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_coreid_t_t core_id, intermon_caprep_t cap, intermon_chanid_t_t chan_id, intermon_coreid_t_t from_core_id)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_monitor_request_scc__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_monitor_request_scc).core_id = core_id;
    ((_binding->tx_union).bind_monitor_request_scc).cap = cap;
    ((_binding->tx_union).bind_monitor_request_scc).chan_id = chan_id;
    ((_binding->tx_union).bind_monitor_request_scc).from_core_id = from_core_id;
    FL_DEBUG("udn TX intermon.bind_monitor_request_scc\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_monitor_reply_scc__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_errval_t err, intermon_chanid_t_t chan_id, intermon_coreid_t_t core_id)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_monitor_reply_scc__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_monitor_reply_scc).err = err;
    ((_binding->tx_union).bind_monitor_reply_scc).chan_id = chan_id;
    ((_binding->tx_union).bind_monitor_reply_scc).core_id = core_id;
    FL_DEBUG("udn TX intermon.bind_monitor_reply_scc\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_monitor_proxy_scc__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_coreid_t_t dst_core_id, intermon_caprep_t cap, intermon_chanid_t_t chan_id, intermon_coreid_t_t core_id)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_monitor_proxy_scc__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_monitor_proxy_scc).dst_core_id = dst_core_id;
    ((_binding->tx_union).bind_monitor_proxy_scc).cap = cap;
    ((_binding->tx_union).bind_monitor_proxy_scc).chan_id = chan_id;
    ((_binding->tx_union).bind_monitor_proxy_scc).core_id = core_id;
    FL_DEBUG("udn TX intermon.bind_monitor_proxy_scc\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_monitor_request_bmp__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_coreid_t_t core_id, intermon_chanid_t_t chan_id, intermon_coreid_t_t from_core_id)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_monitor_request_bmp__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_monitor_request_bmp).core_id = core_id;
    ((_binding->tx_union).bind_monitor_request_bmp).chan_id = chan_id;
    ((_binding->tx_union).bind_monitor_request_bmp).from_core_id = from_core_id;
    FL_DEBUG("udn TX intermon.bind_monitor_request_bmp\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_monitor_reply_bmp__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_errval_t err, intermon_chanid_t_t chan_id, intermon_coreid_t_t core_id)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_monitor_reply_bmp__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_monitor_reply_bmp).err = err;
    ((_binding->tx_union).bind_monitor_reply_bmp).chan_id = chan_id;
    ((_binding->tx_union).bind_monitor_reply_bmp).core_id = core_id;
    FL_DEBUG("udn TX intermon.bind_monitor_reply_bmp\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_monitor_proxy_bmp__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_coreid_t_t dst_core_id, intermon_chanid_t_t chan_id, intermon_coreid_t_t core_id)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_monitor_proxy_bmp__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_monitor_proxy_bmp).dst_core_id = dst_core_id;
    ((_binding->tx_union).bind_monitor_proxy_bmp).chan_id = chan_id;
    ((_binding->tx_union).bind_monitor_proxy_bmp).core_id = core_id;
    FL_DEBUG("udn TX intermon.bind_monitor_proxy_bmp\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_new_monitor_notify__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_coreid_t_t core_id)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_new_monitor_notify__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).new_monitor_notify).core_id = core_id;
    FL_DEBUG("udn TX intermon.new_monitor_notify\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_ump_request__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, iref_t iref, intermon_mon_id_t_t mon_id, uint32_t channel_length_in, uint32_t channel_length_out, intermon_genpaddr_t framebase, uint8_t framebits, intermon_caprep_t notify)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_ump_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_ump_request).iref = iref;
    ((_binding->tx_union).bind_ump_request).mon_id = mon_id;
    ((_binding->tx_union).bind_ump_request).channel_length_in = channel_length_in;
    ((_binding->tx_union).bind_ump_request).channel_length_out = channel_length_out;
    ((_binding->tx_union).bind_ump_request).framebase = framebase;
    ((_binding->tx_union).bind_ump_request).framebits = framebits;
    ((_binding->tx_union).bind_ump_request).notify = notify;
    FL_DEBUG("udn TX intermon.bind_ump_request\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_ump_reply__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_con_id_t_t con_id, intermon_mon_id_t_t mon_id, intermon_errval_t err, intermon_caprep_t notify)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_ump_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_ump_reply).con_id = con_id;
    ((_binding->tx_union).bind_ump_reply).mon_id = mon_id;
    ((_binding->tx_union).bind_ump_reply).err = err;
    ((_binding->tx_union).bind_ump_reply).notify = notify;
    FL_DEBUG("udn TX intermon.bind_ump_reply\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_udn_request__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, iref_t iref, intermon_mon_id_t_t mon_id, intermon_caprep_t notify, intermon_coreid_t_t core_id, intermon_chanid_t_t chan_id, uint8_t asid)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_udn_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_udn_request).iref = iref;
    ((_binding->tx_union).bind_udn_request).mon_id = mon_id;
    ((_binding->tx_union).bind_udn_request).notify = notify;
    ((_binding->tx_union).bind_udn_request).core_id = core_id;
    ((_binding->tx_union).bind_udn_request).chan_id = chan_id;
    ((_binding->tx_union).bind_udn_request).asid = asid;
    FL_DEBUG("udn TX intermon.bind_udn_request\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_udn_reply__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_con_id_t_t con_id, intermon_mon_id_t_t mon_id, intermon_errval_t err, intermon_caprep_t notify, intermon_coreid_t_t core_id, intermon_chanid_t_t chan_id, uint8_t asid)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_udn_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_udn_reply).con_id = con_id;
    ((_binding->tx_union).bind_udn_reply).mon_id = mon_id;
    ((_binding->tx_union).bind_udn_reply).err = err;
    ((_binding->tx_union).bind_udn_reply).notify = notify;
    ((_binding->tx_union).bind_udn_reply).core_id = core_id;
    ((_binding->tx_union).bind_udn_reply).chan_id = chan_id;
    ((_binding->tx_union).bind_udn_reply).asid = asid;
    FL_DEBUG("udn TX intermon.bind_udn_reply\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_cap_send_request__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_con_id_t_t con_id, intermon_capid_t_t capid, intermon_caprep_t cap, intermon_errval_t err, bool give_away, bool has_descendents, intermon_coremask_t on_cores, bool null_cap)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_cap_send_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).cap_send_request).con_id = con_id;
    ((_binding->tx_union).cap_send_request).capid = capid;
    ((_binding->tx_union).cap_send_request).cap = cap;
    ((_binding->tx_union).cap_send_request).err = err;
    ((_binding->tx_union).cap_send_request).give_away = give_away;
    ((_binding->tx_union).cap_send_request).has_descendents = has_descendents;
    ((_binding->tx_union).cap_send_request).on_cores = ((intermon_coremask_t *)(on_cores));
    ((_binding->tx_union).cap_send_request).null_cap = null_cap;
    FL_DEBUG("udn TX intermon.cap_send_request\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_span_domain_request__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_state_id_t_t state_id, intermon_genpaddr_t vnodebase, intermon_genpaddr_t framebase, uint8_t framebits)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_span_domain_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).span_domain_request).state_id = state_id;
    ((_binding->tx_union).span_domain_request).vnodebase = vnodebase;
    ((_binding->tx_union).span_domain_request).framebase = framebase;
    ((_binding->tx_union).span_domain_request).framebits = framebits;
    FL_DEBUG("udn TX intermon.span_domain_request\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_span_domain_reply__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_state_id_t_t state_id, intermon_errval_t err)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_span_domain_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).span_domain_reply).state_id = state_id;
    ((_binding->tx_union).span_domain_reply).err = err;
    FL_DEBUG("udn TX intermon.span_domain_reply\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_rsrc_join__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_rsrcid_t id, intermon_coreid_t_t coreid)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_rsrc_join__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).rsrc_join).id = id;
    ((_binding->tx_union).rsrc_join).coreid = coreid;
    FL_DEBUG("udn TX intermon.rsrc_join\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_rsrc_join_complete__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_rsrcid_t id)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_rsrc_join_complete__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).rsrc_join_complete).id = id;
    FL_DEBUG("udn TX intermon.rsrc_join_complete\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_rsrc_phase_data__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_rsrcid_t id, uint32_t phase, const uint8_t *data, size_t len)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_rsrc_phase_data__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).rsrc_phase_data).id = id;
    ((_binding->tx_union).rsrc_phase_data).phase = phase;
    ((_binding->tx_union).rsrc_phase_data).data = ((uint8_t *)(data));
    ((_binding->tx_union).rsrc_phase_data).len = len;
    FL_DEBUG("udn TX intermon.rsrc_phase_data\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_rsrc_timer_sync__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, uint64_t timestamp)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_rsrc_timer_sync__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).rsrc_timer_sync).timestamp = timestamp;
    FL_DEBUG("udn TX intermon.rsrc_timer_sync\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_rsrc_timer_sync_reply__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_errval_t err)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_rsrc_timer_sync_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).rsrc_timer_sync_reply).err = err;
    FL_DEBUG("udn TX intermon.rsrc_timer_sync_reply\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_rsrc_phase__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_rsrcid_t id, uint32_t phase, uint64_t timestamp)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_rsrc_phase__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).rsrc_phase).id = id;
    ((_binding->tx_union).rsrc_phase).phase = phase;
    ((_binding->tx_union).rsrc_phase).timestamp = timestamp;
    FL_DEBUG("udn TX intermon.rsrc_phase\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_multihop_routing_table_request__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_coreid_t source_coreid)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_multihop_routing_table_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).multihop_routing_table_request).source_coreid = source_coreid;
    FL_DEBUG("udn TX intermon.multihop_routing_table_request\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_multihop_routing_table_response__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_errval_t err, intermon_coreid_t source_coreid, intermon_coreid_t max_coreid, const intermon_coreid_t *to, size_t len)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_multihop_routing_table_response__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).multihop_routing_table_response).err = err;
    ((_binding->tx_union).multihop_routing_table_response).source_coreid = source_coreid;
    ((_binding->tx_union).multihop_routing_table_response).max_coreid = max_coreid;
    ((_binding->tx_union).multihop_routing_table_response).to = ((intermon_coreid_t *)(to));
    ((_binding->tx_union).multihop_routing_table_response).len = len;
    FL_DEBUG("udn TX intermon.multihop_routing_table_response\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_multihop_routing_table_grow__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_coreid_t forwarder, const intermon_coreid_t *destinations, size_t len)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_multihop_routing_table_grow__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).multihop_routing_table_grow).forwarder = forwarder;
    ((_binding->tx_union).multihop_routing_table_grow).destinations = ((intermon_coreid_t *)(destinations));
    ((_binding->tx_union).multihop_routing_table_grow).len = len;
    FL_DEBUG("udn TX intermon.multihop_routing_table_grow\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_multihop_intermon_request__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, iref_t iref, intermon_vci_t_t sender_vci, intermon_coreid_t core_id)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_multihop_intermon_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_multihop_intermon_request).iref = iref;
    ((_binding->tx_union).bind_multihop_intermon_request).sender_vci = sender_vci;
    ((_binding->tx_union).bind_multihop_intermon_request).core_id = core_id;
    FL_DEBUG("udn TX intermon.bind_multihop_intermon_request\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bind_multihop_intermon_reply__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_vci_t_t receiver_vci, intermon_vci_t_t sender_vci, intermon_errval_t err)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bind_multihop_intermon_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_multihop_intermon_reply).receiver_vci = receiver_vci;
    ((_binding->tx_union).bind_multihop_intermon_reply).sender_vci = sender_vci;
    ((_binding->tx_union).bind_multihop_intermon_reply).err = err;
    FL_DEBUG("udn TX intermon.bind_multihop_intermon_reply\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_multihop_message__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_vci_t_t vci, uint8_t direction, uint8_t flags, uint32_t ack, const uint8_t *payload, size_t size)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_multihop_message__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).multihop_message).vci = vci;
    ((_binding->tx_union).multihop_message).direction = direction;
    ((_binding->tx_union).multihop_message).flags = flags;
    ((_binding->tx_union).multihop_message).ack = ack;
    ((_binding->tx_union).multihop_message).payload = ((uint8_t *)(payload));
    ((_binding->tx_union).multihop_message).size = size;
    FL_DEBUG("udn TX intermon.multihop_message\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_multihop_cap_send__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_vci_t_t vci, uint8_t direction, intermon_capid_t_t capid, intermon_errval_t err, intermon_caprep_t cap, bool null_cap)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_multihop_cap_send__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).multihop_cap_send).vci = vci;
    ((_binding->tx_union).multihop_cap_send).direction = direction;
    ((_binding->tx_union).multihop_cap_send).capid = capid;
    ((_binding->tx_union).multihop_cap_send).err = err;
    ((_binding->tx_union).multihop_cap_send).cap = cap;
    ((_binding->tx_union).multihop_cap_send).null_cap = null_cap;
    FL_DEBUG("udn TX intermon.multihop_cap_send\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_trace_prepare__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_coreid_t origin_core)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_trace_prepare__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).trace_prepare).origin_core = origin_core;
    FL_DEBUG("udn TX intermon.trace_prepare\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_trace_prepare_finished__udn_send(struct intermon_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_trace_prepare_finished__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("udn TX intermon.trace_prepare_finished\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_trace_measure__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_coreid_t_t origin_core, uint64_t t0)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_trace_measure__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).trace_measure).origin_core = origin_core;
    ((_binding->tx_union).trace_measure).t0 = t0;
    FL_DEBUG("udn TX intermon.trace_measure\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_trace_measure_ack__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, intermon_coreid_t origin_core, uint64_t t0, uint64_t t1, uint64_t t2)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_trace_measure_ack__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).trace_measure_ack).origin_core = origin_core;
    ((_binding->tx_union).trace_measure_ack).t0 = t0;
    ((_binding->tx_union).trace_measure_ack).t1 = t1;
    ((_binding->tx_union).trace_measure_ack).t2 = t2;
    FL_DEBUG("udn TX intermon.trace_measure_ack\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bfscope_flush_send_forward__udn_send(struct intermon_binding *_binding, struct event_closure _continuation, iref_t iref)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bfscope_flush_send_forward__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bfscope_flush_send_forward).iref = iref;
    FL_DEBUG("udn TX intermon.bfscope_flush_send_forward\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t intermon_bfscope_flush_ack_forward__udn_send(struct intermon_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = intermon_bfscope_flush_ack_forward__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("udn TX intermon.bfscope_flush_ack_forward\n");
    
    // try to send!
    intermon_udn_send_handler(_binding);
    
    return(SYS_ERR_OK);
}


/*
 * Send vtable
 */
static  struct intermon_tx_vtbl intermon_udn_tx_vtbl = {
    .spawnd_image_request = intermon_spawnd_image_request__udn_send,
    .spawnd_image_reply = intermon_spawnd_image_reply__udn_send,
    .monitor_initialized = intermon_monitor_initialized__udn_send,
    .trace_caps_request = intermon_trace_caps_request__udn_send,
    .trace_caps_reply = intermon_trace_caps_reply__udn_send,
    .mem_serv_iref_request = intermon_mem_serv_iref_request__udn_send,
    .mem_serv_iref_reply = intermon_mem_serv_iref_reply__udn_send,
    .ramfs_serv_iref_request = intermon_ramfs_serv_iref_request__udn_send,
    .ramfs_serv_iref_reply = intermon_ramfs_serv_iref_reply__udn_send,
    .name_serv_iref_request = intermon_name_serv_iref_request__udn_send,
    .name_serv_iref_reply = intermon_name_serv_iref_reply__udn_send,
    .monitor_mem_iref_request = intermon_monitor_mem_iref_request__udn_send,
    .monitor_mem_iref_reply = intermon_monitor_mem_iref_reply__udn_send,
    .bind_monitor_request = intermon_bind_monitor_request__udn_send,
    .bind_monitor_reply = intermon_bind_monitor_reply__udn_send,
    .bind_monitor_proxy = intermon_bind_monitor_proxy__udn_send,
    .bind_monitor_request_scc = intermon_bind_monitor_request_scc__udn_send,
    .bind_monitor_reply_scc = intermon_bind_monitor_reply_scc__udn_send,
    .bind_monitor_proxy_scc = intermon_bind_monitor_proxy_scc__udn_send,
    .bind_monitor_request_bmp = intermon_bind_monitor_request_bmp__udn_send,
    .bind_monitor_reply_bmp = intermon_bind_monitor_reply_bmp__udn_send,
    .bind_monitor_proxy_bmp = intermon_bind_monitor_proxy_bmp__udn_send,
    .new_monitor_notify = intermon_new_monitor_notify__udn_send,
    .bind_ump_request = intermon_bind_ump_request__udn_send,
    .bind_ump_reply = intermon_bind_ump_reply__udn_send,
    .bind_udn_request = intermon_bind_udn_request__udn_send,
    .bind_udn_reply = intermon_bind_udn_reply__udn_send,
    .cap_send_request = intermon_cap_send_request__udn_send,
    .span_domain_request = intermon_span_domain_request__udn_send,
    .span_domain_reply = intermon_span_domain_reply__udn_send,
    .rsrc_join = intermon_rsrc_join__udn_send,
    .rsrc_join_complete = intermon_rsrc_join_complete__udn_send,
    .rsrc_phase_data = intermon_rsrc_phase_data__udn_send,
    .rsrc_timer_sync = intermon_rsrc_timer_sync__udn_send,
    .rsrc_timer_sync_reply = intermon_rsrc_timer_sync_reply__udn_send,
    .rsrc_phase = intermon_rsrc_phase__udn_send,
    .multihop_routing_table_request = intermon_multihop_routing_table_request__udn_send,
    .multihop_routing_table_response = intermon_multihop_routing_table_response__udn_send,
    .multihop_routing_table_grow = intermon_multihop_routing_table_grow__udn_send,
    .bind_multihop_intermon_request = intermon_bind_multihop_intermon_request__udn_send,
    .bind_multihop_intermon_reply = intermon_bind_multihop_intermon_reply__udn_send,
    .multihop_message = intermon_multihop_message__udn_send,
    .multihop_cap_send = intermon_multihop_cap_send__udn_send,
    .trace_prepare = intermon_trace_prepare__udn_send,
    .trace_prepare_finished = intermon_trace_prepare_finished__udn_send,
    .trace_measure = intermon_trace_measure__udn_send,
    .trace_measure_ack = intermon_trace_measure_ack__udn_send,
    .bfscope_flush_send_forward = intermon_bfscope_flush_send_forward__udn_send,
    .bfscope_flush_ack_forward = intermon_bfscope_flush_ack_forward__udn_send,
};
/*
 * Control functions
 */
static  bool intermon_udn_can_send(struct intermon_binding *b)
{
    return((b->tx_msgnum) == 0);
}

static  errval_t intermon_udn_register_send(struct intermon_binding *b, struct waitset *ws, struct event_closure _continuation)
{
    return(flounder_support_register(ws, &(b->register_chanstate), _continuation, intermon_udn_can_send(b)));
}

static  void intermon_udn_default_error_handler(struct intermon_binding *b, errval_t err)
{
    DEBUG_ERR(err, "asynchronous error in Flounder-generated intermon udn binding (default handler)");
    abort();
}

static  errval_t intermon_udn_change_waitset(struct intermon_binding *_binding, struct waitset *ws)
{
    struct intermon_udn_binding *b = (void *)(_binding);
    errval_t err;
    
    // change waitset on private monitor binding if we have one
    if ((((b->udn_state).chan).monitor_binding) != get_monitor_binding()) {
        err = flounder_support_change_monitor_waitset(((b->udn_state).chan).monitor_binding, ws);
        if (err_is_fail(err)) {
            return(err_push(err, FLOUNDER_ERR_CHANGE_MONITOR_WAITSET));
        }
    }
    
    // change waitset on binding
    _binding->waitset = ws;
    
    // re-register for receive (if previously registered)
    err = udn_chan_deregister_recv(&((b->udn_state).chan));
    if (err_is_fail(err) && (err_no(err) != LIB_ERR_CHAN_NOT_REGISTERED)) {
        return(err_push(err, LIB_ERR_CHAN_DEREGISTER_RECV));
    }
    if (err_is_ok(err)) {
        err = udn_chan_register_recv(&((b->udn_state).chan), _binding->waitset, (struct event_closure){  .handler = intermon_udn_rx_handler,  .arg = _binding });
        if (err_is_fail(err)) {
            return(err_push(err, LIB_ERR_CHAN_REGISTER_RECV));
        }
    }
    return(SYS_ERR_OK);
}

static  errval_t intermon_udn_control(struct intermon_binding *_binding, idc_control_t control)
{
    // no control flags are supported
    return(SYS_ERR_OK);
}


/*
 * Function to destroy the binding state
 */
 void intermon_udn_destroy(struct intermon_udn_binding *b)
{
    flounder_support_waitset_chanstate_destroy(&((b->b).register_chanstate));
    flounder_support_waitset_chanstate_destroy(&((b->b).tx_cont_chanstate));
    udn_chan_destroy(&((b->udn_state).chan));
}


/*
 * Bind function
 */
static  void intermon_udn_bind_continuation(void *st, errval_t err, struct udn_chan *chan, struct capref notify_cap)
{
    struct intermon_binding *_binding = st;
    struct intermon_udn_binding *b = st;
    
    if (err_is_ok(err)) {
        // notify cap ignored
        // setup cap handlers
        (((b->udn_state).chan).cap_handlers).st = b;
        (((b->udn_state).chan).cap_handlers).cap_receive_handler = intermon_udn_cap_rx_handler;
        // register for receive notification
        err = udn_chan_register_recv(&((b->udn_state).chan), _binding->waitset, (struct event_closure){  .handler = intermon_udn_rx_handler,  .arg = _binding });
        if (err_is_fail(err)) {
            (_binding->error_handler)(_binding, err_push(err, LIB_ERR_CHAN_REGISTER_RECV));
        }
    } else {
        intermon_udn_destroy(b);
    }
    
    (_binding->bind_cont)(_binding->st, err, _binding);
}

 errval_t intermon_udn_init(struct intermon_udn_binding *b, struct waitset *waitset, coreid_t dest_core_id, uint32_t out_chan_id, uint8_t dest_asid)
{
    errval_t err;
    struct intermon_binding *_binding = &(b->b);
    (b->b).st = NULL;
    (b->b).waitset = waitset;
    event_mutex_init(&((b->b).mutex), waitset);
    (b->b).can_send = intermon_udn_can_send;
    (b->b).register_send = intermon_udn_register_send;
    (b->b).error_handler = intermon_udn_default_error_handler;
    (b->b).tx_vtbl = intermon_udn_tx_vtbl;
    memset(&((b->b).rx_vtbl), 0, sizeof((b->b).rx_vtbl));
    flounder_support_waitset_chanstate_init(&((b->b).register_chanstate));
    flounder_support_waitset_chanstate_init(&((b->b).tx_cont_chanstate));
    (b->b).tx_msgnum = 0;
    (b->b).rx_msgnum = 0;
    (b->b).tx_msg_fragment = 0;
    (b->b).rx_msg_fragment = 0;
    (b->b).tx_str_pos = 0;
    (b->b).rx_str_pos = 0;
    (b->b).tx_str_len = 0;
    (b->b).rx_str_len = 0;
    (b->b).bind_cont = NULL;
    flounder_stub_udn_state_init(&(b->udn_state), b);
    err = udn_chan_init(&((b->udn_state).chan), dest_core_id, out_chan_id, dest_asid);
    if (err_is_fail(err)) {
        intermon_udn_destroy(b);
        return(err_push(err, LIB_ERR_UDN_CHAN_INIT));
    }
    
    (b->b).change_waitset = intermon_udn_change_waitset;
    (b->b).control = intermon_udn_control;
    // register for receive notification
    err = udn_chan_register_recv(&((b->udn_state).chan), _binding->waitset, (struct event_closure){  .handler = intermon_udn_rx_handler,  .arg = _binding });
    if (err_is_fail(err)) {
        (_binding->error_handler)(_binding, err_push(err, LIB_ERR_CHAN_REGISTER_RECV));
    }
    
    return(err);
}

static  void intermon_udn_new_monitor_binding_continuation(void *st, errval_t err, struct monitor_binding *monitor_binding)
{
    struct intermon_binding *_binding = st;
    struct intermon_udn_binding *b = st;
    
    if (err_is_fail(err)) {
        err = err_push(err, LIB_ERR_MONITOR_CLIENT_BIND);
        goto out;
    }
    
    ((b->udn_state).chan).monitor_binding = monitor_binding;
    // start the bind on the new monitor binding
    err = udn_chan_bind(&((b->udn_state).chan), (struct udn_bind_continuation){  .handler = intermon_udn_bind_continuation,  .st = b }, &(_binding->event_qnode), b->iref, monitor_binding, NULL_CAP);
    
    out:
    if (err_is_fail(err)) {
        (_binding->bind_cont)(_binding->st, err, _binding);
        intermon_udn_destroy(b);
    }
}

 errval_t intermon_udn_bind(struct intermon_udn_binding *b, iref_t iref, intermon_bind_continuation_fn *_continuation, void *st, struct waitset *waitset, idc_bind_flags_t flags)
{
    errval_t err;
    (b->b).st = NULL;
    (b->b).waitset = waitset;
    event_mutex_init(&((b->b).mutex), waitset);
    (b->b).can_send = intermon_udn_can_send;
    (b->b).register_send = intermon_udn_register_send;
    (b->b).error_handler = intermon_udn_default_error_handler;
    (b->b).tx_vtbl = intermon_udn_tx_vtbl;
    memset(&((b->b).rx_vtbl), 0, sizeof((b->b).rx_vtbl));
    flounder_support_waitset_chanstate_init(&((b->b).register_chanstate));
    flounder_support_waitset_chanstate_init(&((b->b).tx_cont_chanstate));
    (b->b).tx_msgnum = 0;
    (b->b).rx_msgnum = 0;
    (b->b).tx_msg_fragment = 0;
    (b->b).rx_msg_fragment = 0;
    (b->b).tx_str_pos = 0;
    (b->b).rx_str_pos = 0;
    (b->b).tx_str_len = 0;
    (b->b).rx_str_len = 0;
    (b->b).bind_cont = NULL;
    flounder_stub_udn_state_init(&(b->udn_state), b);
    (b->b).change_waitset = intermon_udn_change_waitset;
    (b->b).control = intermon_udn_control;
    (b->b).st = st;
    (b->b).bind_cont = _continuation;
    b->iref = iref;
    
    // do we need a new monitor binding?
    if (flags & IDC_BIND_FLAG_RPC_CAP_TRANSFER) {
        err = monitor_client_new_binding(intermon_udn_new_monitor_binding_continuation, b, waitset, DEFAULT_LMP_BUF_WORDS);
    } else {
        err = udn_chan_bind(&((b->udn_state).chan), (struct udn_bind_continuation){  .handler = intermon_udn_bind_continuation,  .st = b }, &((b->b).event_qnode), iref, get_monitor_binding(), NULL_CAP);
    }
    
    if (err_is_fail(err)) {
        intermon_udn_destroy(b);
    }
    return(err);
}


/*
 * Connect callback for export
 */
 errval_t intermon_udn_connect_handler(void *st, struct monitor_binding *mb, uintptr_t mon_id, struct capref notify_cap, coreid_t dest_core_id, uint32_t out_chan_id, uint8_t dest_asid)
{
    struct intermon_export *e = st;
    errval_t err;
    
    // allocate storage for binding
    struct intermon_udn_binding *b = malloc(sizeof(struct intermon_udn_binding ));
    if (b == NULL) {
        return(LIB_ERR_MALLOC_FAIL);
    }
    
    struct intermon_binding *_binding = &(b->b);
    (b->b).st = NULL;
    (b->b).waitset = (e->waitset);
    event_mutex_init(&((b->b).mutex), e->waitset);
    (b->b).can_send = intermon_udn_can_send;
    (b->b).register_send = intermon_udn_register_send;
    (b->b).error_handler = intermon_udn_default_error_handler;
    (b->b).tx_vtbl = intermon_udn_tx_vtbl;
    memset(&((b->b).rx_vtbl), 0, sizeof((b->b).rx_vtbl));
    flounder_support_waitset_chanstate_init(&((b->b).register_chanstate));
    flounder_support_waitset_chanstate_init(&((b->b).tx_cont_chanstate));
    (b->b).tx_msgnum = 0;
    (b->b).rx_msgnum = 0;
    (b->b).tx_msg_fragment = 0;
    (b->b).rx_msg_fragment = 0;
    (b->b).tx_str_pos = 0;
    (b->b).rx_str_pos = 0;
    (b->b).tx_str_len = 0;
    (b->b).rx_str_len = 0;
    (b->b).bind_cont = NULL;
    flounder_stub_udn_state_init(&(b->udn_state), b);
    (b->b).change_waitset = intermon_udn_change_waitset;
    (b->b).control = intermon_udn_control;
    
    // run user's connect handler
    err = ((e->connect_cb)(e->st, _binding));
    if (err_is_fail(err)) {
        // connection refused
        intermon_udn_destroy(b);
        return(err);
    }
    
    // accept the connection and setup the channel
    err = udn_chan_accept(&((b->udn_state).chan), mon_id, dest_core_id, out_chan_id, dest_asid);
    if (err_is_fail(err)) {
        err = err_push(err, LIB_ERR_UDN_CHAN_ACCEPT);
        (_binding->error_handler)(_binding, err);
        return(err);
    }
    
    // notify cap ignored
    // setup cap handlers
    (((b->udn_state).chan).cap_handlers).st = b;
    (((b->udn_state).chan).cap_handlers).cap_receive_handler = intermon_udn_cap_rx_handler;
    
    // register for receive notification
    err = udn_chan_register_recv(&((b->udn_state).chan), _binding->waitset, (struct event_closure){  .handler = intermon_udn_rx_handler,  .arg = _binding });
    if (err_is_fail(err)) {
        (_binding->error_handler)(_binding, err_push(err, LIB_ERR_CHAN_REGISTER_RECV));
    }
    
    // send back bind reply
    udn_chan_send_bind_reply(mb, &((b->udn_state).chan), SYS_ERR_OK, mon_id, NULL_CAP);
    
    return(SYS_ERR_OK);
}

#endif // CONFIG_FLOUNDER_BACKEND_UDN
