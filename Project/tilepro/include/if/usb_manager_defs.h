#ifndef __usb_manager_IF_H
#define __usb_manager_IF_H 1
/*
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * INTERFACE NAME: usb_manager
 * INTEFACE FILE: /home/andreas/barrelfish/new_test2/if/usb_manager.if
 * INTERFACE DESCRIPTION: USB manager
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr.6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY FLOUNDER: DO NOT EDIT!
 */

#include <flounder/flounder.h>

/*
 * Concrete type definitions
 */
typedef uint64_t usb_manager_genpaddr_t;
typedef uint64_t usb_manager_genvaddr_t;
typedef uint32_t usb_manager_rsrcid_t;
typedef uint32_t usb_manager_errval_t;
typedef uint32_t usb_manager_cycles_t;
typedef uint32_t usb_manager_iref_t;
typedef uint8_t usb_manager_coreid_t;
typedef uint32_t usb_manager_domainid_t;
struct _usb_manager_pipe__struct {
    uint8_t dev;
    uint8_t ep_number;
    uint8_t ep_address;
    uint8_t ep_dir;
    uint8_t ep_type;
    uint16_t ep_psz;
    uint8_t multi;
    int32_t valid;
};
typedef struct _usb_manager_pipe__struct usb_manager_pipe_t;
struct _usb_manager_usb_config__struct {
    uint8_t bLength;
    uint8_t bDescriptorType;
    uint16_t wTotalLength;
    uint8_t bNumInterfaces;
    uint8_t bConfigurationValue;
    uint8_t iConfiguration;
    uint8_t bmAttributes;
    uint8_t bMaxPower;
};
typedef struct _usb_manager_usb_config__struct usb_manager_usb_config_t;
struct _usb_manager_usb_intf__struct {
    uint8_t bLength;
    uint8_t bDescriptorType;
    uint8_t bInterfaceNumber;
    uint8_t bAlternateSetting;
    uint8_t bNumEndpoints;
    uint8_t bInterfaceClass;
    uint8_t bInterfaceSubClass;
    uint8_t bInterfaceProtocol;
    uint8_t iInterface;
};
typedef struct _usb_manager_usb_intf__struct usb_manager_usb_intf_t;

/*
 * Forward declaration of binding type
 */
struct usb_manager_binding;

/*
 * Contination (callback) and control function types
 */
typedef  void usb_manager_bind_continuation_fn(void *st, errval_t err, struct usb_manager_binding *_binding);
typedef  bool usb_manager_can_send_fn(struct usb_manager_binding *_binding);
typedef  errval_t usb_manager_register_send_fn(struct usb_manager_binding *_binding, struct waitset *ws, struct event_closure _continuation);
typedef  errval_t usb_manager_change_waitset_fn(struct usb_manager_binding *_binding, struct waitset *ws);
typedef  errval_t usb_manager_control_fn(struct usb_manager_binding *_binding, idc_control_t control);
typedef  void usb_manager_error_handler_fn(struct usb_manager_binding *_binding, errval_t err);

/*
 * Enumeration for message numbers
 */
typedef enum usb_manager_msg_enum {
    usb_manager___dummy__msgnum = 0,
    usb_manager_device_connect__msgnum = 1,
    usb_manager_notify_conn__msgnum = 2,
    usb_manager_device_disconnect__msgnum = 3,
    usb_manager_notify_disconn__msgnum = 4,
    usb_manager_pipe_req__msgnum = 5,
    usb_manager_pipe_resp__msgnum = 6,
    usb_manager_get_curr_config__msgnum = 7,
    usb_manager_get_curr_config_resp__msgnum = 8,
    usb_manager_get_num_config__msgnum = 9,
    usb_manager_get_num_config_resp__msgnum = 10,
    usb_manager_get_config__msgnum = 11,
    usb_manager_get_config_resp__msgnum = 12,
    usb_manager_set_config__msgnum = 13,
    usb_manager_set_config_resp__msgnum = 14,
    usb_manager_get_curr_intf__msgnum = 15,
    usb_manager_get_curr_intf_resp__msgnum = 16,
    usb_manager_get_num_intf__msgnum = 17,
    usb_manager_get_num_intf_resp__msgnum = 18,
    usb_manager_get_intf__msgnum = 19,
    usb_manager_get_intf_resp__msgnum = 20,
    usb_manager_set_intf__msgnum = 21,
    usb_manager_set_intf_resp__msgnum = 22
} usb_manager_msg_enum;

/*
 * Message type signatures (transmit)
 */
typedef  errval_t usb_manager_device_connect__tx_method_fn(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t port);
typedef  errval_t usb_manager_notify_conn__tx_method_fn(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t resp);
typedef  errval_t usb_manager_device_disconnect__tx_method_fn(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t port);
typedef  errval_t usb_manager_notify_disconn__tx_method_fn(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t ret);
typedef  errval_t usb_manager_pipe_req__tx_method_fn(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev, uint8_t type, uint8_t dir);
typedef  errval_t usb_manager_pipe_resp__tx_method_fn(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t resp, usb_manager_pipe_t p);
typedef  errval_t usb_manager_get_curr_config__tx_method_fn(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev);
typedef  errval_t usb_manager_get_curr_config_resp__tx_method_fn(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t status, usb_manager_usb_config_t config);
typedef  errval_t usb_manager_get_num_config__tx_method_fn(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev);
typedef  errval_t usb_manager_get_num_config_resp__tx_method_fn(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t num);
typedef  errval_t usb_manager_get_config__tx_method_fn(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev, uint8_t num);
typedef  errval_t usb_manager_get_config_resp__tx_method_fn(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t status, usb_manager_usb_config_t config);
typedef  errval_t usb_manager_set_config__tx_method_fn(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev, uint8_t num);
typedef  errval_t usb_manager_set_config_resp__tx_method_fn(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t status);
typedef  errval_t usb_manager_get_curr_intf__tx_method_fn(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev);
typedef  errval_t usb_manager_get_curr_intf_resp__tx_method_fn(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t status, usb_manager_usb_intf_t intf);
typedef  errval_t usb_manager_get_num_intf__tx_method_fn(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev);
typedef  errval_t usb_manager_get_num_intf_resp__tx_method_fn(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t num);
typedef  errval_t usb_manager_get_intf__tx_method_fn(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev, uint8_t num);
typedef  errval_t usb_manager_get_intf_resp__tx_method_fn(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t status, usb_manager_usb_intf_t intf);
typedef  errval_t usb_manager_set_intf__tx_method_fn(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev, uint8_t num);
typedef  errval_t usb_manager_set_intf_resp__tx_method_fn(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t status);

/*
 * Message type signatures (receive)
 */
typedef  void usb_manager_device_connect__rx_method_fn(struct usb_manager_binding *_binding, int32_t port);
typedef  void usb_manager_notify_conn__rx_method_fn(struct usb_manager_binding *_binding, int32_t resp);
typedef  void usb_manager_device_disconnect__rx_method_fn(struct usb_manager_binding *_binding, int32_t port);
typedef  void usb_manager_notify_disconn__rx_method_fn(struct usb_manager_binding *_binding, int32_t ret);
typedef  void usb_manager_pipe_req__rx_method_fn(struct usb_manager_binding *_binding, uint8_t dev, uint8_t type, uint8_t dir);
typedef  void usb_manager_pipe_resp__rx_method_fn(struct usb_manager_binding *_binding, uint8_t resp, usb_manager_pipe_t p);
typedef  void usb_manager_get_curr_config__rx_method_fn(struct usb_manager_binding *_binding, uint8_t dev);
typedef  void usb_manager_get_curr_config_resp__rx_method_fn(struct usb_manager_binding *_binding, int32_t status, usb_manager_usb_config_t config);
typedef  void usb_manager_get_num_config__rx_method_fn(struct usb_manager_binding *_binding, uint8_t dev);
typedef  void usb_manager_get_num_config_resp__rx_method_fn(struct usb_manager_binding *_binding, uint8_t num);
typedef  void usb_manager_get_config__rx_method_fn(struct usb_manager_binding *_binding, uint8_t dev, uint8_t num);
typedef  void usb_manager_get_config_resp__rx_method_fn(struct usb_manager_binding *_binding, int32_t status, usb_manager_usb_config_t config);
typedef  void usb_manager_set_config__rx_method_fn(struct usb_manager_binding *_binding, uint8_t dev, uint8_t num);
typedef  void usb_manager_set_config_resp__rx_method_fn(struct usb_manager_binding *_binding, int32_t status);
typedef  void usb_manager_get_curr_intf__rx_method_fn(struct usb_manager_binding *_binding, uint8_t dev);
typedef  void usb_manager_get_curr_intf_resp__rx_method_fn(struct usb_manager_binding *_binding, int32_t status, usb_manager_usb_intf_t intf);
typedef  void usb_manager_get_num_intf__rx_method_fn(struct usb_manager_binding *_binding, uint8_t dev);
typedef  void usb_manager_get_num_intf_resp__rx_method_fn(struct usb_manager_binding *_binding, uint8_t num);
typedef  void usb_manager_get_intf__rx_method_fn(struct usb_manager_binding *_binding, uint8_t dev, uint8_t num);
typedef  void usb_manager_get_intf_resp__rx_method_fn(struct usb_manager_binding *_binding, int32_t status, usb_manager_usb_intf_t intf);
typedef  void usb_manager_set_intf__rx_method_fn(struct usb_manager_binding *_binding, uint8_t dev, uint8_t num);
typedef  void usb_manager_set_intf_resp__rx_method_fn(struct usb_manager_binding *_binding, int32_t status);

/*
 * Struct type for holding the args for each msg
 */
struct usb_manager_device_connect__args {
    int32_t port;
};
struct usb_manager_notify_conn__args {
    int32_t resp;
};
struct usb_manager_device_disconnect__args {
    int32_t port;
};
struct usb_manager_notify_disconn__args {
    int32_t ret;
};
struct usb_manager_pipe_req__args {
    uint8_t dev;
    uint8_t type;
    uint8_t dir;
};
struct usb_manager_pipe_resp__args {
    uint8_t resp;
    usb_manager_pipe_t p;
};
struct usb_manager_get_curr_config__args {
    uint8_t dev;
};
struct usb_manager_get_curr_config_resp__args {
    int32_t status;
    usb_manager_usb_config_t config;
};
struct usb_manager_get_num_config__args {
    uint8_t dev;
};
struct usb_manager_get_num_config_resp__args {
    uint8_t num;
};
struct usb_manager_get_config__args {
    uint8_t dev;
    uint8_t num;
};
struct usb_manager_get_config_resp__args {
    int32_t status;
    usb_manager_usb_config_t config;
};
struct usb_manager_set_config__args {
    uint8_t dev;
    uint8_t num;
};
struct usb_manager_set_config_resp__args {
    int32_t status;
};
struct usb_manager_get_curr_intf__args {
    uint8_t dev;
};
struct usb_manager_get_curr_intf_resp__args {
    int32_t status;
    usb_manager_usb_intf_t intf;
};
struct usb_manager_get_num_intf__args {
    uint8_t dev;
};
struct usb_manager_get_num_intf_resp__args {
    uint8_t num;
};
struct usb_manager_get_intf__args {
    uint8_t dev;
    uint8_t num;
};
struct usb_manager_get_intf_resp__args {
    int32_t status;
    usb_manager_usb_intf_t intf;
};
struct usb_manager_set_intf__args {
    uint8_t dev;
    uint8_t num;
};
struct usb_manager_set_intf_resp__args {
    int32_t status;
};

/*
 * Union type for all message arguments
 */
union usb_manager_arg_union {
    struct usb_manager_device_connect__args device_connect;
    struct usb_manager_notify_conn__args notify_conn;
    struct usb_manager_device_disconnect__args device_disconnect;
    struct usb_manager_notify_disconn__args notify_disconn;
    struct usb_manager_pipe_req__args pipe_req;
    struct usb_manager_pipe_resp__args pipe_resp;
    struct usb_manager_get_curr_config__args get_curr_config;
    struct usb_manager_get_curr_config_resp__args get_curr_config_resp;
    struct usb_manager_get_num_config__args get_num_config;
    struct usb_manager_get_num_config_resp__args get_num_config_resp;
    struct usb_manager_get_config__args get_config;
    struct usb_manager_get_config_resp__args get_config_resp;
    struct usb_manager_set_config__args set_config;
    struct usb_manager_set_config_resp__args set_config_resp;
    struct usb_manager_get_curr_intf__args get_curr_intf;
    struct usb_manager_get_curr_intf_resp__args get_curr_intf_resp;
    struct usb_manager_get_num_intf__args get_num_intf;
    struct usb_manager_get_num_intf_resp__args get_num_intf_resp;
    struct usb_manager_get_intf__args get_intf;
    struct usb_manager_get_intf_resp__args get_intf_resp;
    struct usb_manager_set_intf__args set_intf;
    struct usb_manager_set_intf_resp__args set_intf_resp;
};

/*
 * VTable struct definition for the interface (transmit)
 */
struct usb_manager_tx_vtbl {
    usb_manager_device_connect__tx_method_fn *device_connect;
    usb_manager_notify_conn__tx_method_fn *notify_conn;
    usb_manager_device_disconnect__tx_method_fn *device_disconnect;
    usb_manager_notify_disconn__tx_method_fn *notify_disconn;
    usb_manager_pipe_req__tx_method_fn *pipe_req;
    usb_manager_pipe_resp__tx_method_fn *pipe_resp;
    usb_manager_get_curr_config__tx_method_fn *get_curr_config;
    usb_manager_get_curr_config_resp__tx_method_fn *get_curr_config_resp;
    usb_manager_get_num_config__tx_method_fn *get_num_config;
    usb_manager_get_num_config_resp__tx_method_fn *get_num_config_resp;
    usb_manager_get_config__tx_method_fn *get_config;
    usb_manager_get_config_resp__tx_method_fn *get_config_resp;
    usb_manager_set_config__tx_method_fn *set_config;
    usb_manager_set_config_resp__tx_method_fn *set_config_resp;
    usb_manager_get_curr_intf__tx_method_fn *get_curr_intf;
    usb_manager_get_curr_intf_resp__tx_method_fn *get_curr_intf_resp;
    usb_manager_get_num_intf__tx_method_fn *get_num_intf;
    usb_manager_get_num_intf_resp__tx_method_fn *get_num_intf_resp;
    usb_manager_get_intf__tx_method_fn *get_intf;
    usb_manager_get_intf_resp__tx_method_fn *get_intf_resp;
    usb_manager_set_intf__tx_method_fn *set_intf;
    usb_manager_set_intf_resp__tx_method_fn *set_intf_resp;
};

/*
 * VTable struct definition for the interface (receive)
 */
struct usb_manager_rx_vtbl {
    usb_manager_device_connect__rx_method_fn *device_connect;
    usb_manager_notify_conn__rx_method_fn *notify_conn;
    usb_manager_device_disconnect__rx_method_fn *device_disconnect;
    usb_manager_notify_disconn__rx_method_fn *notify_disconn;
    usb_manager_pipe_req__rx_method_fn *pipe_req;
    usb_manager_pipe_resp__rx_method_fn *pipe_resp;
    usb_manager_get_curr_config__rx_method_fn *get_curr_config;
    usb_manager_get_curr_config_resp__rx_method_fn *get_curr_config_resp;
    usb_manager_get_num_config__rx_method_fn *get_num_config;
    usb_manager_get_num_config_resp__rx_method_fn *get_num_config_resp;
    usb_manager_get_config__rx_method_fn *get_config;
    usb_manager_get_config_resp__rx_method_fn *get_config_resp;
    usb_manager_set_config__rx_method_fn *set_config;
    usb_manager_set_config_resp__rx_method_fn *set_config_resp;
    usb_manager_get_curr_intf__rx_method_fn *get_curr_intf;
    usb_manager_get_curr_intf_resp__rx_method_fn *get_curr_intf_resp;
    usb_manager_get_num_intf__rx_method_fn *get_num_intf;
    usb_manager_get_num_intf_resp__rx_method_fn *get_num_intf_resp;
    usb_manager_get_intf__rx_method_fn *get_intf;
    usb_manager_get_intf_resp__rx_method_fn *get_intf_resp;
    usb_manager_set_intf__rx_method_fn *set_intf;
    usb_manager_set_intf_resp__rx_method_fn *set_intf_resp;
};

/*
 * Incoming connect callback type
 */
typedef  errval_t usb_manager_connect_fn(void *st, struct usb_manager_binding *binding);

/*
 * Export state struct
 */
struct usb_manager_export {
    struct idc_export common;
    usb_manager_connect_fn *connect_cb;
    struct waitset *waitset;
    void *st;
};

/*
 * Export function
 */
extern  errval_t usb_manager_export(void *st, idc_export_callback_fn *export_cb, usb_manager_connect_fn *connect_cb, struct waitset *ws, idc_export_flags_t flags);

/*
 * The Binding structure
 */
struct usb_manager_binding {
    /* Arbitrary user state pointer */
    void *st;
    
    /* Waitset used for receive handlers and send continuations */
    struct waitset *waitset;
    
    /* Mutex for the use of user code. */
    /* Must be held before any operation where there is a possibility of */
    /* concurrent access to the same binding (eg. multiple threads, or */
    /* asynchronous event handlers that use the same binding object). */
    struct event_mutex mutex;
    
    /* returns true iff a message could currently be accepted by the binding */
    usb_manager_can_send_fn *can_send;
    
    /* register an event for when a message is likely to be able to be sent */
    usb_manager_register_send_fn *register_send;
    
    /* change the waitset used by a binding */
    usb_manager_change_waitset_fn *change_waitset;
    
    /* perform control operations */
    usb_manager_control_fn *control;
    
    /* error handler for any async errors associated with this binding */
    /* must be filled-in by user */
    usb_manager_error_handler_fn *error_handler;
    
    /* Message send functions (filled in by binding) */
    struct usb_manager_tx_vtbl tx_vtbl;
    
    /* Incoming message handlers (filled in by user) */
    struct usb_manager_rx_vtbl rx_vtbl;
    
    /* Private state belonging to the binding implementation */
    union usb_manager_arg_union tx_union;
    union usb_manager_arg_union rx_union;
    struct waitset_chanstate register_chanstate;
    struct waitset_chanstate tx_cont_chanstate;
    enum usb_manager_msg_enum tx_msgnum;
    enum usb_manager_msg_enum rx_msgnum;
    int tx_msg_fragment;
    int rx_msg_fragment;
    size_t tx_str_pos;
    size_t rx_str_pos;
    size_t tx_str_len;
    size_t rx_str_len;
    struct event_queue_node event_qnode;
    usb_manager_bind_continuation_fn *bind_cont;
};

/*
 * Generic bind function
 */
extern  errval_t usb_manager_bind(iref_t i, usb_manager_bind_continuation_fn *_continuation, void *st, struct waitset *waitset, idc_bind_flags_t flags);

/*
 * Send wrappers
 */
static inline errval_t usb_manager_device_connect__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t port) __attribute__ ((always_inline));
static inline errval_t usb_manager_device_connect__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t port)
{
    return(((_binding->tx_vtbl).device_connect)(_binding, _continuation, port));
}

static inline errval_t usb_manager_notify_conn__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t resp) __attribute__ ((always_inline));
static inline errval_t usb_manager_notify_conn__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t resp)
{
    return(((_binding->tx_vtbl).notify_conn)(_binding, _continuation, resp));
}

static inline errval_t usb_manager_device_disconnect__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t port) __attribute__ ((always_inline));
static inline errval_t usb_manager_device_disconnect__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t port)
{
    return(((_binding->tx_vtbl).device_disconnect)(_binding, _continuation, port));
}

static inline errval_t usb_manager_notify_disconn__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t ret) __attribute__ ((always_inline));
static inline errval_t usb_manager_notify_disconn__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t ret)
{
    return(((_binding->tx_vtbl).notify_disconn)(_binding, _continuation, ret));
}

static inline errval_t usb_manager_pipe_req__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev, uint8_t type, uint8_t dir) __attribute__ ((always_inline));
static inline errval_t usb_manager_pipe_req__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev, uint8_t type, uint8_t dir)
{
    return(((_binding->tx_vtbl).pipe_req)(_binding, _continuation, dev, type, dir));
}

static inline errval_t usb_manager_pipe_resp__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t resp, usb_manager_pipe_t p) __attribute__ ((always_inline));
static inline errval_t usb_manager_pipe_resp__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t resp, usb_manager_pipe_t p)
{
    return(((_binding->tx_vtbl).pipe_resp)(_binding, _continuation, resp, p));
}

static inline errval_t usb_manager_get_curr_config__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev) __attribute__ ((always_inline));
static inline errval_t usb_manager_get_curr_config__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev)
{
    return(((_binding->tx_vtbl).get_curr_config)(_binding, _continuation, dev));
}

static inline errval_t usb_manager_get_curr_config_resp__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t status, usb_manager_usb_config_t config) __attribute__ ((always_inline));
static inline errval_t usb_manager_get_curr_config_resp__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t status, usb_manager_usb_config_t config)
{
    return(((_binding->tx_vtbl).get_curr_config_resp)(_binding, _continuation, status, config));
}

static inline errval_t usb_manager_get_num_config__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev) __attribute__ ((always_inline));
static inline errval_t usb_manager_get_num_config__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev)
{
    return(((_binding->tx_vtbl).get_num_config)(_binding, _continuation, dev));
}

static inline errval_t usb_manager_get_num_config_resp__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t num) __attribute__ ((always_inline));
static inline errval_t usb_manager_get_num_config_resp__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t num)
{
    return(((_binding->tx_vtbl).get_num_config_resp)(_binding, _continuation, num));
}

static inline errval_t usb_manager_get_config__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev, uint8_t num) __attribute__ ((always_inline));
static inline errval_t usb_manager_get_config__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev, uint8_t num)
{
    return(((_binding->tx_vtbl).get_config)(_binding, _continuation, dev, num));
}

static inline errval_t usb_manager_get_config_resp__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t status, usb_manager_usb_config_t config) __attribute__ ((always_inline));
static inline errval_t usb_manager_get_config_resp__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t status, usb_manager_usb_config_t config)
{
    return(((_binding->tx_vtbl).get_config_resp)(_binding, _continuation, status, config));
}

static inline errval_t usb_manager_set_config__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev, uint8_t num) __attribute__ ((always_inline));
static inline errval_t usb_manager_set_config__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev, uint8_t num)
{
    return(((_binding->tx_vtbl).set_config)(_binding, _continuation, dev, num));
}

static inline errval_t usb_manager_set_config_resp__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t status) __attribute__ ((always_inline));
static inline errval_t usb_manager_set_config_resp__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t status)
{
    return(((_binding->tx_vtbl).set_config_resp)(_binding, _continuation, status));
}

static inline errval_t usb_manager_get_curr_intf__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev) __attribute__ ((always_inline));
static inline errval_t usb_manager_get_curr_intf__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev)
{
    return(((_binding->tx_vtbl).get_curr_intf)(_binding, _continuation, dev));
}

static inline errval_t usb_manager_get_curr_intf_resp__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t status, usb_manager_usb_intf_t intf) __attribute__ ((always_inline));
static inline errval_t usb_manager_get_curr_intf_resp__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t status, usb_manager_usb_intf_t intf)
{
    return(((_binding->tx_vtbl).get_curr_intf_resp)(_binding, _continuation, status, intf));
}

static inline errval_t usb_manager_get_num_intf__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev) __attribute__ ((always_inline));
static inline errval_t usb_manager_get_num_intf__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev)
{
    return(((_binding->tx_vtbl).get_num_intf)(_binding, _continuation, dev));
}

static inline errval_t usb_manager_get_num_intf_resp__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t num) __attribute__ ((always_inline));
static inline errval_t usb_manager_get_num_intf_resp__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t num)
{
    return(((_binding->tx_vtbl).get_num_intf_resp)(_binding, _continuation, num));
}

static inline errval_t usb_manager_get_intf__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev, uint8_t num) __attribute__ ((always_inline));
static inline errval_t usb_manager_get_intf__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev, uint8_t num)
{
    return(((_binding->tx_vtbl).get_intf)(_binding, _continuation, dev, num));
}

static inline errval_t usb_manager_get_intf_resp__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t status, usb_manager_usb_intf_t intf) __attribute__ ((always_inline));
static inline errval_t usb_manager_get_intf_resp__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t status, usb_manager_usb_intf_t intf)
{
    return(((_binding->tx_vtbl).get_intf_resp)(_binding, _continuation, status, intf));
}

static inline errval_t usb_manager_set_intf__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev, uint8_t num) __attribute__ ((always_inline));
static inline errval_t usb_manager_set_intf__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, uint8_t dev, uint8_t num)
{
    return(((_binding->tx_vtbl).set_intf)(_binding, _continuation, dev, num));
}

static inline errval_t usb_manager_set_intf_resp__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t status) __attribute__ ((always_inline));
static inline errval_t usb_manager_set_intf_resp__tx(struct usb_manager_binding *_binding, struct event_closure _continuation, int32_t status)
{
    return(((_binding->tx_vtbl).set_intf_resp)(_binding, _continuation, status));
}


/*
 * Backend-specific includes
 */
#ifdef CONFIG_FLOUNDER_BACKEND_LMP
#include <if/usb_manager_lmp_defs.h>
#endif // CONFIG_FLOUNDER_BACKEND_LMP
#ifdef CONFIG_FLOUNDER_BACKEND_UMP
#include <if/usb_manager_ump_defs.h>
#endif // CONFIG_FLOUNDER_BACKEND_UMP
#ifdef CONFIG_FLOUNDER_BACKEND_UMP_IPI
#include <if/usb_manager_ump_ipi_defs.h>
#endif // CONFIG_FLOUNDER_BACKEND_UMP_IPI
#ifdef CONFIG_FLOUNDER_BACKEND_MULTIHOP
#include <if/usb_manager_multihop_defs.h>
#endif // CONFIG_FLOUNDER_BACKEND_MULTIHOP
#ifdef CONFIG_FLOUNDER_BACKEND_UDN
#include <if/usb_manager_udn_defs.h>
#endif // CONFIG_FLOUNDER_BACKEND_UDN
/*
 * And we're done
 */
#endif // __usb_manager_IF_H
