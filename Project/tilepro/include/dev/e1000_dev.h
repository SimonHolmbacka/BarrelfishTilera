/*
 * DEVICE DEFINITION: Intel e1000 Gigabit Ethernet
 * 
 * Copyright (c) 2007, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich.
 *  Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED: DO NOT EDIT!
 */

#ifndef __e1000_H
#define __e1000_H

#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#undef __DP
#undef __DP1
#undef __DP2
#undef __STR
#undef __XTR
#define __DN(x) e1000 ## _ ## x
#ifdef e1000_PREFIX
#define __DP(x) __DP1(x,e1000_PREFIX)
#define __DP1(x1,x2) __DP2(x1,x2)
#define __DP2(x1,x2) x2 ## x1
#else
#define __DP(x) e1000##_ ##x
#endif
#define __STR(x) #x
#define __XTR(x) __STR(x)

/*
 * Constant definition: e1000.linkspeed (Link speed)
 */
typedef enum e1000_linkspeed_t {
    __DP(mb10) = (0x0),
    __DP(mb100) = (0x1),
    __DP(mb1000) = (0x2),
    __DP(mb_notused) = (0x3),
} e1000_linkspeed_t;

static inline int e1000_linkspeed_prt( char * s, size_t sz, e1000_linkspeed_t e ) __attribute__ ((always_inline));
static inline int e1000_linkspeed_prt( char * s, size_t sz, e1000_linkspeed_t e )
{
    switch (e) {
        case __DP(mb10):
        return snprintf(s, sz, "%s", "10Mb/s");
        case __DP(mb100):
        return snprintf(s, sz, "%s", "100Mb/s");
        case __DP(mb1000):
        return snprintf(s, sz, "%s", "1Gb/s");
        case __DP(mb_notused):
        return snprintf(s, sz, "%s", "1Gb/s");
        default:
        return snprintf(s, sz, "Unknown " __XTR(e1000_linkspeed_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int e1000_linkspeed_chk( e1000_linkspeed_t e ) __attribute__ ((always_inline));
static inline int e1000_linkspeed_chk( e1000_linkspeed_t e )
{
    switch (e) {
        case __DP(mb10):
        return 1;
        case __DP(mb100):
        return 1;
        case __DP(mb1000):
        return 1;
        case __DP(mb_notused):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: e1000.lanid (LAN ID)
 */
typedef enum e1000_lanid_t {
    __DP(lan_a) = (0x0),
    __DP(lan_b) = (0x1),
    __DP(lan_not_u1) = (0x2),
    __DP(lan_not_u2) = (0x3),
} e1000_lanid_t;

static inline int e1000_lanid_prt( char * s, size_t sz, e1000_lanid_t e ) __attribute__ ((always_inline));
static inline int e1000_lanid_prt( char * s, size_t sz, e1000_lanid_t e )
{
    switch (e) {
        case __DP(lan_a):
        return snprintf(s, sz, "%s", "LAN A");
        case __DP(lan_b):
        return snprintf(s, sz, "%s", "LAN B");
        case __DP(lan_not_u1):
        return snprintf(s, sz, "%s", "LAN ID not used");
        case __DP(lan_not_u2):
        return snprintf(s, sz, "%s", "LAN ID not used");
        default:
        return snprintf(s, sz, "Unknown " __XTR(e1000_lanid_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int e1000_lanid_chk( e1000_lanid_t e ) __attribute__ ((always_inline));
static inline int e1000_lanid_chk( e1000_lanid_t e )
{
    switch (e) {
        case __DP(lan_a):
        return 1;
        case __DP(lan_b):
        return 1;
        case __DP(lan_not_u1):
        return 1;
        case __DP(lan_not_u2):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: e1000.mac_mask (LAN MAC MASK)
 */
typedef enum e1000_mac_mask_t {
    __DP(lan_b_mask) = (0x100),
} e1000_mac_mask_t;

static inline int e1000_mac_mask_prt( char * s, size_t sz, e1000_mac_mask_t e ) __attribute__ ((always_inline));
static inline int e1000_mac_mask_prt( char * s, size_t sz, e1000_mac_mask_t e )
{
    switch (e) {
        case __DP(lan_b_mask):
        return snprintf(s, sz, "%s", "LAN B mask");
        default:
        return snprintf(s, sz, "Unknown " __XTR(e1000_mac_mask_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int e1000_mac_mask_chk( e1000_mac_mask_t e ) __attribute__ ((always_inline));
static inline int e1000_mac_mask_chk( e1000_mac_mask_t e )
{
    switch (e) {
        case __DP(lan_b_mask):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: e1000.flashenable (Flash write enable control)
 */
typedef enum e1000_flashenable_t {
    __DP(flash_erase) = (0x0),
    __DP(flash_wr_disable) = (0x1),
    __DP(flash_wr_enable) = (0x2),
} e1000_flashenable_t;

static inline int e1000_flashenable_prt( char * s, size_t sz, e1000_flashenable_t e ) __attribute__ ((always_inline));
static inline int e1000_flashenable_prt( char * s, size_t sz, e1000_flashenable_t e )
{
    switch (e) {
        case __DP(flash_erase):
        return snprintf(s, sz, "%s", "Flash erase");
        case __DP(flash_wr_disable):
        return snprintf(s, sz, "%s", "Flash writes discarded");
        case __DP(flash_wr_enable):
        return snprintf(s, sz, "%s", "Flash writed enabled");
        default:
        return snprintf(s, sz, "Unknown " __XTR(e1000_flashenable_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int e1000_flashenable_chk( e1000_flashenable_t e ) __attribute__ ((always_inline));
static inline int e1000_flashenable_chk( e1000_flashenable_t e )
{
    switch (e) {
        case __DP(flash_erase):
        return 1;
        case __DP(flash_wr_disable):
        return 1;
        case __DP(flash_wr_enable):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: e1000.eeaddrsize (EEPROM address size)
 */
typedef enum e1000_eeaddrsize_t {
    __DP(bits8or9) = (0x0),
    __DP(bits16) = (0x1),
} e1000_eeaddrsize_t;

static inline int e1000_eeaddrsize_prt( char * s, size_t sz, e1000_eeaddrsize_t e ) __attribute__ ((always_inline));
static inline int e1000_eeaddrsize_prt( char * s, size_t sz, e1000_eeaddrsize_t e )
{
    switch (e) {
        case __DP(bits8or9):
        return snprintf(s, sz, "%s", "8- and 9-bit");
        case __DP(bits16):
        return snprintf(s, sz, "%s", "16-bit");
        default:
        return snprintf(s, sz, "Unknown " __XTR(e1000_eeaddrsize_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int e1000_eeaddrsize_chk( e1000_eeaddrsize_t e ) __attribute__ ((always_inline));
static inline int e1000_eeaddrsize_chk( e1000_eeaddrsize_t e )
{
    switch (e) {
        case __DP(bits8or9):
        return 1;
        case __DP(bits16):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: e1000.nvmtype (Non-volatile memory type)
 */
typedef enum e1000_nvmtype_t {
    __DP(eeprom) = (0x0),
    __DP(saflash) = (0x1),
    __DP(spiflash) = (0x2),
    __DP(sio) = (0x3),
} e1000_nvmtype_t;

static inline int e1000_nvmtype_prt( char * s, size_t sz, e1000_nvmtype_t e ) __attribute__ ((always_inline));
static inline int e1000_nvmtype_prt( char * s, size_t sz, e1000_nvmtype_t e )
{
    switch (e) {
        case __DP(eeprom):
        return snprintf(s, sz, "%s", "EEPROM");
        case __DP(saflash):
        return snprintf(s, sz, "%s", "Stand-alone Flash");
        case __DP(spiflash):
        return snprintf(s, sz, "%s", "Shared SPI Flash");
        case __DP(sio):
        return snprintf(s, sz, "%s", "SIO");
        default:
        return snprintf(s, sz, "Unknown " __XTR(e1000_nvmtype_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int e1000_nvmtype_chk( e1000_nvmtype_t e ) __attribute__ ((always_inline));
static inline int e1000_nvmtype_chk( e1000_nvmtype_t e )
{
    switch (e) {
        case __DP(eeprom):
        return 1;
        case __DP(saflash):
        return 1;
        case __DP(spiflash):
        return 1;
        case __DP(sio):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: e1000.linkmode (Link mode)
 */
typedef enum e1000_linkmode_t {
    __DP(glci) = (0x0),
    __DP(l82573) = (0x2),
    __DP(serdes) = (0x3),
} e1000_linkmode_t;

static inline int e1000_linkmode_prt( char * s, size_t sz, e1000_linkmode_t e ) __attribute__ ((always_inline));
static inline int e1000_linkmode_prt( char * s, size_t sz, e1000_linkmode_t e )
{
    switch (e) {
        case __DP(glci):
        return snprintf(s, sz, "%s", "Direct coper or GLCI");
        case __DP(l82573):
        return snprintf(s, sz, "%s", "Must be set for 82573E/V/L");
        case __DP(serdes):
        return snprintf(s, sz, "%s", "Internal SerDes (TBI) or SerDes mode");
        default:
        return snprintf(s, sz, "Unknown " __XTR(e1000_linkmode_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int e1000_linkmode_chk( e1000_linkmode_t e ) __attribute__ ((always_inline));
static inline int e1000_linkmode_chk( e1000_linkmode_t e )
{
    switch (e) {
        case __DP(glci):
        return 1;
        case __DP(l82573):
        return 1;
        case __DP(serdes):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: e1000.phyop (PHY register opcode)
 */
typedef enum e1000_phyop_t {
    __DP(mdi_write) = (0x1),
    __DP(mdi_read) = (0x2),
} e1000_phyop_t;

static inline int e1000_phyop_prt( char * s, size_t sz, e1000_phyop_t e ) __attribute__ ((always_inline));
static inline int e1000_phyop_prt( char * s, size_t sz, e1000_phyop_t e )
{
    switch (e) {
        case __DP(mdi_write):
        return snprintf(s, sz, "%s", "MDI Write");
        case __DP(mdi_read):
        return snprintf(s, sz, "%s", "MDI Read");
        default:
        return snprintf(s, sz, "Unknown " __XTR(e1000_phyop_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int e1000_phyop_chk( e1000_phyop_t e ) __attribute__ ((always_inline));
static inline int e1000_phyop_chk( e1000_phyop_t e )
{
    switch (e) {
        case __DP(mdi_write):
        return 1;
        case __DP(mdi_read):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: e1000.fca (Flow control address)
 */
typedef enum e1000_fca_t {
    __DP(fca_lo) = (0xc28001),
    __DP(fca_hi) = (0x100),
} e1000_fca_t;

static inline int e1000_fca_prt( char * s, size_t sz, e1000_fca_t e ) __attribute__ ((always_inline));
static inline int e1000_fca_prt( char * s, size_t sz, e1000_fca_t e )
{
    switch (e) {
        case __DP(fca_lo):
        return snprintf(s, sz, "%s", "fca_lo");
        case __DP(fca_hi):
        return snprintf(s, sz, "%s", "fca_hi");
        default:
        return snprintf(s, sz, "Unknown " __XTR(e1000_fca_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int e1000_fca_chk( e1000_fca_t e ) __attribute__ ((always_inline));
static inline int e1000_fca_chk( e1000_fca_t e )
{
    switch (e) {
        case __DP(fca_lo):
        return 1;
        case __DP(fca_hi):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: e1000.fctval (Flow control type)
 */
typedef enum e1000_fctval_t {
    __DP(fct_val) = (0x8808),
} e1000_fctval_t;

static inline int e1000_fctval_prt( char * s, size_t sz, e1000_fctval_t e ) __attribute__ ((always_inline));
static inline int e1000_fctval_prt( char * s, size_t sz, e1000_fctval_t e )
{
    switch (e) {
        case __DP(fct_val):
        return snprintf(s, sz, "%s", "fct_val");
        default:
        return snprintf(s, sz, "Unknown " __XTR(e1000_fctval_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int e1000_fctval_chk( e1000_fctval_t e ) __attribute__ ((always_inline));
static inline int e1000_fctval_chk( e1000_fctval_t e )
{
    switch (e) {
        case __DP(fct_val):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: e1000.vet_val (VLAN ether type value)
 */
typedef enum e1000_vet_val_t {
    __DP(vlan_type) = (0x8100),
} e1000_vet_val_t;

static inline int e1000_vet_val_prt( char * s, size_t sz, e1000_vet_val_t e ) __attribute__ ((always_inline));
static inline int e1000_vet_val_prt( char * s, size_t sz, e1000_vet_val_t e )
{
    switch (e) {
        case __DP(vlan_type):
        return snprintf(s, sz, "%s", "vlan_type");
        default:
        return snprintf(s, sz, "Unknown " __XTR(e1000_vet_val_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int e1000_vet_val_chk( e1000_vet_val_t e ) __attribute__ ((always_inline));
static inline int e1000_vet_val_chk( e1000_vet_val_t e )
{
    switch (e) {
        case __DP(vlan_type):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: e1000.ledmode (LED output mode)
 */
typedef enum e1000_ledmode_t {
    __DP(link_10_100) = (0x0),
    __DP(link_100_1000) = (0x1),
    __DP(link_up) = (0x2),
    __DP(filter_activity) = (0x3),
    __DP(link_activity) = (0x4),
    __DP(link_10) = (0x5),
    __DP(link_100) = (0x6),
    __DP(link_1000) = (0x7),
    __DP(full_duplex) = (0x9),
    __DP(collision) = (0xa),
    __DP(activity) = (0xb),
    __DP(bus_size) = (0xc),
    __DP(paused) = (0xd),
    __DP(led_on) = (0xe),
    __DP(led_off) = (0xf),
} e1000_ledmode_t;

static inline int e1000_ledmode_prt( char * s, size_t sz, e1000_ledmode_t e ) __attribute__ ((always_inline));
static inline int e1000_ledmode_prt( char * s, size_t sz, e1000_ledmode_t e )
{
    switch (e) {
        case __DP(link_10_100):
        return snprintf(s, sz, "%s", "Either 10 or 100 Mbs link established");
        case __DP(link_100_1000):
        return snprintf(s, sz, "%s", "Either 100 or 1000 Mbs link established");
        case __DP(link_up):
        return snprintf(s, sz, "%s", "Any speed link established");
        case __DP(filter_activity):
        return snprintf(s, sz, "%s", "Packets passing MAC filtering");
        case __DP(link_activity):
        return snprintf(s, sz, "%s", "No transmit or receive activity");
        case __DP(link_10):
        return snprintf(s, sz, "%s", "10 Mbs link established");
        case __DP(link_100):
        return snprintf(s, sz, "%s", "100 Mbs link established");
        case __DP(link_1000):
        return snprintf(s, sz, "%s", "1000 Mbs link established");
        case __DP(full_duplex):
        return snprintf(s, sz, "%s", "Link configured for full-duplex");
        case __DP(collision):
        return snprintf(s, sz, "%s", "Collision is observed");
        case __DP(activity):
        return snprintf(s, sz, "%s", "Link established and packets sent or revd");
        case __DP(bus_size):
        return snprintf(s, sz, "%s", "Controller detects 1 PCIe lane conn.");
        case __DP(paused):
        return snprintf(s, sz, "%s", "Transmitter is flow controlled");
        case __DP(led_on):
        return snprintf(s, sz, "%s", "Always on");
        case __DP(led_off):
        return snprintf(s, sz, "%s", "Always off");
        default:
        return snprintf(s, sz, "Unknown " __XTR(e1000_ledmode_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int e1000_ledmode_chk( e1000_ledmode_t e ) __attribute__ ((always_inline));
static inline int e1000_ledmode_chk( e1000_ledmode_t e )
{
    switch (e) {
        case __DP(link_10_100):
        return 1;
        case __DP(link_100_1000):
        return 1;
        case __DP(link_up):
        return 1;
        case __DP(filter_activity):
        return 1;
        case __DP(link_activity):
        return 1;
        case __DP(link_10):
        return 1;
        case __DP(link_100):
        return 1;
        case __DP(link_1000):
        return 1;
        case __DP(full_duplex):
        return 1;
        case __DP(collision):
        return 1;
        case __DP(activity):
        return 1;
        case __DP(bus_size):
        return 1;
        case __DP(paused):
        return 1;
        case __DP(led_on):
        return 1;
        case __DP(led_off):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: e1000.blmode (LED blink mode)
 */
typedef enum e1000_blmode_t {
    __DP(ms200) = (0x0),
    __DP(ms83) = (0x1),
} e1000_blmode_t;

static inline int e1000_blmode_prt( char * s, size_t sz, e1000_blmode_t e ) __attribute__ ((always_inline));
static inline int e1000_blmode_prt( char * s, size_t sz, e1000_blmode_t e )
{
    switch (e) {
        case __DP(ms200):
        return snprintf(s, sz, "%s", "200ms on, 200ms off");
        case __DP(ms83):
        return snprintf(s, sz, "%s", "83ms on, 83 ms off");
        default:
        return snprintf(s, sz, "Unknown " __XTR(e1000_blmode_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int e1000_blmode_chk( e1000_blmode_t e ) __attribute__ ((always_inline));
static inline int e1000_blmode_chk( e1000_blmode_t e )
{
    switch (e) {
        case __DP(ms200):
        return 1;
        case __DP(ms83):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: e1000.lbmode (Loopback mode)
 */
typedef enum e1000_lbmode_t {
    __DP(lb_normal) = (0x0),
    __DP(lb_mac) = (0x1),
} e1000_lbmode_t;

static inline int e1000_lbmode_prt( char * s, size_t sz, e1000_lbmode_t e ) __attribute__ ((always_inline));
static inline int e1000_lbmode_prt( char * s, size_t sz, e1000_lbmode_t e )
{
    switch (e) {
        case __DP(lb_normal):
        return snprintf(s, sz, "%s", "Normal operation");
        case __DP(lb_mac):
        return snprintf(s, sz, "%s", "MAC loopback");
        default:
        return snprintf(s, sz, "Unknown " __XTR(e1000_lbmode_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int e1000_lbmode_chk( e1000_lbmode_t e ) __attribute__ ((always_inline));
static inline int e1000_lbmode_chk( e1000_lbmode_t e )
{
    switch (e) {
        case __DP(lb_normal):
        return 1;
        case __DP(lb_mac):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: e1000.rxthresh (Received desc. threshold size)
 */
typedef enum e1000_rxthresh_t {
    __DP(rdlen_2) = (0x0),
    __DP(rdlen_4) = (0x1),
    __DP(rdlen_8) = (0x2),
} e1000_rxthresh_t;

static inline int e1000_rxthresh_prt( char * s, size_t sz, e1000_rxthresh_t e ) __attribute__ ((always_inline));
static inline int e1000_rxthresh_prt( char * s, size_t sz, e1000_rxthresh_t e )
{
    switch (e) {
        case __DP(rdlen_2):
        return snprintf(s, sz, "%s", "1/2 RDLEN");
        case __DP(rdlen_4):
        return snprintf(s, sz, "%s", "1/4 RDLEN");
        case __DP(rdlen_8):
        return snprintf(s, sz, "%s", "1/8 RDLEN");
        default:
        return snprintf(s, sz, "Unknown " __XTR(e1000_rxthresh_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int e1000_rxthresh_chk( e1000_rxthresh_t e ) __attribute__ ((always_inline));
static inline int e1000_rxthresh_chk( e1000_rxthresh_t e )
{
    switch (e) {
        case __DP(rdlen_2):
        return 1;
        case __DP(rdlen_4):
        return 1;
        case __DP(rdlen_8):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: e1000.dtype (Descriptor type)
 */
typedef enum e1000_dtype_t {
    __DP(dt_legacy) = (0x0),
    __DP(dt_split) = (0x1),
} e1000_dtype_t;

static inline int e1000_dtype_prt( char * s, size_t sz, e1000_dtype_t e ) __attribute__ ((always_inline));
static inline int e1000_dtype_prt( char * s, size_t sz, e1000_dtype_t e )
{
    switch (e) {
        case __DP(dt_legacy):
        return snprintf(s, sz, "%s", "Legacy descriptor type");
        case __DP(dt_split):
        return snprintf(s, sz, "%s", "Packet split descriptor type");
        default:
        return snprintf(s, sz, "Unknown " __XTR(e1000_dtype_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int e1000_dtype_chk( e1000_dtype_t e ) __attribute__ ((always_inline));
static inline int e1000_dtype_chk( e1000_dtype_t e )
{
    switch (e) {
        case __DP(dt_legacy):
        return 1;
        case __DP(dt_split):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: e1000.rxbsize (Receive buffer size)
 */
typedef enum e1000_rxbsize_t {
    __DP(rxb2048) = (0x0),
    __DP(rxb1024) = (0x1),
    __DP(rxb512) = (0x2),
    __DP(rxb256) = (0x3),
} e1000_rxbsize_t;

static inline int e1000_rxbsize_prt( char * s, size_t sz, e1000_rxbsize_t e ) __attribute__ ((always_inline));
static inline int e1000_rxbsize_prt( char * s, size_t sz, e1000_rxbsize_t e )
{
    switch (e) {
        case __DP(rxb2048):
        return snprintf(s, sz, "%s", "2048 bytes");
        case __DP(rxb1024):
        return snprintf(s, sz, "%s", "1024 or 16384 bytes");
        case __DP(rxb512):
        return snprintf(s, sz, "%s", "512 or 8192 bytes");
        case __DP(rxb256):
        return snprintf(s, sz, "%s", "256 or 4096 bytes");
        default:
        return snprintf(s, sz, "Unknown " __XTR(e1000_rxbsize_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int e1000_rxbsize_chk( e1000_rxbsize_t e ) __attribute__ ((always_inline));
static inline int e1000_rxbsize_chk( e1000_rxbsize_t e )
{
    switch (e) {
        case __DP(rxb2048):
        return 1;
        case __DP(rxb1024):
        return 1;
        case __DP(rxb512):
        return 1;
        case __DP(rxb256):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: e1000.threshgran (Threshold granularity)
 */
typedef enum e1000_threshgran_t {
    __DP(gran_cache) = (0x0),
    __DP(gran_desc) = (0x1),
} e1000_threshgran_t;

static inline int e1000_threshgran_prt( char * s, size_t sz, e1000_threshgran_t e ) __attribute__ ((always_inline));
static inline int e1000_threshgran_prt( char * s, size_t sz, e1000_threshgran_t e )
{
    switch (e) {
        case __DP(gran_cache):
        return snprintf(s, sz, "%s", "Cache line granularity");
        case __DP(gran_desc):
        return snprintf(s, sz, "%s", "Descriptor granularity");
        default:
        return snprintf(s, sz, "Unknown " __XTR(e1000_threshgran_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int e1000_threshgran_chk( e1000_threshgran_t e ) __attribute__ ((always_inline));
static inline int e1000_threshgran_chk( e1000_threshgran_t e )
{
    switch (e) {
        case __DP(gran_cache):
        return 1;
        case __DP(gran_desc):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: e1000.coldist (Recommended collision distances)
 */
typedef enum e1000_coldist_t {
    __DP(cd_half) = (0x200),
    __DP(cd_full) = (0x3f),
    __DP(cd_esb) = (0x40),
} e1000_coldist_t;

static inline int e1000_coldist_prt( char * s, size_t sz, e1000_coldist_t e ) __attribute__ ((always_inline));
static inline int e1000_coldist_prt( char * s, size_t sz, e1000_coldist_t e )
{
    switch (e) {
        case __DP(cd_half):
        return snprintf(s, sz, "%s", "512 byte-times");
        case __DP(cd_full):
        return snprintf(s, sz, "%s", "64 byte-times");
        case __DP(cd_esb):
        return snprintf(s, sz, "%s", "64 byte-times (for 631xESB/632xESB)");
        default:
        return snprintf(s, sz, "Unknown " __XTR(e1000_coldist_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int e1000_coldist_chk( e1000_coldist_t e ) __attribute__ ((always_inline));
static inline int e1000_coldist_chk( e1000_coldist_t e )
{
    switch (e) {
        case __DP(cd_half):
        return 1;
        case __DP(cd_full):
        return 1;
        case __DP(cd_esb):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: e1000.addrsel (Address select)
 */
typedef enum e1000_addrsel_t {
    __DP(as_dest) = (0x0),
    __DP(as_src) = (0x1),
} e1000_addrsel_t;

static inline int e1000_addrsel_prt( char * s, size_t sz, e1000_addrsel_t e ) __attribute__ ((always_inline));
static inline int e1000_addrsel_prt( char * s, size_t sz, e1000_addrsel_t e )
{
    switch (e) {
        case __DP(as_dest):
        return snprintf(s, sz, "%s", "Destination");
        case __DP(as_src):
        return snprintf(s, sz, "%s", "Source");
        default:
        return snprintf(s, sz, "Unknown " __XTR(e1000_addrsel_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int e1000_addrsel_chk( e1000_addrsel_t e ) __attribute__ ((always_inline));
static inline int e1000_addrsel_chk( e1000_addrsel_t e )
{
    switch (e) {
        case __DP(as_dest):
        return 1;
        case __DP(as_src):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: e1000.mrqen (Multiple rx queue enable)
 */
typedef enum e1000_mrqen_t {
    __DP(mrq_dis) = (0x0),
    __DP(mrq_rss) = (0x1),
} e1000_mrqen_t;

static inline int e1000_mrqen_prt( char * s, size_t sz, e1000_mrqen_t e ) __attribute__ ((always_inline));
static inline int e1000_mrqen_prt( char * s, size_t sz, e1000_mrqen_t e )
{
    switch (e) {
        case __DP(mrq_dis):
        return snprintf(s, sz, "%s", "Multiple queues disabled");
        case __DP(mrq_rss):
        return snprintf(s, sz, "%s", "Multiple queues enabled by MSFT RSS");
        default:
        return snprintf(s, sz, "Unknown " __XTR(e1000_mrqen_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int e1000_mrqen_chk( e1000_mrqen_t e ) __attribute__ ((always_inline));
static inline int e1000_mrqen_chk( e1000_mrqen_t e )
{
    switch (e) {
        case __DP(mrq_dis):
        return 1;
        case __DP(mrq_rss):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: e1000.fps (Function power state)
 */
typedef enum e1000_fps_t {
    __DP(fps_dr) = (0x0),
    __DP(fps_d0u) = (0x1),
    __DP(fps_d0a) = (0x2),
    __DP(fps_d3) = (0x3),
} e1000_fps_t;

static inline int e1000_fps_prt( char * s, size_t sz, e1000_fps_t e ) __attribute__ ((always_inline));
static inline int e1000_fps_prt( char * s, size_t sz, e1000_fps_t e )
{
    switch (e) {
        case __DP(fps_dr):
        return snprintf(s, sz, "%s", "DR");
        case __DP(fps_d0u):
        return snprintf(s, sz, "%s", "D0u");
        case __DP(fps_d0a):
        return snprintf(s, sz, "%s", "Doa");
        case __DP(fps_d3):
        return snprintf(s, sz, "%s", "D3");
        default:
        return snprintf(s, sz, "Unknown " __XTR(e1000_fps_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int e1000_fps_chk( e1000_fps_t e ) __attribute__ ((always_inline));
static inline int e1000_fps_chk( e1000_fps_t e )
{
    switch (e) {
        case __DP(fps_dr):
        return 1;
        case __DP(fps_d0u):
        return 1;
        case __DP(fps_d0a):
        return 1;
        case __DP(fps_d3):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: e1000.fwmode (Firmware mode)
 */
typedef enum e1000_fwmode_t {
    __DP(nomng) = (0x0),
    __DP(ptmode) = (0x2),
    __DP(hieo) = (0x4),
} e1000_fwmode_t;

static inline int e1000_fwmode_prt( char * s, size_t sz, e1000_fwmode_t e ) __attribute__ ((always_inline));
static inline int e1000_fwmode_prt( char * s, size_t sz, e1000_fwmode_t e )
{
    switch (e) {
        case __DP(nomng):
        return snprintf(s, sz, "%s", "No MNG");
        case __DP(ptmode):
        return snprintf(s, sz, "%s", "PT mode");
        case __DP(hieo):
        return snprintf(s, sz, "%s", "Host interface firmware");
        default:
        return snprintf(s, sz, "Unknown " __XTR(e1000_fwmode_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int e1000_fwmode_chk( e1000_fwmode_t e ) __attribute__ ((always_inline));
static inline int e1000_fwmode_chk( e1000_fwmode_t e )
{
    switch (e) {
        case __DP(nomng):
        return 1;
        case __DP(ptmode):
        return 1;
        case __DP(hieo):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: e1000.pcierr (PCIe external error indication)
 */
typedef enum e1000_pcierr_t {
    __DP(pe_none) = (0x0),
    __DP(pe_mschk) = (0x1),
    __DP(pe_prot) = (0x2),
    __DP(pe_clkoff) = (0x3),
    __DP(pe_flchk) = (0x4),
    __DP(pe_pschk) = (0x5),
    __DP(pe_lschk) = (0x6),
    __DP(pe_dschk) = (0x7),
    __DP(pe_inval) = (0x8),
    __DP(pe_tlbe) = (0x9),
    __DP(pe_eerd) = (0xa),
    __DP(pe_hwver) = (0xb),
    __DP(pe_sfrd) = (0xc),
    __DP(pe_unspec) = (0xd),
    __DP(pe_auth) = (0xe),
    __DP(pe_pfrd) = (0xf),
    __DP(pe_ifep) = (0x10),
} e1000_pcierr_t;

static inline int e1000_pcierr_prt( char * s, size_t sz, e1000_pcierr_t e ) __attribute__ ((always_inline));
static inline int e1000_pcierr_prt( char * s, size_t sz, e1000_pcierr_t e )
{
    switch (e) {
        case __DP(pe_none):
        return snprintf(s, sz, "%s", "No error");
        case __DP(pe_mschk):
        return snprintf(s, sz, "%s", "Bad checksum in manageability sections");
        case __DP(pe_prot):
        return snprintf(s, sz, "%s", "EEPROM protection disabled");
        case __DP(pe_clkoff):
        return snprintf(s, sz, "%s", "Clock off command executed");
        case __DP(pe_flchk):
        return snprintf(s, sz, "%s", "Bad checksum in flash header");
        case __DP(pe_pschk):
        return snprintf(s, sz, "%s", "Bad checksum in patch section");
        case __DP(pe_lschk):
        return snprintf(s, sz, "%s", "Bad checksum in loader section");
        case __DP(pe_dschk):
        return snprintf(s, sz, "%s", "Bad checksum in diagnostic section");
        case __DP(pe_inval):
        return snprintf(s, sz, "%s", "Invalid firmware mode");
        case __DP(pe_tlbe):
        return snprintf(s, sz, "%s", "TLB table exceeded");
        case __DP(pe_eerd):
        return snprintf(s, sz, "%s", "EEPROM read failed");
        case __DP(pe_hwver):
        return snprintf(s, sz, "%s", "Bad hardware version in patch load");
        case __DP(pe_sfrd):
        return snprintf(s, sz, "%s", "SFlash read failed");
        case __DP(pe_unspec):
        return snprintf(s, sz, "%s", "Unspecified error");
        case __DP(pe_auth):
        return snprintf(s, sz, "%s", "Flash authentication failed");
        case __DP(pe_pfrd):
        return snprintf(s, sz, "%s", "PFlash read failed");
        case __DP(pe_ifep):
        return snprintf(s, sz, "%s", "Invalid Flash entry point");
        default:
        return snprintf(s, sz, "Unknown " __XTR(e1000_pcierr_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int e1000_pcierr_chk( e1000_pcierr_t e ) __attribute__ ((always_inline));
static inline int e1000_pcierr_chk( e1000_pcierr_t e )
{
    switch (e) {
        case __DP(pe_none):
        return 1;
        case __DP(pe_mschk):
        return 1;
        case __DP(pe_prot):
        return 1;
        case __DP(pe_clkoff):
        return 1;
        case __DP(pe_flchk):
        return 1;
        case __DP(pe_pschk):
        return 1;
        case __DP(pe_lschk):
        return 1;
        case __DP(pe_dschk):
        return 1;
        case __DP(pe_inval):
        return 1;
        case __DP(pe_tlbe):
        return 1;
        case __DP(pe_eerd):
        return 1;
        case __DP(pe_hwver):
        return 1;
        case __DP(pe_sfrd):
        return 1;
        case __DP(pe_unspec):
        return 1;
        case __DP(pe_auth):
        return 1;
        case __DP(pe_pfrd):
        return 1;
        case __DP(pe_ifep):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: e1000.rsstype (RSS computation type)
 */
typedef enum e1000_rsstype_t {
    __DP(no_rss) = (0x0),
    __DP(tcp_v4) = (0x1),
    __DP(ipv4) = (0x2),
    __DP(tcp_v6) = (0x3),
    __DP(ipv6) = (0x5),
} e1000_rsstype_t;

static inline int e1000_rsstype_prt( char * s, size_t sz, e1000_rsstype_t e ) __attribute__ ((always_inline));
static inline int e1000_rsstype_prt( char * s, size_t sz, e1000_rsstype_t e )
{
    switch (e) {
        case __DP(no_rss):
        return snprintf(s, sz, "%s", "No RS computation");
        case __DP(tcp_v4):
        return snprintf(s, sz, "%s", "IPv4 with TCP hash");
        case __DP(ipv4):
        return snprintf(s, sz, "%s", "IPv4 hash");
        case __DP(tcp_v6):
        return snprintf(s, sz, "%s", "IPv6 with TCP hash");
        case __DP(ipv6):
        return snprintf(s, sz, "%s", "IPv6 hash");
        default:
        return snprintf(s, sz, "Unknown " __XTR(e1000_rsstype_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int e1000_rsstype_chk( e1000_rsstype_t e ) __attribute__ ((always_inline));
static inline int e1000_rsstype_chk( e1000_rsstype_t e )
{
    switch (e) {
        case __DP(no_rss):
        return 1;
        case __DP(tcp_v4):
        return 1;
        case __DP(ipv4):
        return 1;
        case __DP(tcp_v6):
        return 1;
        case __DP(ipv6):
        return 1;
        default:
        return 0;
    }
}


/*
 * Register type: Implicit type of Device control register
 */

/*
 * Dump of fields for register type: e1000_ctrl_t
 *   fd (size 1, offset 0):	 RW	  full-duplex
 *   _anon1 (size 1, offset 1):	 MBZ	  _
 *   gio_md (size 1, offset 2):	 RW	  GIO master disable
 *   lrst (size 1, offset 3):	 RW	  Link reset
 *   _anon4 (size 2, offset 4):	 MBZ	  _
 *   slu (size 1, offset 6):	 RW	  Set link up
 *   _anon7 (size 1, offset 7):	 MBZ	  _
 *   speed (size 2, offset 8):	 RW	  Speed selection
 *   _anon10 (size 1, offset 10):	 MBZ	  _
 *   frcspd (size 1, offset 11):	 RW	  Force speed
 *   frcdplx (size 1, offset 12):	 RW	  Force duplex
 *   _anon13 (size 5, offset 13):	 MBZ	  _
 *   sdp0_data (size 1, offset 18):	 RW	  SDP0 data value, or dock/undock status
 *   sdp1_data (size 1, offset 19):	 RW	  SDP1 data value
 *   advd3wuc (size 1, offset 20):	 RW	  D3cold wakeup capability
 *   _anon21 (size 1, offset 21):	 MBZ	  _
 *   sdp0_iodir (size 1, offset 22):	 RW	  SDP0 pin I/O directionality
 *   sdp1_iodir (size 1, offset 23):	 RW	  SDP1 pin I/O directionality
 *   _anon24 (size 2, offset 24):	 MBZ	  _
 *   rst (size 1, offset 26):	 RW	  Device reset
 *   rfce (size 1, offset 27):	 RW	  Receive flow control enable
 *   tfce (size 1, offset 28):	 RW	  Transmit flow control enable
 *   _anon29 (size 1, offset 29):	 MBZ	  _
 *   vme (size 1, offset 30):	 RW	  VLAN mode enable
 *   phy_rst (size 1, offset 31):	 RW	  PHY reset
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_ctrl_t {
    uint8_t	fd	:1;
    uint8_t	_anon1	:1;
    uint8_t	gio_md	:1;
    uint8_t	lrst	:1;
    uint8_t	_anon4	:2;
    uint8_t	slu	:1;
    uint8_t	_anon7	:1;
    e1000_linkspeed_t	speed	:2;
    uint8_t	_anon10	:1;
    uint8_t	frcspd	:1;
    uint8_t	frcdplx	:1;
    uint8_t	_anon13	:5;
    uint8_t	sdp0_data	:1;
    uint8_t	sdp1_data	:1;
    uint8_t	advd3wuc	:1;
    uint8_t	_anon21	:1;
    uint8_t	sdp0_iodir	:1;
    uint8_t	sdp1_iodir	:1;
    uint8_t	_anon24	:2;
    uint8_t	rst	:1;
    uint8_t	rfce	:1;
    uint8_t	tfce	:1;
    uint8_t	_anon29	:1;
    uint8_t	vme	:1;
    uint8_t	phy_rst	:1;
} __attribute__ ((packed))
 e1000_ctrl_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_ctrl_t, sizeof(uint32_t));

typedef union e1000_ctrl_un {
    e1000_ctrl_t	val;
    uint32_t	raw;
}
 e1000_ctrl_un;
static inline int e1000_ctrl_prtval( char * s, size_t sz, e1000_ctrl_t v ) __attribute__ ((always_inline));
static inline int e1000_ctrl_prtval( char * s, size_t sz, e1000_ctrl_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fd=0x%"PRIx8" (full-duplex)\n", (uint8_t)(v.fd));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " gio_md=0x%"PRIx8" (GIO master disable)\n", (uint8_t)(v.gio_md));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " lrst=0x%"PRIx8" (Link reset)\n", (uint8_t)(v.lrst));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " slu=0x%"PRIx8" (Set link up)\n", (uint8_t)(v.slu));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " speed=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_linkspeed_prt(s+r, _avail, v.speed);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Speed selection)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " frcspd=0x%"PRIx8" (Force speed)\n", (uint8_t)(v.frcspd));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " frcdplx=0x%"PRIx8" (Force duplex)\n", (uint8_t)(v.frcdplx));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sdp0_data=0x%"PRIx8" (SDP0 data value, or dock/undock status)\n", (uint8_t)(v.sdp0_data));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sdp1_data=0x%"PRIx8" (SDP1 data value)\n", (uint8_t)(v.sdp1_data));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " advd3wuc=0x%"PRIx8" (D3cold wakeup capability)\n", (uint8_t)(v.advd3wuc));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sdp0_iodir=0x%"PRIx8" (SDP0 pin I/O directionality)\n", (uint8_t)(v.sdp0_iodir));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sdp1_iodir=0x%"PRIx8" (SDP1 pin I/O directionality)\n", (uint8_t)(v.sdp1_iodir));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rst=0x%"PRIx8" (Device reset)\n", (uint8_t)(v.rst));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rfce=0x%"PRIx8" (Receive flow control enable)\n", (uint8_t)(v.rfce));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " tfce=0x%"PRIx8" (Transmit flow control enable)\n", (uint8_t)(v.tfce));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vme=0x%"PRIx8" (VLAN mode enable)\n", (uint8_t)(v.vme));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " phy_rst=0x%"PRIx8" (PHY reset)\n", (uint8_t)(v.phy_rst));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Device status register
 */

/*
 * Dump of fields for register type: e1000_status_t
 *   fd (size 1, offset 0):	 RW	  Link full duplex configuration
 *   lu (size 1, offset 1):	 RW	  Link up
 *   lan_id (size 2, offset 2):	 RW	  LAN ID
 *   txoff (size 1, offset 4):	 RW	  Transmission paused
 *   tbimode (size 1, offset 5):	 RW	  TBI mode
 *   speed (size 2, offset 6):	 RW	  Link speed setting
 *   asdv (size 2, offset 8):	 RW	  Auto speed detection value
 *   phyra (size 1, offset 10):	 RW	  PHY reset asserted
 *   _anon11 (size 8, offset 11):	 MBZ	  _
 *   gio_mes (size 1, offset 19):	 RW	  GIO master enable status
 *   _anon20 (size 12, offset 20):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_status_t {
    uint8_t	fd	:1;
    uint8_t	lu	:1;
    uint8_t	lan_id	:2;
    uint8_t	txoff	:1;
    uint8_t	tbimode	:1;
    e1000_linkspeed_t	speed	:2;
    e1000_linkspeed_t	asdv	:2;
    uint8_t	phyra	:1;
    uint8_t	_anon11	:8;
    uint8_t	gio_mes	:1;
    uint16_t	_anon20	:12;
} __attribute__ ((packed))
 e1000_status_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_status_t, sizeof(uint32_t));

typedef union e1000_status_un {
    e1000_status_t	val;
    uint32_t	raw;
}
 e1000_status_un;
static inline int e1000_status_prtval( char * s, size_t sz, e1000_status_t v ) __attribute__ ((always_inline));
static inline int e1000_status_prtval( char * s, size_t sz, e1000_status_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fd=0x%"PRIx8" (Link full duplex configuration)\n", (uint8_t)(v.fd));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " lu=0x%"PRIx8" (Link up)\n", (uint8_t)(v.lu));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " lan_id=0x%"PRIx8" (LAN ID)\n", (uint8_t)(v.lan_id));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " txoff=0x%"PRIx8" (Transmission paused)\n", (uint8_t)(v.txoff));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " tbimode=0x%"PRIx8" (TBI mode)\n", (uint8_t)(v.tbimode));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " speed=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_linkspeed_prt(s+r, _avail, v.speed);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Link speed setting)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " asdv=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_linkspeed_prt(s+r, _avail, v.asdv);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Auto speed detection value)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " phyra=0x%"PRIx8" (PHY reset asserted)\n", (uint8_t)(v.phyra));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " gio_mes=0x%"PRIx8" (GIO master enable status)\n", (uint8_t)(v.gio_mes));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of EEPROM/Flash control register
 */

/*
 * Dump of fields for register type: e1000_eec_t
 *   ee_sk (size 1, offset 0):	 RW	  Clock input to EEPROM
 *   ee_cs (size 1, offset 1):	 RW	  Chip select to EEPROM
 *   ee_di (size 1, offset 2):	 RW	  Data input to EEPROM
 *   ee_do (size 1, offset 3):	 RW	  Data output bit from EEPROM
 *   fwe (size 2, offset 4):	 RW	  Flash write enable control
 *   ee_req (size 1, offset 6):	 RW	  Request EEPROM access
 *   ee_gnt (size 1, offset 7):	 RW	  Grant EEPROM access
 *   ee_pres (size 1, offset 8):	 RW	  EEPROM present
 *   auto_rd (size 1, offset 9):	 RW	  EEPROM auto read done
 *   ee_addr_sz (size 1, offset 10):	 RW	  EEPROM address size
 *   ee_size (size 4, offset 11):	 RW	  EEPROM size (x128 bytes)
 *   nvadds (size 2, offset 15):	 RW	  NVM address size in bytes
 *   _anon17 (size 3, offset 17):	 RSVD	  _
 *   aupden (size 1, offset 20):	 RW	  Enable automatic Flash update
 *   _anon21 (size 2, offset 21):	 RSVD	  _
 *   nvmtype (size 2, offset 23):	 RO	  NVM type
 *   _anon25 (size 7, offset 25):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_eec_t {
    uint8_t	ee_sk	:1;
    uint8_t	ee_cs	:1;
    uint8_t	ee_di	:1;
    uint8_t	ee_do	:1;
    e1000_flashenable_t	fwe	:2;
    uint8_t	ee_req	:1;
    uint8_t	ee_gnt	:1;
    uint8_t	ee_pres	:1;
    uint8_t	auto_rd	:1;
    e1000_eeaddrsize_t	ee_addr_sz	:1;
    uint8_t	ee_size	:4;
    uint8_t	nvadds	:2;
    uint8_t	_anon17	:3;
    uint8_t	aupden	:1;
    uint8_t	_anon21	:2;
    e1000_nvmtype_t	nvmtype	:2;
    uint8_t	_anon25	:7;
} __attribute__ ((packed))
 e1000_eec_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_eec_t, sizeof(uint32_t));

typedef union e1000_eec_un {
    e1000_eec_t	val;
    uint32_t	raw;
}
 e1000_eec_un;
static inline int e1000_eec_prtval( char * s, size_t sz, e1000_eec_t v ) __attribute__ ((always_inline));
static inline int e1000_eec_prtval( char * s, size_t sz, e1000_eec_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ee_sk=0x%"PRIx8" (Clock input to EEPROM)\n", (uint8_t)(v.ee_sk));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ee_cs=0x%"PRIx8" (Chip select to EEPROM)\n", (uint8_t)(v.ee_cs));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ee_di=0x%"PRIx8" (Data input to EEPROM)\n", (uint8_t)(v.ee_di));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ee_do=0x%"PRIx8" (Data output bit from EEPROM)\n", (uint8_t)(v.ee_do));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " fwe=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_flashenable_prt(s+r, _avail, v.fwe);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Flash write enable control)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ee_req=0x%"PRIx8" (Request EEPROM access)\n", (uint8_t)(v.ee_req));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ee_gnt=0x%"PRIx8" (Grant EEPROM access)\n", (uint8_t)(v.ee_gnt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ee_pres=0x%"PRIx8" (EEPROM present)\n", (uint8_t)(v.ee_pres));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " auto_rd=0x%"PRIx8" (EEPROM auto read done)\n", (uint8_t)(v.auto_rd));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " ee_addr_sz=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_eeaddrsize_prt(s+r, _avail, v.ee_addr_sz);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (EEPROM address size)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ee_size=0x%"PRIx8" (EEPROM size (x128 bytes))\n", (uint8_t)(v.ee_size));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " nvadds=0x%"PRIx8" (NVM address size in bytes)\n", (uint8_t)(v.nvadds));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " aupden=0x%"PRIx8" (Enable automatic Flash update)\n", (uint8_t)(v.aupden));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " nvmtype=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_nvmtype_prt(s+r, _avail, v.nvmtype);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (NVM type)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of EEPROM read register
 */

/*
 * Dump of fields for register type: e1000_eerd_t
 *   start (size 1, offset 0):	 RW	  Start read
 *   done (size 1, offset 1):	 RO	  Read done
 *   addr (size 14, offset 2):	 RW	  Read address
 *   data (size 16, offset 16):	 RW	  Read data
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_eerd_t {
    uint8_t	start	:1;
    uint8_t	done	:1;
    uint16_t	addr	:14;
    uint16_t	data	:16;
} __attribute__ ((packed))
 e1000_eerd_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_eerd_t, sizeof(uint32_t));

typedef union e1000_eerd_un {
    e1000_eerd_t	val;
    uint32_t	raw;
}
 e1000_eerd_un;
static inline int e1000_eerd_prtval( char * s, size_t sz, e1000_eerd_t v ) __attribute__ ((always_inline));
static inline int e1000_eerd_prtval( char * s, size_t sz, e1000_eerd_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " start=0x%"PRIx8" (Start read)\n", (uint8_t)(v.start));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " done=0x%"PRIx8" (Read done)\n", (uint8_t)(v.done));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " addr=0x%0"PRIx16" (Read address)\n", (uint16_t)(v.addr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " data=0x%0"PRIx16" (Read data)\n", (uint16_t)(v.data));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Extended device control register
 */

/*
 * Dump of fields for register type: e1000_ctrlext_t
 *   _anon0 (size 2, offset 0):	 MBZ	  _
 *   sdp2_gpien (size 1, offset 2):	 RW	  General-purpose interrupt detection for SDP2
 *   sdp3_gpien (size 1, offset 3):	 RW	  General-purpose interrupt detection for SDP3
 *   _anon4 (size 2, offset 4):	 RSVD	  _
 *   sdp2_data (size 1, offset 6):	 RW	  SDP2 data value
 *   sdp3_data (size 1, offset 7):	 RW	  SDP3 data value
 *   _anon8 (size 2, offset 8):	 MBZ	  _
 *   sdp2_iodir (size 1, offset 10):	 RW	  SDP2 pin directionality
 *   sdp3_iodir (size 1, offset 11):	 RW	  SDP3 pin directionality
 *   asdchk (size 1, offset 12):	 RW	  Auto-speed-detection check
 *   ee_rst (size 1, offset 13):	 RW	  EEPROM reset
 *   _anon14 (size 1, offset 14):	 MBZ	  _
 *   spd_byps (size 1, offset 15):	 RW	  Speed select bypass
 *   _anon16 (size 1, offset 16):	 RSVD	  _
 *   rodis (size 1, offset 17):	 RW	  Relaxed ordering disabled
 *   serdeslpe (size 1, offset 18):	 RW	  SERDES low power enable
 *   dmadge (size 1, offset 19):	 RW	  DMA dynamic gating enable
 *   phypde (size 1, offset 20):	 RW	  PHY power down enable
 *   _anon21 (size 1, offset 21):	 RSVD	  _
 *   link_mode (size 2, offset 22):	 RW	  Link mode
 *   pb_paren (size 1, offset 24):	 RW	  Packet buffer parity error detection enable
 *   df_paren (size 1, offset 25):	 RW	  Descriptor FIFO parity error detection enable
 *   _anon26 (size 1, offset 26):	 MBZ	  _
 *   iame (size 1, offset 27):	 RW	  Interrupt acknowledge auto-mask enable
 *   drv_load (size 1, offset 28):	 RW	  Driver loaded
 *   int_tca (size 1, offset 29):	 RW	  Timers clear enable
 *   host_paren (size 1, offset 30):	 RW	  Host data FIFO parity enable
 *   _anon31 (size 1, offset 31):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_ctrlext_t {
    uint8_t	_anon0	:2;
    uint8_t	sdp2_gpien	:1;
    uint8_t	sdp3_gpien	:1;
    uint8_t	_anon4	:2;
    uint8_t	sdp2_data	:1;
    uint8_t	sdp3_data	:1;
    uint8_t	_anon8	:2;
    uint8_t	sdp2_iodir	:1;
    uint8_t	sdp3_iodir	:1;
    uint8_t	asdchk	:1;
    uint8_t	ee_rst	:1;
    uint8_t	_anon14	:1;
    uint8_t	spd_byps	:1;
    uint8_t	_anon16	:1;
    uint8_t	rodis	:1;
    uint8_t	serdeslpe	:1;
    uint8_t	dmadge	:1;
    uint8_t	phypde	:1;
    uint8_t	_anon21	:1;
    e1000_linkmode_t	link_mode	:2;
    uint8_t	pb_paren	:1;
    uint8_t	df_paren	:1;
    uint8_t	_anon26	:1;
    uint8_t	iame	:1;
    uint8_t	drv_load	:1;
    uint8_t	int_tca	:1;
    uint8_t	host_paren	:1;
    uint8_t	_anon31	:1;
} __attribute__ ((packed))
 e1000_ctrlext_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_ctrlext_t, sizeof(uint32_t));

typedef union e1000_ctrlext_un {
    e1000_ctrlext_t	val;
    uint32_t	raw;
}
 e1000_ctrlext_un;
static inline int e1000_ctrlext_prtval( char * s, size_t sz, e1000_ctrlext_t v ) __attribute__ ((always_inline));
static inline int e1000_ctrlext_prtval( char * s, size_t sz, e1000_ctrlext_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sdp2_gpien=0x%"PRIx8" (General-purpose interrupt detection for SDP2)\n", (uint8_t)(v.sdp2_gpien));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sdp3_gpien=0x%"PRIx8" (General-purpose interrupt detection for SDP3)\n", (uint8_t)(v.sdp3_gpien));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sdp2_data=0x%"PRIx8" (SDP2 data value)\n", (uint8_t)(v.sdp2_data));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sdp3_data=0x%"PRIx8" (SDP3 data value)\n", (uint8_t)(v.sdp3_data));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sdp2_iodir=0x%"PRIx8" (SDP2 pin directionality)\n", (uint8_t)(v.sdp2_iodir));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sdp3_iodir=0x%"PRIx8" (SDP3 pin directionality)\n", (uint8_t)(v.sdp3_iodir));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " asdchk=0x%"PRIx8" (Auto-speed-detection check)\n", (uint8_t)(v.asdchk));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ee_rst=0x%"PRIx8" (EEPROM reset)\n", (uint8_t)(v.ee_rst));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " spd_byps=0x%"PRIx8" (Speed select bypass)\n", (uint8_t)(v.spd_byps));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rodis=0x%"PRIx8" (Relaxed ordering disabled)\n", (uint8_t)(v.rodis));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " serdeslpe=0x%"PRIx8" (SERDES low power enable)\n", (uint8_t)(v.serdeslpe));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " dmadge=0x%"PRIx8" (DMA dynamic gating enable)\n", (uint8_t)(v.dmadge));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " phypde=0x%"PRIx8" (PHY power down enable)\n", (uint8_t)(v.phypde));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " link_mode=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_linkmode_prt(s+r, _avail, v.link_mode);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Link mode)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pb_paren=0x%"PRIx8" (Packet buffer parity error detection enable)\n", (uint8_t)(v.pb_paren));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " df_paren=0x%"PRIx8" (Descriptor FIFO parity error detection enable)\n", (uint8_t)(v.df_paren));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " iame=0x%"PRIx8" (Interrupt acknowledge auto-mask enable)\n", (uint8_t)(v.iame));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " drv_load=0x%"PRIx8" (Driver loaded)\n", (uint8_t)(v.drv_load));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " int_tca=0x%"PRIx8" (Timers clear enable)\n", (uint8_t)(v.int_tca));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " host_paren=0x%"PRIx8" (Host data FIFO parity enable)\n", (uint8_t)(v.host_paren));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Flash access register
 */

/*
 * Dump of fields for register type: e1000_fla_t
 *   fl_sk (size 1, offset 0):	 RW	  Clock input to Flash
 *   fl_ce (size 1, offset 1):	 RW	  Chip select to Flash
 *   fl_si (size 1, offset 2):	 RW	  Data input to Flash
 *   fl_so (size 1, offset 3):	 RW	  Data output bit from Flash
 *   fl_req (size 1, offset 4):	 RW	  Request Flash access
 *   fl_gnt (size 1, offset 5):	 RW	  Grant Flash access
 *   fl_addr_sz (size 1, offset 6):	 RW	  Flash address size
 *   _anon7 (size 2, offset 7):	 RSVD	  _
 *   sw_wr_done (size 1, offset 9):	 RW	  Last write done
 *   rd_status (size 1, offset 10):	 RW	  Flash status
 *   _anon11 (size 5, offset 11):	 RSVD	  _
 *   ide_bo (size 14, offset 16):	 RW	  Base address of IDE Boot expansion ROM
 *   fl_busy (size 1, offset 30):	 RW	  Flash busy
 *   fl_er (size 1, offset 31):	 RW	  Flash erase command
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_fla_t {
    uint8_t	fl_sk	:1;
    uint8_t	fl_ce	:1;
    uint8_t	fl_si	:1;
    uint8_t	fl_so	:1;
    uint8_t	fl_req	:1;
    uint8_t	fl_gnt	:1;
    uint8_t	fl_addr_sz	:1;
    uint8_t	_anon7	:2;
    uint8_t	sw_wr_done	:1;
    uint8_t	rd_status	:1;
    uint8_t	_anon11	:5;
    uint16_t	ide_bo	:14;
    uint8_t	fl_busy	:1;
    uint8_t	fl_er	:1;
} __attribute__ ((packed))
 e1000_fla_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_fla_t, sizeof(uint32_t));

typedef union e1000_fla_un {
    e1000_fla_t	val;
    uint32_t	raw;
}
 e1000_fla_un;
static inline int e1000_fla_prtval( char * s, size_t sz, e1000_fla_t v ) __attribute__ ((always_inline));
static inline int e1000_fla_prtval( char * s, size_t sz, e1000_fla_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fl_sk=0x%"PRIx8" (Clock input to Flash)\n", (uint8_t)(v.fl_sk));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fl_ce=0x%"PRIx8" (Chip select to Flash)\n", (uint8_t)(v.fl_ce));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fl_si=0x%"PRIx8" (Data input to Flash)\n", (uint8_t)(v.fl_si));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fl_so=0x%"PRIx8" (Data output bit from Flash)\n", (uint8_t)(v.fl_so));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fl_req=0x%"PRIx8" (Request Flash access)\n", (uint8_t)(v.fl_req));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fl_gnt=0x%"PRIx8" (Grant Flash access)\n", (uint8_t)(v.fl_gnt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fl_addr_sz=0x%"PRIx8" (Flash address size)\n", (uint8_t)(v.fl_addr_sz));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sw_wr_done=0x%"PRIx8" (Last write done)\n", (uint8_t)(v.sw_wr_done));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rd_status=0x%"PRIx8" (Flash status)\n", (uint8_t)(v.rd_status));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ide_bo=0x%0"PRIx16" (Base address of IDE Boot expansion ROM)\n", (uint16_t)(v.ide_bo));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fl_busy=0x%"PRIx8" (Flash busy)\n", (uint8_t)(v.fl_busy));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fl_er=0x%"PRIx8" (Flash erase command)\n", (uint8_t)(v.fl_er));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of MDI control register
 */

/*
 * Dump of fields for register type: e1000_mdic_t
 *   data (size 16, offset 0):	 RW	  Data
 *   regadd (size 5, offset 16):	 RW	  PHY register address
 *   phyadd (size 5, offset 21):	 RW	  PHY address
 *   op (size 2, offset 26):	 RW	  Opcode
 *   r (size 1, offset 28):	 RW	  Ready bit
 *   i (size 1, offset 29):	 RW	  Interript enable
 *   e (size 1, offset 30):	 RW	  Error
 *   _anon31 (size 1, offset 31):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_mdic_t {
    uint16_t	data	:16;
    uint8_t	regadd	:5;
    uint8_t	phyadd	:5;
    e1000_phyop_t	op	:2;
    uint8_t	r	:1;
    uint8_t	i	:1;
    uint8_t	e	:1;
    uint8_t	_anon31	:1;
} __attribute__ ((packed))
 e1000_mdic_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_mdic_t, sizeof(uint32_t));

typedef union e1000_mdic_un {
    e1000_mdic_t	val;
    uint32_t	raw;
}
 e1000_mdic_un;
static inline int e1000_mdic_prtval( char * s, size_t sz, e1000_mdic_t v ) __attribute__ ((always_inline));
static inline int e1000_mdic_prtval( char * s, size_t sz, e1000_mdic_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " data=0x%0"PRIx16" (Data)\n", (uint16_t)(v.data));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " regadd=0x%"PRIx8" (PHY register address)\n", (uint8_t)(v.regadd));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " phyadd=0x%"PRIx8" (PHY address)\n", (uint8_t)(v.phyadd));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " op=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_phyop_prt(s+r, _avail, v.op);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Opcode)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " r=0x%"PRIx8" (Ready bit)\n", (uint8_t)(v.r));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " i=0x%"PRIx8" (Interript enable)\n", (uint8_t)(v.i));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " e=0x%"PRIx8" (Error)\n", (uint8_t)(v.e));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of SERDES ANA register
 */

/*
 * Dump of fields for register type: e1000_serdesctl_t
 *   data (size 8, offset 0):	 RW	  Data to SerDes
 *   addr (size 8, offset 8):	 RW	  Address to SerDes
 *   _anon16 (size 15, offset 16):	 RSVD	  _
 *   done (size 1, offset 31):	 RW	  Done
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_serdesctl_t {
    uint8_t	data	:8;
    uint8_t	addr	:8;
    uint16_t	_anon16	:15;
    uint8_t	done	:1;
} __attribute__ ((packed))
 e1000_serdesctl_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_serdesctl_t, sizeof(uint32_t));

typedef union e1000_serdesctl_un {
    e1000_serdesctl_t	val;
    uint32_t	raw;
}
 e1000_serdesctl_un;
static inline int e1000_serdesctl_prtval( char * s, size_t sz, e1000_serdesctl_t v ) __attribute__ ((always_inline));
static inline int e1000_serdesctl_prtval( char * s, size_t sz, e1000_serdesctl_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " data=0x%"PRIx8" (Data to SerDes)\n", (uint8_t)(v.data));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " addr=0x%"PRIx8" (Address to SerDes)\n", (uint8_t)(v.addr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " done=0x%"PRIx8" (Done)\n", (uint8_t)(v.done));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of GLCI control and status register
 */

/*
 * Dump of fields for register type: e1000_kumctrlsta_t
 *   data (size 16, offset 0):	 RW	  Data
 *   offset (size 5, offset 16):	 RW	  Offset of internal register
 *   ren (size 1, offset 21):	 RW	  Read enable (1=read)
 *   _anon22 (size 10, offset 22):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_kumctrlsta_t {
    uint16_t	data	:16;
    uint8_t	offset	:5;
    uint8_t	ren	:1;
    uint16_t	_anon22	:10;
} __attribute__ ((packed))
 e1000_kumctrlsta_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_kumctrlsta_t, sizeof(uint32_t));

typedef union e1000_kumctrlsta_un {
    e1000_kumctrlsta_t	val;
    uint32_t	raw;
}
 e1000_kumctrlsta_un;
static inline int e1000_kumctrlsta_prtval( char * s, size_t sz, e1000_kumctrlsta_t v ) __attribute__ ((always_inline));
static inline int e1000_kumctrlsta_prtval( char * s, size_t sz, e1000_kumctrlsta_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " data=0x%0"PRIx16" (Data)\n", (uint16_t)(v.data));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " offset=0x%"PRIx8" (Offset of internal register)\n", (uint8_t)(v.offset));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ren=0x%"PRIx8" (Read enable (1=read))\n", (uint8_t)(v.ren));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of MDC/MDIO PHY address register
 */

/*
 * Dump of fields for register type: e1000_mdphya_t
 *   phya (size 5, offset 0):	 RW	  PHY address
 *   _anon5 (size 27, offset 5):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_mdphya_t {
    uint8_t	phya	:5;
    uint32_t	_anon5	:27;
} __attribute__ ((packed))
 e1000_mdphya_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_mdphya_t, sizeof(uint32_t));

typedef union e1000_mdphya_un {
    e1000_mdphya_t	val;
    uint32_t	raw;
}
 e1000_mdphya_un;
static inline int e1000_mdphya_prtval( char * s, size_t sz, e1000_mdphya_t v ) __attribute__ ((always_inline));
static inline int e1000_mdphya_prtval( char * s, size_t sz, e1000_mdphya_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " phya=0x%"PRIx8" (PHY address)\n", (uint8_t)(v.phya));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of ULT Fuse register 3 register
 */

/*
 * Dump of fields for register type: e1000_ufuse3_t
 *   drred (size 15, offset 0):	 RO	  Data RAM redundancy fuses
 *   crred (size 13, offset 15):	 RO	  Code RAM redundancy fuses
 *   enad (size 1, offset 28):	 RO	  Enable Data RAM redundancy fuses
 *   enac (size 1, offset 29):	 RO	  Enable Code RAM redundancy fuses
 *   _anon30 (size 2, offset 30):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_ufuse3_t {
    uint16_t	drred	:15;
    uint16_t	crred	:13;
    uint8_t	enad	:1;
    uint8_t	enac	:1;
    uint8_t	_anon30	:2;
} __attribute__ ((packed))
 e1000_ufuse3_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_ufuse3_t, sizeof(uint32_t));

typedef union e1000_ufuse3_un {
    e1000_ufuse3_t	val;
    uint32_t	raw;
}
 e1000_ufuse3_un;
static inline int e1000_ufuse3_prtval( char * s, size_t sz, e1000_ufuse3_t v ) __attribute__ ((always_inline));
static inline int e1000_ufuse3_prtval( char * s, size_t sz, e1000_ufuse3_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " drred=0x%0"PRIx16" (Data RAM redundancy fuses)\n", (uint16_t)(v.drred));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " crred=0x%0"PRIx16" (Code RAM redundancy fuses)\n", (uint16_t)(v.crred));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " enad=0x%"PRIx8" (Enable Data RAM redundancy fuses)\n", (uint8_t)(v.enad));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " enac=0x%"PRIx8" (Enable Code RAM redundancy fuses)\n", (uint8_t)(v.enac));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Flow control transmit timer value register
 */

/*
 * Dump of fields for register type: e1000_fcttv_t
 *   ttv (size 16, offset 0):	 RW	  Transmit timer value
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_fcttv_t {
    uint16_t	ttv	:16;
    uint16_t	_anon16	:16;
} __attribute__ ((packed))
 e1000_fcttv_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_fcttv_t, sizeof(uint32_t));

typedef union e1000_fcttv_un {
    e1000_fcttv_t	val;
    uint32_t	raw;
}
 e1000_fcttv_un;
static inline int e1000_fcttv_prtval( char * s, size_t sz, e1000_fcttv_t v ) __attribute__ ((always_inline));
static inline int e1000_fcttv_prtval( char * s, size_t sz, e1000_fcttv_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ttv=0x%0"PRIx16" (Transmit timer value)\n", (uint16_t)(v.ttv));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Transmit config word register
 */

/*
 * Dump of fields for register type: e1000_txcw_t
 *   _anon0 (size 5, offset 0):	 MBZ	  _
 *   txcw_fd (size 1, offset 5):	 RW	  TXCW full-duplex
 *   txcw_hd (size 1, offset 6):	 RW	  TXCW half-duplex
 *   txcw_pause (size 2, offset 7):	 RW	  TXCW pause
 *   _anon9 (size 3, offset 9):	 MBZ	  _
 *   txcw_rfi (size 2, offset 12):	 RW	  TXCW remote fault indication
 *   _anon14 (size 1, offset 14):	 MBZ	  _
 *   txcw_npr (size 1, offset 15):	 RW	  TXCW next page request
 *   _anon16 (size 14, offset 16):	 MBZ	  _
 *   txconfig (size 1, offset 30):	 RW	  Transmit config control bit
 *   ane (size 1, offset 31):	 RW	  Auto-negotiation enable
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_txcw_t {
    uint8_t	_anon0	:5;
    uint8_t	txcw_fd	:1;
    uint8_t	txcw_hd	:1;
    uint8_t	txcw_pause	:2;
    uint8_t	_anon9	:3;
    uint8_t	txcw_rfi	:2;
    uint8_t	_anon14	:1;
    uint8_t	txcw_npr	:1;
    uint16_t	_anon16	:14;
    uint8_t	txconfig	:1;
    uint8_t	ane	:1;
} __attribute__ ((packed))
 e1000_txcw_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_txcw_t, sizeof(uint32_t));

typedef union e1000_txcw_un {
    e1000_txcw_t	val;
    uint32_t	raw;
}
 e1000_txcw_un;
static inline int e1000_txcw_prtval( char * s, size_t sz, e1000_txcw_t v ) __attribute__ ((always_inline));
static inline int e1000_txcw_prtval( char * s, size_t sz, e1000_txcw_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " txcw_fd=0x%"PRIx8" (TXCW full-duplex)\n", (uint8_t)(v.txcw_fd));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " txcw_hd=0x%"PRIx8" (TXCW half-duplex)\n", (uint8_t)(v.txcw_hd));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " txcw_pause=0x%"PRIx8" (TXCW pause)\n", (uint8_t)(v.txcw_pause));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " txcw_rfi=0x%"PRIx8" (TXCW remote fault indication)\n", (uint8_t)(v.txcw_rfi));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " txcw_npr=0x%"PRIx8" (TXCW next page request)\n", (uint8_t)(v.txcw_npr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " txconfig=0x%"PRIx8" (Transmit config control bit)\n", (uint8_t)(v.txconfig));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ane=0x%"PRIx8" (Auto-negotiation enable)\n", (uint8_t)(v.ane));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Receive config word register
 */

/*
 * Dump of fields for register type: e1000_rxcw_t
 *   _anon0 (size 5, offset 0):	 MBZ	  _
 *   rxcw_fd (size 1, offset 5):	 RO	  RXCW full-duplex
 *   rxcw_hd (size 1, offset 6):	 RO	  RXCW half-duplex
 *   rxcw_pause (size 2, offset 7):	 RO	  RXCW pause
 *   _anon9 (size 3, offset 9):	 MBZ	  _
 *   rxcw_rfi (size 2, offset 12):	 RO	  RXCW remote fault indication
 *   _anon14 (size 1, offset 14):	 MBZ	  _
 *   rxcw_npr (size 1, offset 15):	 RO	  RXCW next page request
 *   _anon16 (size 10, offset 16):	 MBZ	  _
 *   nc (size 1, offset 26):	 RO	  Carrier sense indicator
 *   inv (size 1, offset 27):	 RO	  Invalid symbol during config process
 *   chg (size 1, offset 28):	 RO	  Change to RXCW indication
 *   rxconfig (size 1, offset 29):	 RO	  Reception indication
 *   sync (size 1, offset 30):	 RO	  Lost bit sync indication
 *   anc (size 1, offset 31):	 RO	  Auto-negotiation complete
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_rxcw_t {
    uint8_t	_anon0	:5;
    uint8_t	rxcw_fd	:1;
    uint8_t	rxcw_hd	:1;
    uint8_t	rxcw_pause	:2;
    uint8_t	_anon9	:3;
    uint8_t	rxcw_rfi	:2;
    uint8_t	_anon14	:1;
    uint8_t	rxcw_npr	:1;
    uint16_t	_anon16	:10;
    uint8_t	nc	:1;
    uint8_t	inv	:1;
    uint8_t	chg	:1;
    uint8_t	rxconfig	:1;
    uint8_t	sync	:1;
    uint8_t	anc	:1;
} __attribute__ ((packed))
 e1000_rxcw_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_rxcw_t, sizeof(uint32_t));

typedef union e1000_rxcw_un {
    e1000_rxcw_t	val;
    uint32_t	raw;
}
 e1000_rxcw_un;
static inline int e1000_rxcw_prtval( char * s, size_t sz, e1000_rxcw_t v ) __attribute__ ((always_inline));
static inline int e1000_rxcw_prtval( char * s, size_t sz, e1000_rxcw_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rxcw_fd=0x%"PRIx8" (RXCW full-duplex)\n", (uint8_t)(v.rxcw_fd));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rxcw_hd=0x%"PRIx8" (RXCW half-duplex)\n", (uint8_t)(v.rxcw_hd));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rxcw_pause=0x%"PRIx8" (RXCW pause)\n", (uint8_t)(v.rxcw_pause));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rxcw_rfi=0x%"PRIx8" (RXCW remote fault indication)\n", (uint8_t)(v.rxcw_rfi));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rxcw_npr=0x%"PRIx8" (RXCW next page request)\n", (uint8_t)(v.rxcw_npr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " nc=0x%"PRIx8" (Carrier sense indicator)\n", (uint8_t)(v.nc));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " inv=0x%"PRIx8" (Invalid symbol during config process)\n", (uint8_t)(v.inv));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " chg=0x%"PRIx8" (Change to RXCW indication)\n", (uint8_t)(v.chg));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rxconfig=0x%"PRIx8" (Reception indication)\n", (uint8_t)(v.rxconfig));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sync=0x%"PRIx8" (Lost bit sync indication)\n", (uint8_t)(v.sync));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " anc=0x%"PRIx8" (Auto-negotiation complete)\n", (uint8_t)(v.anc));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of LED control register
 */

/*
 * Dump of fields for register type: e1000_ledctl_t
 *   led0_mode (size 4, offset 0):	 RW	  LED0/LINK# mode
 *   _anon4 (size 1, offset 4):	 MBZ	  _
 *   global_blink_mode (size 1, offset 5):	 RW	  Global blink mode
 *   led0_ivrt (size 1, offset 6):	 RW	  LED0 invert
 *   led0_blink (size 1, offset 7):	 RW	  LED0 blink
 *   led1_mode (size 4, offset 8):	 RW	  LED1/LINK# mode
 *   _anon12 (size 1, offset 12):	 MBZ	  _
 *   led1_blink_mode (size 1, offset 13):	 RW	  Global blink mode
 *   led1_ivrt (size 1, offset 14):	 RW	  LED1 invert
 *   led1_blink (size 1, offset 15):	 RW	  LED1 blink
 *   led2_mode (size 4, offset 16):	 RW	  LED2/LINK# mode
 *   _anon20 (size 1, offset 20):	 MBZ	  _
 *   led2_blink_mode (size 1, offset 21):	 RW	  Global blink mode
 *   led2_ivrt (size 1, offset 22):	 RW	  LED2 invert
 *   led2_blink (size 1, offset 23):	 RW	  LED2 blink
 *   led3_mode (size 4, offset 24):	 RW	  LED3/LINK# mode
 *   _anon28 (size 1, offset 28):	 MBZ	  _
 *   led3_blink_mode (size 1, offset 29):	 RW	  Global blink mode
 *   led3_ivrt (size 1, offset 30):	 RW	  LED3 invert
 *   led3_blink (size 1, offset 31):	 RW	  LED3 blink
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_ledctl_t {
    e1000_ledmode_t	led0_mode	:4;
    uint8_t	_anon4	:1;
    e1000_blmode_t	global_blink_mode	:1;
    uint8_t	led0_ivrt	:1;
    uint8_t	led0_blink	:1;
    e1000_ledmode_t	led1_mode	:4;
    uint8_t	_anon12	:1;
    e1000_blmode_t	led1_blink_mode	:1;
    uint8_t	led1_ivrt	:1;
    uint8_t	led1_blink	:1;
    e1000_ledmode_t	led2_mode	:4;
    uint8_t	_anon20	:1;
    e1000_blmode_t	led2_blink_mode	:1;
    uint8_t	led2_ivrt	:1;
    uint8_t	led2_blink	:1;
    e1000_ledmode_t	led3_mode	:4;
    uint8_t	_anon28	:1;
    e1000_blmode_t	led3_blink_mode	:1;
    uint8_t	led3_ivrt	:1;
    uint8_t	led3_blink	:1;
} __attribute__ ((packed))
 e1000_ledctl_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_ledctl_t, sizeof(uint32_t));

typedef union e1000_ledctl_un {
    e1000_ledctl_t	val;
    uint32_t	raw;
}
 e1000_ledctl_un;
static inline int e1000_ledctl_prtval( char * s, size_t sz, e1000_ledctl_t v ) __attribute__ ((always_inline));
static inline int e1000_ledctl_prtval( char * s, size_t sz, e1000_ledctl_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " led0_mode=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_ledmode_prt(s+r, _avail, v.led0_mode);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (LED0/LINK# mode)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " global_blink_mode=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_blmode_prt(s+r, _avail, v.global_blink_mode);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Global blink mode)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " led0_ivrt=0x%"PRIx8" (LED0 invert)\n", (uint8_t)(v.led0_ivrt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " led0_blink=0x%"PRIx8" (LED0 blink)\n", (uint8_t)(v.led0_blink));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " led1_mode=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_ledmode_prt(s+r, _avail, v.led1_mode);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (LED1/LINK# mode)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " led1_blink_mode=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_blmode_prt(s+r, _avail, v.led1_blink_mode);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Global blink mode)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " led1_ivrt=0x%"PRIx8" (LED1 invert)\n", (uint8_t)(v.led1_ivrt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " led1_blink=0x%"PRIx8" (LED1 blink)\n", (uint8_t)(v.led1_blink));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " led2_mode=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_ledmode_prt(s+r, _avail, v.led2_mode);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (LED2/LINK# mode)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " led2_blink_mode=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_blmode_prt(s+r, _avail, v.led2_blink_mode);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Global blink mode)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " led2_ivrt=0x%"PRIx8" (LED2 invert)\n", (uint8_t)(v.led2_ivrt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " led2_blink=0x%"PRIx8" (LED2 blink)\n", (uint8_t)(v.led2_blink));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " led3_mode=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_ledmode_prt(s+r, _avail, v.led3_mode);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (LED3/LINK# mode)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " led3_blink_mode=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_blmode_prt(s+r, _avail, v.led3_blink_mode);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Global blink mode)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " led3_ivrt=0x%"PRIx8" (LED3 invert)\n", (uint8_t)(v.led3_ivrt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " led3_blink=0x%"PRIx8" (LED3 blink)\n", (uint8_t)(v.led3_blink));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Extended config control register
 */

/*
 * Dump of fields for register type: e1000_extcnf_ctrl_t
 *   _anon0 (size 1, offset 0):	 MBZ	  _
 *   phy_we (size 1, offset 1):	 RW	  PHY write enable
 *   dud_en (size 1, offset 2):	 RW	  Extended dock/undock configuration enable
 *   _anon3 (size 1, offset 3):	 RSVD	  _
 *   dock_own (size 1, offset 4):	 RW	  Dock config owner
 *   mdio_swown (size 1, offset 5):	 RW	  MDIO software ownership
 *   mdio_hwown (size 1, offset 6):	 RW	  MDIO hoftware ownership
 *   _anon7 (size 9, offset 7):	 RSVD	  _
 *   ecp (size 12, offset 16):	 RW	  Extended configuration pointer
 *   _anon28 (size 4, offset 28):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_extcnf_ctrl_t {
    uint8_t	_anon0	:1;
    uint8_t	phy_we	:1;
    uint8_t	dud_en	:1;
    uint8_t	_anon3	:1;
    uint8_t	dock_own	:1;
    uint8_t	mdio_swown	:1;
    uint8_t	mdio_hwown	:1;
    uint16_t	_anon7	:9;
    uint16_t	ecp	:12;
    uint8_t	_anon28	:4;
} __attribute__ ((packed))
 e1000_extcnf_ctrl_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_extcnf_ctrl_t, sizeof(uint32_t));

typedef union e1000_extcnf_ctrl_un {
    e1000_extcnf_ctrl_t	val;
    uint32_t	raw;
}
 e1000_extcnf_ctrl_un;
static inline int e1000_extcnf_ctrl_prtval( char * s, size_t sz, e1000_extcnf_ctrl_t v ) __attribute__ ((always_inline));
static inline int e1000_extcnf_ctrl_prtval( char * s, size_t sz, e1000_extcnf_ctrl_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " phy_we=0x%"PRIx8" (PHY write enable)\n", (uint8_t)(v.phy_we));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " dud_en=0x%"PRIx8" (Extended dock/undock configuration enable)\n", (uint8_t)(v.dud_en));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " dock_own=0x%"PRIx8" (Dock config owner)\n", (uint8_t)(v.dock_own));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mdio_swown=0x%"PRIx8" (MDIO software ownership)\n", (uint8_t)(v.mdio_swown));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mdio_hwown=0x%"PRIx8" (MDIO hoftware ownership)\n", (uint8_t)(v.mdio_hwown));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ecp=0x%0"PRIx16" (Extended configuration pointer)\n", (uint16_t)(v.ecp));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Extended config size register
 */

/*
 * Dump of fields for register type: e1000_extcnf_size_t
 *   phy_len (size 8, offset 0):	 RW	  Extended PHY configuration area length
 *   dock_len (size 8, offset 8):	 RW	  Extended dock configuration area length
 *   _anon16 (size 8, offset 16):	 MBZ	  _
 *   _anon24 (size 8, offset 24):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_extcnf_size_t {
    uint8_t	phy_len	:8;
    uint8_t	dock_len	:8;
    uint8_t	_anon16	:8;
    uint8_t	_anon24	:8;
} __attribute__ ((packed))
 e1000_extcnf_size_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_extcnf_size_t, sizeof(uint32_t));

typedef union e1000_extcnf_size_un {
    e1000_extcnf_size_t	val;
    uint32_t	raw;
}
 e1000_extcnf_size_un;
static inline int e1000_extcnf_size_prtval( char * s, size_t sz, e1000_extcnf_size_t v ) __attribute__ ((always_inline));
static inline int e1000_extcnf_size_prtval( char * s, size_t sz, e1000_extcnf_size_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " phy_len=0x%"PRIx8" (Extended PHY configuration area length)\n", (uint8_t)(v.phy_len));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " dock_len=0x%"PRIx8" (Extended dock configuration area length)\n", (uint8_t)(v.dock_len));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Packet buffer allocation register
 */

/*
 * Dump of fields for register type: e1000_pba_t
 *   rxa (size 16, offset 0):	 RW	  Rx packet buffer allocation in KB
 *   txa (size 16, offset 16):	 RW	  Tx packet buffer allocation in KB
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_pba_t {
    uint16_t	rxa	:16;
    uint16_t	txa	:16;
} __attribute__ ((packed))
 e1000_pba_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_pba_t, sizeof(uint32_t));

typedef union e1000_pba_un {
    e1000_pba_t	val;
    uint32_t	raw;
}
 e1000_pba_un;
static inline int e1000_pba_prtval( char * s, size_t sz, e1000_pba_t v ) __attribute__ ((always_inline));
static inline int e1000_pba_prtval( char * s, size_t sz, e1000_pba_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rxa=0x%0"PRIx16" (Rx packet buffer allocation in KB)\n", (uint16_t)(v.rxa));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " txa=0x%0"PRIx16" (Tx packet buffer allocation in KB)\n", (uint16_t)(v.txa));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of MNG EEPROM control register
 */

/*
 * Dump of fields for register type: e1000_eemngctl_t
 *   _anon0 (size 18, offset 0):	 RSVD	  _
 *   crg_done (size 1, offset 18):	 RW	  MNG configuration cycle done
 *   _anon19 (size 13, offset 19):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_eemngctl_t {
    uint32_t	_anon0	:18;
    uint8_t	crg_done	:1;
    uint16_t	_anon19	:13;
} __attribute__ ((packed))
 e1000_eemngctl_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_eemngctl_t, sizeof(uint32_t));

typedef union e1000_eemngctl_un {
    e1000_eemngctl_t	val;
    uint32_t	raw;
}
 e1000_eemngctl_un;
static inline int e1000_eemngctl_prtval( char * s, size_t sz, e1000_eemngctl_t v ) __attribute__ ((always_inline));
static inline int e1000_eemngctl_prtval( char * s, size_t sz, e1000_eemngctl_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " crg_done=0x%"PRIx8" (MNG configuration cycle done)\n", (uint8_t)(v.crg_done));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Software/firmware sync register
 */

/*
 * Dump of fields for register type: e1000_sw_fw_sync_t
 *   sw_eep_sm (size 1, offset 0):	 RW	  EEPROM access owned by software
 *   sw_phy_sm0 (size 1, offset 1):	 RW	  PHY 0 access owned by software
 *   sw_phy_sm1 (size 1, offset 2):	 RW	  PHY 1 access owned by software
 *   sw_mac_csr_sm (size 1, offset 3):	 RW	  Shared CSR access owned by software
 *   _anon4 (size 12, offset 4):	 RSVD	  _
 *   fw_eep_sm (size 1, offset 16):	 RW	  EEPROM access owned by firmware
 *   fw_phy_sm0 (size 1, offset 17):	 RW	  PHY 0 access owned by firmware
 *   fw_phy_sm1 (size 1, offset 18):	 RW	  PHY 1 access owned by firmware
 *   fw_mac_csr_sm (size 1, offset 19):	 RW	  Shared CSR access owned by firmware
 *   _anon20 (size 12, offset 20):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_sw_fw_sync_t {
    uint8_t	sw_eep_sm	:1;
    uint8_t	sw_phy_sm0	:1;
    uint8_t	sw_phy_sm1	:1;
    uint8_t	sw_mac_csr_sm	:1;
    uint16_t	_anon4	:12;
    uint8_t	fw_eep_sm	:1;
    uint8_t	fw_phy_sm0	:1;
    uint8_t	fw_phy_sm1	:1;
    uint8_t	fw_mac_csr_sm	:1;
    uint16_t	_anon20	:12;
} __attribute__ ((packed))
 e1000_sw_fw_sync_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_sw_fw_sync_t, sizeof(uint32_t));

typedef union e1000_sw_fw_sync_un {
    e1000_sw_fw_sync_t	val;
    uint32_t	raw;
}
 e1000_sw_fw_sync_un;
static inline int e1000_sw_fw_sync_prtval( char * s, size_t sz, e1000_sw_fw_sync_t v ) __attribute__ ((always_inline));
static inline int e1000_sw_fw_sync_prtval( char * s, size_t sz, e1000_sw_fw_sync_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sw_eep_sm=0x%"PRIx8" (EEPROM access owned by software)\n", (uint8_t)(v.sw_eep_sm));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sw_phy_sm0=0x%"PRIx8" (PHY 0 access owned by software)\n", (uint8_t)(v.sw_phy_sm0));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sw_phy_sm1=0x%"PRIx8" (PHY 1 access owned by software)\n", (uint8_t)(v.sw_phy_sm1));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sw_mac_csr_sm=0x%"PRIx8" (Shared CSR access owned by software)\n", (uint8_t)(v.sw_mac_csr_sm));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fw_eep_sm=0x%"PRIx8" (EEPROM access owned by firmware)\n", (uint8_t)(v.fw_eep_sm));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fw_phy_sm0=0x%"PRIx8" (PHY 0 access owned by firmware)\n", (uint8_t)(v.fw_phy_sm0));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fw_phy_sm1=0x%"PRIx8" (PHY 1 access owned by firmware)\n", (uint8_t)(v.fw_phy_sm1));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fw_mac_csr_sm=0x%"PRIx8" (Shared CSR access owned by firmware)\n", (uint8_t)(v.fw_mac_csr_sm));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Interrupt register format
 */

/*
 * Dump of fields for register type: e1000_intreg_t
 *   txdw (size 1, offset 0):	 NOATTR	  Transmit descriptor written back
 *   txqe (size 1, offset 1):	 NOATTR	  Transmit queue empty
 *   lsc (size 1, offset 2):	 NOATTR	  Link status change
 *   rxseq (size 1, offset 3):	 NOATTR	  Receive sequence error
 *   rxdmt0 (size 1, offset 4):	 NOATTR	  Receive descriptor minimum threshold reached
 *   _anon5 (size 1, offset 5):	 RSVD	  _
 *   rxo (size 1, offset 6):	 NOATTR	  Receiver overrun
 *   rxt0 (size 1, offset 7):	 NOATTR	  Receiver timer interrupt
 *   _anon8 (size 1, offset 8):	 RSVD	  _
 *   mdac (size 1, offset 9):	 NOATTR	  MDI/O access complete
 *   rxcfg (size 1, offset 10):	 NOATTR	  Received configuration symbols
 *   _anon11 (size 2, offset 11):	 RSVD	  _
 *   gpi_sdp2 (size 1, offset 13):	 NOATTR	  General-purpose interrupt on SPD2
 *   gpi_sdp3 (size 1, offset 14):	 NOATTR	  General-purpose interrupt on SPD3
 *   txd_low (size 1, offset 15):	 NOATTR	  Transmit descriptor low threshold
 *   srpd (size 1, offset 16):	 NOATTR	  Small receive packet detected
 *   ack (size 1, offset 17):	 NOATTR	  Receive ack frame detected
 *   _anon18 (size 2, offset 18):	 RSVD	  _
 *   rx_desc_fifo_par0 (size 1, offset 20):	 NOATTR	  Rx descriptor FIFO parity error 0
 *   tx_desc_fifo_par0 (size 1, offset 21):	 NOATTR	  Tx descriptor FIFO parity error 0
 *   pcie_master_par (size 1, offset 22):	 NOATTR	  PCIe master data FIFO parity error
 *   pbpar (size 1, offset 23):	 NOATTR	  Packet buffer parity error
 *   rx_desc_fifo_par1 (size 1, offset 24):	 NOATTR	  Rx descriptor FIFO parity error 1
 *   tx_desc_fifo_par1 (size 1, offset 25):	 NOATTR	  Tx descriptor FIFO parity error 1
 *   _anon26 (size 5, offset 26):	 RSVD	  _
 *   int_asserted (size 1, offset 31):	 NOATTR	  Interrupt asserted
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_intreg_t {
    uint8_t	txdw	:1;
    uint8_t	txqe	:1;
    uint8_t	lsc	:1;
    uint8_t	rxseq	:1;
    uint8_t	rxdmt0	:1;
    uint8_t	_anon5	:1;
    uint8_t	rxo	:1;
    uint8_t	rxt0	:1;
    uint8_t	_anon8	:1;
    uint8_t	mdac	:1;
    uint8_t	rxcfg	:1;
    uint8_t	_anon11	:2;
    uint8_t	gpi_sdp2	:1;
    uint8_t	gpi_sdp3	:1;
    uint8_t	txd_low	:1;
    uint8_t	srpd	:1;
    uint8_t	ack	:1;
    uint8_t	_anon18	:2;
    uint8_t	rx_desc_fifo_par0	:1;
    uint8_t	tx_desc_fifo_par0	:1;
    uint8_t	pcie_master_par	:1;
    uint8_t	pbpar	:1;
    uint8_t	rx_desc_fifo_par1	:1;
    uint8_t	tx_desc_fifo_par1	:1;
    uint8_t	_anon26	:5;
    uint8_t	int_asserted	:1;
} __attribute__ ((packed))
 e1000_intreg_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_intreg_t, sizeof(uint32_t));

typedef union e1000_intreg_un {
    e1000_intreg_t	val;
    uint32_t	raw;
}
 e1000_intreg_un;
static inline int e1000_intreg_prtval( char * s, size_t sz, e1000_intreg_t v ) __attribute__ ((always_inline));
static inline int e1000_intreg_prtval( char * s, size_t sz, e1000_intreg_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " txdw=0x%"PRIx8" (Transmit descriptor written back)\n", (uint8_t)(v.txdw));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " txqe=0x%"PRIx8" (Transmit queue empty)\n", (uint8_t)(v.txqe));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " lsc=0x%"PRIx8" (Link status change)\n", (uint8_t)(v.lsc));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rxseq=0x%"PRIx8" (Receive sequence error)\n", (uint8_t)(v.rxseq));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rxdmt0=0x%"PRIx8" (Receive descriptor minimum threshold reached)\n", (uint8_t)(v.rxdmt0));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rxo=0x%"PRIx8" (Receiver overrun)\n", (uint8_t)(v.rxo));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rxt0=0x%"PRIx8" (Receiver timer interrupt)\n", (uint8_t)(v.rxt0));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mdac=0x%"PRIx8" (MDI/O access complete)\n", (uint8_t)(v.mdac));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rxcfg=0x%"PRIx8" (Received configuration symbols)\n", (uint8_t)(v.rxcfg));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " gpi_sdp2=0x%"PRIx8" (General-purpose interrupt on SPD2)\n", (uint8_t)(v.gpi_sdp2));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " gpi_sdp3=0x%"PRIx8" (General-purpose interrupt on SPD3)\n", (uint8_t)(v.gpi_sdp3));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " txd_low=0x%"PRIx8" (Transmit descriptor low threshold)\n", (uint8_t)(v.txd_low));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " srpd=0x%"PRIx8" (Small receive packet detected)\n", (uint8_t)(v.srpd));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ack=0x%"PRIx8" (Receive ack frame detected)\n", (uint8_t)(v.ack));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rx_desc_fifo_par0=0x%"PRIx8" (Rx descriptor FIFO parity error 0)\n", (uint8_t)(v.rx_desc_fifo_par0));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " tx_desc_fifo_par0=0x%"PRIx8" (Tx descriptor FIFO parity error 0)\n", (uint8_t)(v.tx_desc_fifo_par0));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pcie_master_par=0x%"PRIx8" (PCIe master data FIFO parity error)\n", (uint8_t)(v.pcie_master_par));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pbpar=0x%"PRIx8" (Packet buffer parity error)\n", (uint8_t)(v.pbpar));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rx_desc_fifo_par1=0x%"PRIx8" (Rx descriptor FIFO parity error 1)\n", (uint8_t)(v.rx_desc_fifo_par1));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " tx_desc_fifo_par1=0x%"PRIx8" (Tx descriptor FIFO parity error 1)\n", (uint8_t)(v.tx_desc_fifo_par1));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " int_asserted=0x%"PRIx8" (Interrupt asserted)\n", (uint8_t)(v.int_asserted));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Interrupt throttling rate register
 */

/*
 * Dump of fields for register type: e1000_itr_t
 *   interval (size 16, offset 0):	 RW	  Minimum inter-interrupt interval (x256ns)
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_itr_t {
    uint16_t	interval	:16;
    uint16_t	_anon16	:16;
} __attribute__ ((packed))
 e1000_itr_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_itr_t, sizeof(uint32_t));

typedef union e1000_itr_un {
    e1000_itr_t	val;
    uint32_t	raw;
}
 e1000_itr_un;
static inline int e1000_itr_prtval( char * s, size_t sz, e1000_itr_t v ) __attribute__ ((always_inline));
static inline int e1000_itr_prtval( char * s, size_t sz, e1000_itr_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " interval=0x%0"PRIx16" (Minimum inter-interrupt interval (x256ns))\n", (uint16_t)(v.interval));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Receive control register
 */

/*
 * Dump of fields for register type: e1000_rctl_t
 *   _anon0 (size 1, offset 0):	 MBZ	  _
 *   en (size 1, offset 1):	 RW	  Receiver enable
 *   sbp (size 1, offset 2):	 RW	  Store bad packets
 *   upe (size 1, offset 3):	 RW	  Unicast promiscuous enabled
 *   mpe (size 1, offset 4):	 RW	  Multicast promiscuous enabled
 *   lpe (size 1, offset 5):	 RW	  Long packet reception enable
 *   lbm (size 2, offset 6):	 RW	  Loopback mode
 *   rdmts (size 2, offset 8):	 RW	  Receive descriptor minimum threshold size
 *   dtyp (size 2, offset 10):	 RW	  Descriptor type
 *   mo (size 2, offset 12):	 RW	  Multicast offset (12 bits starting at 36-val)
 *   _anon14 (size 1, offset 14):	 MBZ	  _
 *   bam (size 1, offset 15):	 RW	  Broadcast accept mode
 *   bsize (size 2, offset 16):	 RW	  Receive buffer size (see BSEX)
 *   vfe (size 1, offset 18):	 RW	  VLAN filter enable
 *   cfien (size 1, offset 19):	 RW	  Canonical form indicator enable
 *   cfi (size 1, offset 20):	 RW	  Canonical form indicator value
 *   _anon21 (size 1, offset 21):	 MBZ	  _
 *   dpf (size 1, offset 22):	 RW	  Discard pause frames
 *   pmcf (size 1, offset 23):	 RW	  Pass MAC control frames
 *   _anon24 (size 1, offset 24):	 MBZ	  _
 *   bsex (size 1, offset 25):	 RW	  Buffer size extension
 *   secrc (size 1, offset 26):	 RW	  Strip Ethernet CRC from packet
 *   flxbuf (size 4, offset 27):	 RW	  Flexible buffer size (in KB)
 *   _anon31 (size 1, offset 31):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_rctl_t {
    uint8_t	_anon0	:1;
    uint8_t	en	:1;
    uint8_t	sbp	:1;
    uint8_t	upe	:1;
    uint8_t	mpe	:1;
    uint8_t	lpe	:1;
    e1000_lbmode_t	lbm	:2;
    e1000_rxthresh_t	rdmts	:2;
    e1000_dtype_t	dtyp	:2;
    uint8_t	mo	:2;
    uint8_t	_anon14	:1;
    uint8_t	bam	:1;
    e1000_rxbsize_t	bsize	:2;
    uint8_t	vfe	:1;
    uint8_t	cfien	:1;
    uint8_t	cfi	:1;
    uint8_t	_anon21	:1;
    uint8_t	dpf	:1;
    uint8_t	pmcf	:1;
    uint8_t	_anon24	:1;
    uint8_t	bsex	:1;
    uint8_t	secrc	:1;
    uint8_t	flxbuf	:4;
    uint8_t	_anon31	:1;
} __attribute__ ((packed))
 e1000_rctl_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_rctl_t, sizeof(uint32_t));

typedef union e1000_rctl_un {
    e1000_rctl_t	val;
    uint32_t	raw;
}
 e1000_rctl_un;
static inline int e1000_rctl_prtval( char * s, size_t sz, e1000_rctl_t v ) __attribute__ ((always_inline));
static inline int e1000_rctl_prtval( char * s, size_t sz, e1000_rctl_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " en=0x%"PRIx8" (Receiver enable)\n", (uint8_t)(v.en));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sbp=0x%"PRIx8" (Store bad packets)\n", (uint8_t)(v.sbp));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " upe=0x%"PRIx8" (Unicast promiscuous enabled)\n", (uint8_t)(v.upe));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mpe=0x%"PRIx8" (Multicast promiscuous enabled)\n", (uint8_t)(v.mpe));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " lpe=0x%"PRIx8" (Long packet reception enable)\n", (uint8_t)(v.lpe));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " lbm=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_lbmode_prt(s+r, _avail, v.lbm);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Loopback mode)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " rdmts=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_rxthresh_prt(s+r, _avail, v.rdmts);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Receive descriptor minimum threshold size)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " dtyp=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_dtype_prt(s+r, _avail, v.dtyp);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Descriptor type)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mo=0x%"PRIx8" (Multicast offset (12 bits starting at 36-val))\n", (uint8_t)(v.mo));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " bam=0x%"PRIx8" (Broadcast accept mode)\n", (uint8_t)(v.bam));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " bsize=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_rxbsize_prt(s+r, _avail, v.bsize);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Receive buffer size (see BSEX))\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vfe=0x%"PRIx8" (VLAN filter enable)\n", (uint8_t)(v.vfe));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " cfien=0x%"PRIx8" (Canonical form indicator enable)\n", (uint8_t)(v.cfien));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " cfi=0x%"PRIx8" (Canonical form indicator value)\n", (uint8_t)(v.cfi));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " dpf=0x%"PRIx8" (Discard pause frames)\n", (uint8_t)(v.dpf));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pmcf=0x%"PRIx8" (Pass MAC control frames)\n", (uint8_t)(v.pmcf));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " bsex=0x%"PRIx8" (Buffer size extension)\n", (uint8_t)(v.bsex));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " secrc=0x%"PRIx8" (Strip Ethernet CRC from packet)\n", (uint8_t)(v.secrc));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " flxbuf=0x%"PRIx8" (Flexible buffer size (in KB))\n", (uint8_t)(v.flxbuf));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Early receive threshold register
 */

/*
 * Dump of fields for register type: e1000_ert_t
 *   rxthresh (size 13, offset 0):	 RW	  Receive threshold value (x 8 bytes)
 *   _anon13 (size 1, offset 13):	 RSVD	  _
 *   _anon14 (size 18, offset 14):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_ert_t {
    uint16_t	rxthresh	:13;
    uint8_t	_anon13	:1;
    uint32_t	_anon14	:18;
} __attribute__ ((packed))
 e1000_ert_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_ert_t, sizeof(uint32_t));

typedef union e1000_ert_un {
    e1000_ert_t	val;
    uint32_t	raw;
}
 e1000_ert_un;
static inline int e1000_ert_prtval( char * s, size_t sz, e1000_ert_t v ) __attribute__ ((always_inline));
static inline int e1000_ert_prtval( char * s, size_t sz, e1000_ert_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rxthresh=0x%0"PRIx16" (Receive threshold value (x 8 bytes))\n", (uint16_t)(v.rxthresh));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Flow control rx threshold low register
 */

/*
 * Dump of fields for register type: e1000_fcrtl_t
 *   _anon0 (size 3, offset 0):	 MBZ	  _
 *   rtl (size 13, offset 3):	 RW	  Recieve threshold low
 *   _anon16 (size 15, offset 16):	 MBZ	  _
 *   xone (size 1, offset 31):	 RW	  XON enable
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_fcrtl_t {
    uint8_t	_anon0	:3;
    uint16_t	rtl	:13;
    uint16_t	_anon16	:15;
    uint8_t	xone	:1;
} __attribute__ ((packed))
 e1000_fcrtl_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_fcrtl_t, sizeof(uint32_t));

typedef union e1000_fcrtl_un {
    e1000_fcrtl_t	val;
    uint32_t	raw;
}
 e1000_fcrtl_un;
static inline int e1000_fcrtl_prtval( char * s, size_t sz, e1000_fcrtl_t v ) __attribute__ ((always_inline));
static inline int e1000_fcrtl_prtval( char * s, size_t sz, e1000_fcrtl_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rtl=0x%0"PRIx16" (Recieve threshold low)\n", (uint16_t)(v.rtl));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " xone=0x%"PRIx8" (XON enable)\n", (uint8_t)(v.xone));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Flow control rx threshold high register
 */

/*
 * Dump of fields for register type: e1000_fcrth_t
 *   _anon0 (size 3, offset 0):	 MBZ	  _
 *   rth (size 13, offset 3):	 RW	  Recieve threshold high
 *   _anon16 (size 15, offset 16):	 MBZ	  _
 *   flowcntdis (size 1, offset 31):	 RW	  Flow control disable
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_fcrth_t {
    uint8_t	_anon0	:3;
    uint16_t	rth	:13;
    uint16_t	_anon16	:15;
    uint8_t	flowcntdis	:1;
} __attribute__ ((packed))
 e1000_fcrth_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_fcrth_t, sizeof(uint32_t));

typedef union e1000_fcrth_un {
    e1000_fcrth_t	val;
    uint32_t	raw;
}
 e1000_fcrth_un;
static inline int e1000_fcrth_prtval( char * s, size_t sz, e1000_fcrth_t v ) __attribute__ ((always_inline));
static inline int e1000_fcrth_prtval( char * s, size_t sz, e1000_fcrth_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rth=0x%0"PRIx16" (Recieve threshold high)\n", (uint16_t)(v.rth));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " flowcntdis=0x%"PRIx8" (Flow control disable)\n", (uint8_t)(v.flowcntdis));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Packet split rx control register
 */

/*
 * Dump of fields for register type: e1000_psrctl_t
 *   bsize0 (size 7, offset 0):	 RW	  Receive buffer 0 size (x 128 bytes)
 *   _anon7 (size 1, offset 7):	 MBZ	  _
 *   bsize1 (size 7, offset 8):	 RW	  Receive buffer 1 size (x 1 kbytes)
 *   _anon15 (size 1, offset 15):	 MBZ	  _
 *   bsize2 (size 7, offset 16):	 RW	  Receive buffer 2 size (x 1 kbytes)
 *   _anon23 (size 1, offset 23):	 MBZ	  _
 *   bsize3 (size 7, offset 24):	 RW	  Receive buffer 3 size (x 1 kbytes)
 *   _anon31 (size 1, offset 31):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_psrctl_t {
    uint8_t	bsize0	:7;
    uint8_t	_anon7	:1;
    uint8_t	bsize1	:7;
    uint8_t	_anon15	:1;
    uint8_t	bsize2	:7;
    uint8_t	_anon23	:1;
    uint8_t	bsize3	:7;
    uint8_t	_anon31	:1;
} __attribute__ ((packed))
 e1000_psrctl_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_psrctl_t, sizeof(uint32_t));

typedef union e1000_psrctl_un {
    e1000_psrctl_t	val;
    uint32_t	raw;
}
 e1000_psrctl_un;
static inline int e1000_psrctl_prtval( char * s, size_t sz, e1000_psrctl_t v ) __attribute__ ((always_inline));
static inline int e1000_psrctl_prtval( char * s, size_t sz, e1000_psrctl_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " bsize0=0x%"PRIx8" (Receive buffer 0 size (x 128 bytes))\n", (uint8_t)(v.bsize0));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " bsize1=0x%"PRIx8" (Receive buffer 1 size (x 1 kbytes))\n", (uint8_t)(v.bsize1));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " bsize2=0x%"PRIx8" (Receive buffer 2 size (x 1 kbytes))\n", (uint8_t)(v.bsize2));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " bsize3=0x%"PRIx8" (Receive buffer 3 size (x 1 kbytes))\n", (uint8_t)(v.bsize3));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Descriptor length value
 */

/*
 * Dump of fields for register type: e1000_dqlen_t
 *   _anon0 (size 7, offset 0):	 MBZ	  _
 *   len (size 13, offset 7):	 NOATTR	  Num. descriptors (x8)
 *   _anon20 (size 12, offset 20):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_dqlen_t {
    uint8_t	_anon0	:7;
    uint16_t	len	:13;
    uint16_t	_anon20	:12;
} __attribute__ ((packed))
 e1000_dqlen_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_dqlen_t, sizeof(uint32_t));

typedef union e1000_dqlen_un {
    e1000_dqlen_t	val;
    uint32_t	raw;
}
 e1000_dqlen_un;
static inline int e1000_dqlen_prtval( char * s, size_t sz, e1000_dqlen_t v ) __attribute__ ((always_inline));
static inline int e1000_dqlen_prtval( char * s, size_t sz, e1000_dqlen_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " len=0x%0"PRIx16" (Num. descriptors (x8))\n", (uint16_t)(v.len));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Descriptor head/tail value
 */

/*
 * Dump of fields for register type: e1000_dqval_t
 *   val (size 16, offset 0):	 NOATTR	  value
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_dqval_t {
    uint16_t	val	:16;
    uint16_t	_anon16	:16;
} __attribute__ ((packed))
 e1000_dqval_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_dqval_t, sizeof(uint32_t));

typedef union e1000_dqval_un {
    e1000_dqval_t	val;
    uint32_t	raw;
}
 e1000_dqval_un;
static inline int e1000_dqval_prtval( char * s, size_t sz, e1000_dqval_t v ) __attribute__ ((always_inline));
static inline int e1000_dqval_prtval( char * s, size_t sz, e1000_dqval_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " val=0x%0"PRIx16" (value)\n", (uint16_t)(v.val));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Rx. interrupt delay timer register
 */

/*
 * Dump of fields for register type: e1000_rdtr_t
 *   delay (size 16, offset 0):	 RW	  delay timer (x 1.024us)
 *   _anon16 (size 15, offset 16):	 MBZ	  _
 *   fpd (size 1, offset 31):	 RW	  Flush partial descriptor block
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_rdtr_t {
    uint16_t	delay	:16;
    uint16_t	_anon16	:15;
    uint8_t	fpd	:1;
} __attribute__ ((packed))
 e1000_rdtr_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_rdtr_t, sizeof(uint32_t));

typedef union e1000_rdtr_un {
    e1000_rdtr_t	val;
    uint32_t	raw;
}
 e1000_rdtr_un;
static inline int e1000_rdtr_prtval( char * s, size_t sz, e1000_rdtr_t v ) __attribute__ ((always_inline));
static inline int e1000_rdtr_prtval( char * s, size_t sz, e1000_rdtr_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " delay=0x%0"PRIx16" (delay timer (x 1.024us))\n", (uint16_t)(v.delay));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fpd=0x%"PRIx8" (Flush partial descriptor block)\n", (uint8_t)(v.fpd));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Rx descriptor control register array
 */

/*
 * Dump of fields for register type: e1000_rxdctl_t
 *   pthresh (size 6, offset 0):	 NOATTR	  Prefetch threshold
 *   _anon6 (size 2, offset 6):	 MBZ	  _
 *   hthresh (size 6, offset 8):	 NOATTR	  Host threshold
 *   _anon14 (size 2, offset 14):	 MBZ	  _
 *   wthresh (size 6, offset 16):	 NOATTR	  Write back threshold
 *   _anon22 (size 2, offset 22):	 MBZ	  _
 *   gran (size 1, offset 24):	 NOATTR	  Granularity
 *   _anon25 (size 7, offset 25):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_rxdctl_t {
    uint8_t	pthresh	:6;
    uint8_t	_anon6	:2;
    uint8_t	hthresh	:6;
    uint8_t	_anon14	:2;
    uint8_t	wthresh	:6;
    uint8_t	_anon22	:2;
    e1000_threshgran_t	gran	:1;
    uint8_t	_anon25	:7;
} __attribute__ ((packed))
 e1000_rxdctl_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_rxdctl_t, sizeof(uint32_t));

typedef union e1000_rxdctl_un {
    e1000_rxdctl_t	val;
    uint32_t	raw;
}
 e1000_rxdctl_un;
static inline int e1000_rxdctl_prtval( char * s, size_t sz, e1000_rxdctl_t v ) __attribute__ ((always_inline));
static inline int e1000_rxdctl_prtval( char * s, size_t sz, e1000_rxdctl_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pthresh=0x%"PRIx8" (Prefetch threshold)\n", (uint8_t)(v.pthresh));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " hthresh=0x%"PRIx8" (Host threshold)\n", (uint8_t)(v.hthresh));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wthresh=0x%"PRIx8" (Write back threshold)\n", (uint8_t)(v.wthresh));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " gran=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_threshgran_prt(s+r, _avail, v.gran);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Granularity)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Rx absolute intr. delay register
 */

/*
 * Dump of fields for register type: e1000_radv_t
 *   idv (size 16, offset 0):	 RW	  Interrupt delay value
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_radv_t {
    uint16_t	idv	:16;
    uint16_t	_anon16	:16;
} __attribute__ ((packed))
 e1000_radv_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_radv_t, sizeof(uint32_t));

typedef union e1000_radv_un {
    e1000_radv_t	val;
    uint32_t	raw;
}
 e1000_radv_un;
static inline int e1000_radv_prtval( char * s, size_t sz, e1000_radv_t v ) __attribute__ ((always_inline));
static inline int e1000_radv_prtval( char * s, size_t sz, e1000_radv_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " idv=0x%0"PRIx16" (Interrupt delay value)\n", (uint16_t)(v.idv));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Rx small packet detect interrupt register
 */

/*
 * Dump of fields for register type: e1000_rsrpd_t
 *   size (size 12, offset 0):	 RW	  Max size of small packet
 *   _anon12 (size 20, offset 12):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_rsrpd_t {
    uint16_t	size	:12;
    uint32_t	_anon12	:20;
} __attribute__ ((packed))
 e1000_rsrpd_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_rsrpd_t, sizeof(uint32_t));

typedef union e1000_rsrpd_un {
    e1000_rsrpd_t	val;
    uint32_t	raw;
}
 e1000_rsrpd_un;
static inline int e1000_rsrpd_prtval( char * s, size_t sz, e1000_rsrpd_t v ) __attribute__ ((always_inline));
static inline int e1000_rsrpd_prtval( char * s, size_t sz, e1000_rsrpd_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " size=0x%0"PRIx16" (Max size of small packet)\n", (uint16_t)(v.size));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Rx ACK interrupt delay register
 */

/*
 * Dump of fields for register type: e1000_raid_t
 *   idv (size 16, offset 0):	 RW	  Interrupt delay value (x 1.024us)
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_raid_t {
    uint16_t	idv	:16;
    uint16_t	_anon16	:16;
} __attribute__ ((packed))
 e1000_raid_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_raid_t, sizeof(uint32_t));

typedef union e1000_raid_un {
    e1000_raid_t	val;
    uint32_t	raw;
}
 e1000_raid_un;
static inline int e1000_raid_prtval( char * s, size_t sz, e1000_raid_t v ) __attribute__ ((always_inline));
static inline int e1000_raid_prtval( char * s, size_t sz, e1000_raid_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " idv=0x%0"PRIx16" (Interrupt delay value (x 1.024us))\n", (uint16_t)(v.idv));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Receive checksum control register
 */

/*
 * Dump of fields for register type: e1000_rxcsum_t
 *   pcss (size 8, offset 0):	 RW	  Packet checksum start
 *   ipofld (size 1, offset 8):	 RW	  IP checksum offload enable
 *   tuofld (size 1, offset 9):	 RW	  TCP/UDP checksum offload enable
 *   _anon10 (size 22, offset 10):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_rxcsum_t {
    uint8_t	pcss	:8;
    uint8_t	ipofld	:1;
    uint8_t	tuofld	:1;
    uint32_t	_anon10	:22;
} __attribute__ ((packed))
 e1000_rxcsum_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_rxcsum_t, sizeof(uint32_t));

typedef union e1000_rxcsum_un {
    e1000_rxcsum_t	val;
    uint32_t	raw;
}
 e1000_rxcsum_un;
static inline int e1000_rxcsum_prtval( char * s, size_t sz, e1000_rxcsum_t v ) __attribute__ ((always_inline));
static inline int e1000_rxcsum_prtval( char * s, size_t sz, e1000_rxcsum_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pcss=0x%"PRIx8" (Packet checksum start)\n", (uint8_t)(v.pcss));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ipofld=0x%"PRIx8" (IP checksum offload enable)\n", (uint8_t)(v.ipofld));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " tuofld=0x%"PRIx8" (TCP/UDP checksum offload enable)\n", (uint8_t)(v.tuofld));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Receive filter control register
 */

/*
 * Dump of fields for register type: e1000_rfctl_t
 *   iscsi_dis (size 1, offset 0):	 RW	  iSCSI filtering disable
 *   iscsi_dwc (size 5, offset 1):	 RW	  iSCSI dword count
 *   nfsw_dis (size 1, offset 6):	 RW	  NFS write filtering disable
 *   nfsr_dis (size 1, offset 7):	 RW	  NFS read filtering disable
 *   nfs_ver (size 2, offset 8):	 RW	  NFS version (+2)
 *   ipv6_dis (size 1, offset 10):	 RW	  IPv6 filtering disable
 *   ipv6xsum_dis (size 1, offset 11):	 RW	  IPv6 xsum disable
 *   ackdis (size 1, offset 12):	 RW	  ACK accelerator disable
 *   ackd_dis (size 1, offset 13):	 RW	  ACK data disable
 *   ipfrsp_dis (size 1, offset 14):	 RW	  IP fragment split disable
 *   exsten (size 1, offset 15):	 RW	  Extended status enable
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_rfctl_t {
    uint8_t	iscsi_dis	:1;
    uint8_t	iscsi_dwc	:5;
    uint8_t	nfsw_dis	:1;
    uint8_t	nfsr_dis	:1;
    uint8_t	nfs_ver	:2;
    uint8_t	ipv6_dis	:1;
    uint8_t	ipv6xsum_dis	:1;
    uint8_t	ackdis	:1;
    uint8_t	ackd_dis	:1;
    uint8_t	ipfrsp_dis	:1;
    uint8_t	exsten	:1;
    uint16_t	_anon16	:16;
} __attribute__ ((packed))
 e1000_rfctl_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_rfctl_t, sizeof(uint32_t));

typedef union e1000_rfctl_un {
    e1000_rfctl_t	val;
    uint32_t	raw;
}
 e1000_rfctl_un;
static inline int e1000_rfctl_prtval( char * s, size_t sz, e1000_rfctl_t v ) __attribute__ ((always_inline));
static inline int e1000_rfctl_prtval( char * s, size_t sz, e1000_rfctl_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " iscsi_dis=0x%"PRIx8" (iSCSI filtering disable)\n", (uint8_t)(v.iscsi_dis));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " iscsi_dwc=0x%"PRIx8" (iSCSI dword count)\n", (uint8_t)(v.iscsi_dwc));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " nfsw_dis=0x%"PRIx8" (NFS write filtering disable)\n", (uint8_t)(v.nfsw_dis));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " nfsr_dis=0x%"PRIx8" (NFS read filtering disable)\n", (uint8_t)(v.nfsr_dis));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " nfs_ver=0x%"PRIx8" (NFS version (+2))\n", (uint8_t)(v.nfs_ver));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ipv6_dis=0x%"PRIx8" (IPv6 filtering disable)\n", (uint8_t)(v.ipv6_dis));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ipv6xsum_dis=0x%"PRIx8" (IPv6 xsum disable)\n", (uint8_t)(v.ipv6xsum_dis));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ackdis=0x%"PRIx8" (ACK accelerator disable)\n", (uint8_t)(v.ackdis));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ackd_dis=0x%"PRIx8" (ACK data disable)\n", (uint8_t)(v.ackd_dis));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ipfrsp_dis=0x%"PRIx8" (IP fragment split disable)\n", (uint8_t)(v.ipfrsp_dis));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " exsten=0x%"PRIx8" (Extended status enable)\n", (uint8_t)(v.exsten));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Transmit control register
 */

/*
 * Dump of fields for register type: e1000_tctl_t
 *   _anon0 (size 1, offset 0):	 MBZ	  _
 *   en (size 1, offset 1):	 RW	  Transmit enable
 *   _anon2 (size 1, offset 2):	 MBZ	  _
 *   psp (size 1, offset 3):	 RW	  Pad short packets
 *   ct (size 8, offset 4):	 RW	  Collision threshold
 *   cold (size 10, offset 12):	 RW	  Collision distance
 *   swxoff (size 1, offset 22):	 RW	  Software XOFF transmission
 *   _anon23 (size 1, offset 23):	 MBZ	  _
 *   rtlc (size 1, offset 24):	 RW	  Retransmit on late collision
 *   unortx (size 1, offset 25):	 RW	  Underrun no re-transmit
 *   txcscmt (size 2, offset 26):	 RW	  Tx descriptor minimum threshold
 *   mulr (size 1, offset 28):	 RW	  Multiple request support
 *   _anon29 (size 3, offset 29):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_tctl_t {
    uint8_t	_anon0	:1;
    uint8_t	en	:1;
    uint8_t	_anon2	:1;
    uint8_t	psp	:1;
    uint8_t	ct	:8;
    e1000_coldist_t	cold	:10;
    uint8_t	swxoff	:1;
    uint8_t	_anon23	:1;
    uint8_t	rtlc	:1;
    uint8_t	unortx	:1;
    uint8_t	txcscmt	:2;
    uint8_t	mulr	:1;
    uint8_t	_anon29	:3;
} __attribute__ ((packed))
 e1000_tctl_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_tctl_t, sizeof(uint32_t));

typedef union e1000_tctl_un {
    e1000_tctl_t	val;
    uint32_t	raw;
}
 e1000_tctl_un;
static inline int e1000_tctl_prtval( char * s, size_t sz, e1000_tctl_t v ) __attribute__ ((always_inline));
static inline int e1000_tctl_prtval( char * s, size_t sz, e1000_tctl_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " en=0x%"PRIx8" (Transmit enable)\n", (uint8_t)(v.en));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " psp=0x%"PRIx8" (Pad short packets)\n", (uint8_t)(v.psp));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ct=0x%"PRIx8" (Collision threshold)\n", (uint8_t)(v.ct));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " cold=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_coldist_prt(s+r, _avail, v.cold);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Collision distance)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " swxoff=0x%"PRIx8" (Software XOFF transmission)\n", (uint8_t)(v.swxoff));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rtlc=0x%"PRIx8" (Retransmit on late collision)\n", (uint8_t)(v.rtlc));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " unortx=0x%"PRIx8" (Underrun no re-transmit)\n", (uint8_t)(v.unortx));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " txcscmt=0x%"PRIx8" (Tx descriptor minimum threshold)\n", (uint8_t)(v.txcscmt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mulr=0x%"PRIx8" (Multiple request support)\n", (uint8_t)(v.mulr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Transmit control extended register
 */

/*
 * Dump of fields for register type: e1000_tctl_ext_t
 *   _anon0 (size 10, offset 0):	 MBZ	  _
 *   cold (size 10, offset 10):	 RW	  Collision distance
 *   _anon20 (size 12, offset 20):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_tctl_ext_t {
    uint16_t	_anon0	:10;
    e1000_coldist_t	cold	:10;
    uint16_t	_anon20	:12;
} __attribute__ ((packed))
 e1000_tctl_ext_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_tctl_ext_t, sizeof(uint32_t));

typedef union e1000_tctl_ext_un {
    e1000_tctl_ext_t	val;
    uint32_t	raw;
}
 e1000_tctl_ext_un;
static inline int e1000_tctl_ext_prtval( char * s, size_t sz, e1000_tctl_ext_t v ) __attribute__ ((always_inline));
static inline int e1000_tctl_ext_prtval( char * s, size_t sz, e1000_tctl_ext_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " cold=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_coldist_prt(s+r, _avail, v.cold);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Collision distance)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Transmit IPQ register
 */

/*
 * Dump of fields for register type: e1000_tipg_t
 *   ipgt (size 10, offset 0):	 RW	  IPG back to back (x MAC clock, +4)
 *   ipgr1 (size 10, offset 10):	 RW	  IPG Part 1
 *   ipgr (size 10, offset 20):	 RW	  IPG after deferral
 *   _anon30 (size 2, offset 30):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_tipg_t {
    uint16_t	ipgt	:10;
    uint16_t	ipgr1	:10;
    uint16_t	ipgr	:10;
    uint8_t	_anon30	:2;
} __attribute__ ((packed))
 e1000_tipg_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_tipg_t, sizeof(uint32_t));

typedef union e1000_tipg_un {
    e1000_tipg_t	val;
    uint32_t	raw;
}
 e1000_tipg_un;
static inline int e1000_tipg_prtval( char * s, size_t sz, e1000_tipg_t v ) __attribute__ ((always_inline));
static inline int e1000_tipg_prtval( char * s, size_t sz, e1000_tipg_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ipgt=0x%0"PRIx16" (IPG back to back (x MAC clock, +4))\n", (uint16_t)(v.ipgt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ipgr1=0x%0"PRIx16" (IPG Part 1)\n", (uint16_t)(v.ipgr1));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ipgr=0x%0"PRIx16" (IPG after deferral)\n", (uint16_t)(v.ipgr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Transmit interrupt delay value register
 */

/*
 * Dump of fields for register type: e1000_tidv_t
 *   idv (size 16, offset 0):	 RW	  Interupt delay value
 *   _anon16 (size 15, offset 16):	 MBZ	  _
 *   fdp (size 1, offset 31):	 WO	  Flush partial description block
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_tidv_t {
    uint16_t	idv	:16;
    uint16_t	_anon16	:15;
    uint8_t	fdp	:1;
} __attribute__ ((packed))
 e1000_tidv_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_tidv_t, sizeof(uint32_t));

typedef union e1000_tidv_un {
    e1000_tidv_t	val;
    uint32_t	raw;
}
 e1000_tidv_un;
static inline int e1000_tidv_prtval( char * s, size_t sz, e1000_tidv_t v ) __attribute__ ((always_inline));
static inline int e1000_tidv_prtval( char * s, size_t sz, e1000_tidv_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " idv=0x%0"PRIx16" (Interupt delay value)\n", (uint16_t)(v.idv));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fdp=0x%"PRIx8" (Flush partial description block)\n", (uint8_t)(v.fdp));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Transmit descr. control queue register array
 */

/*
 * Dump of fields for register type: e1000_txdctl_t
 *   pthresh (size 6, offset 0):	 NOATTR	  Prefetch threshold
 *   _anon6 (size 2, offset 6):	 MBZ	  _
 *   hthresh (size 8, offset 8):	 NOATTR	  Host threshold
 *   wthresh (size 6, offset 16):	 NOATTR	  Write back threshold
 *   _anon22 (size 1, offset 22):	 MB1	  _
 *   _anon23 (size 1, offset 23):	 RSVD	  _
 *   gran (size 1, offset 24):	 NOATTR	  Granularity
 *   lwthresh (size 7, offset 25):	 NOATTR	  Transmit descriptor low threshold
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_txdctl_t {
    uint8_t	pthresh	:6;
    uint8_t	_anon6	:2;
    uint8_t	hthresh	:8;
    uint8_t	wthresh	:6;
    uint8_t	_anon22	:1;
    uint8_t	_anon23	:1;
    e1000_threshgran_t	gran	:1;
    uint8_t	lwthresh	:7;
} __attribute__ ((packed))
 e1000_txdctl_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_txdctl_t, sizeof(uint32_t));

typedef union e1000_txdctl_un {
    e1000_txdctl_t	val;
    uint32_t	raw;
}
 e1000_txdctl_un;
static inline int e1000_txdctl_prtval( char * s, size_t sz, e1000_txdctl_t v ) __attribute__ ((always_inline));
static inline int e1000_txdctl_prtval( char * s, size_t sz, e1000_txdctl_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pthresh=0x%"PRIx8" (Prefetch threshold)\n", (uint8_t)(v.pthresh));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " hthresh=0x%"PRIx8" (Host threshold)\n", (uint8_t)(v.hthresh));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wthresh=0x%"PRIx8" (Write back threshold)\n", (uint8_t)(v.wthresh));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " gran=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_threshgran_prt(s+r, _avail, v.gran);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Granularity)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " lwthresh=0x%"PRIx8" (Transmit descriptor low threshold)\n", (uint8_t)(v.lwthresh));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Tx absolute intr. delay register
 */

/*
 * Dump of fields for register type: e1000_tadv_t
 *   idv (size 16, offset 0):	 RW	  Interrupt delay value
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_tadv_t {
    uint16_t	idv	:16;
    uint16_t	_anon16	:16;
} __attribute__ ((packed))
 e1000_tadv_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_tadv_t, sizeof(uint32_t));

typedef union e1000_tadv_un {
    e1000_tadv_t	val;
    uint32_t	raw;
}
 e1000_tadv_un;
static inline int e1000_tadv_prtval( char * s, size_t sz, e1000_tadv_t v ) __attribute__ ((always_inline));
static inline int e1000_tadv_prtval( char * s, size_t sz, e1000_tadv_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " idv=0x%0"PRIx16" (Interrupt delay value)\n", (uint16_t)(v.idv));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Tx arbitration counter register array
 */

/*
 * Dump of fields for register type: e1000_tarc_t
 *   count (size 7, offset 0):	 NOATTR	  Transmit arbitration count
 *   _anon7 (size 1, offset 7):	 RSVD	  _
 *   ratio (size 2, offset 8):	 NOATTR	  Compensation ratio (1 / 2^val)
 *   enable (size 1, offset 10):	 MB1	  enable
 *   _anon11 (size 10, offset 11):	 MBZ	  _
 *   _anon21 (size 1, offset 21):	 MB1	  _
 *   _anon22 (size 1, offset 22):	 MBZ	  _
 *   _anon23 (size 4, offset 23):	 MB1	  _
 *   _anon27 (size 5, offset 27):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_tarc_t {
    uint8_t	count	:7;
    uint8_t	_anon7	:1;
    uint8_t	ratio	:2;
    uint8_t	enable	:1;
    uint16_t	_anon11	:10;
    uint8_t	_anon21	:1;
    uint8_t	_anon22	:1;
    uint8_t	_anon23	:4;
    uint8_t	_anon27	:5;
} __attribute__ ((packed))
 e1000_tarc_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_tarc_t, sizeof(uint32_t));

typedef union e1000_tarc_un {
    e1000_tarc_t	val;
    uint32_t	raw;
}
 e1000_tarc_un;
static inline int e1000_tarc_prtval( char * s, size_t sz, e1000_tarc_t v ) __attribute__ ((always_inline));
static inline int e1000_tarc_prtval( char * s, size_t sz, e1000_tarc_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " count=0x%"PRIx8" (Transmit arbitration count)\n", (uint8_t)(v.count));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ratio=0x%"PRIx8" (Compensation ratio (1 / 2^val))\n", (uint8_t)(v.ratio));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " enable=0x%"PRIx8" (enable)\n", (uint8_t)(v.enable));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Receive address high register array
 */

/*
 * Dump of fields for register type: e1000_rah_t
 *   rah (size 16, offset 0):	 NOATTR	  Receive address high
 *   asel (size 2, offset 16):	 NOATTR	  Address select
 *   _anon18 (size 13, offset 18):	 MBZ	  _
 *   av (size 1, offset 31):	 NOATTR	  Address valid
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_rah_t {
    uint16_t	rah	:16;
    e1000_addrsel_t	asel	:2;
    uint16_t	_anon18	:13;
    uint8_t	av	:1;
} __attribute__ ((packed))
 e1000_rah_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_rah_t, sizeof(uint32_t));

typedef union e1000_rah_un {
    e1000_rah_t	val;
    uint32_t	raw;
}
 e1000_rah_un;
static inline int e1000_rah_prtval( char * s, size_t sz, e1000_rah_t v ) __attribute__ ((always_inline));
static inline int e1000_rah_prtval( char * s, size_t sz, e1000_rah_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rah=0x%0"PRIx16" (Receive address high)\n", (uint16_t)(v.rah));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " asel=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_addrsel_prt(s+r, _avail, v.asel);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Address select)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " av=0x%"PRIx8" (Address valid)\n", (uint8_t)(v.av));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Multiple queues receive command register
 */

/*
 * Dump of fields for register type: e1000_mrq_t
 *   mrqe (size 2, offset 0):	 RW	  Multiple rx queues enable
 *   rssie (size 1, offset 2):	 RW	  RSS interrupt enable
 *   _anon3 (size 13, offset 3):	 MBZ	  _
 *   tcp4 (size 1, offset 16):	 RW	  Enable TCP IPv4 hash
 *   ipv4 (size 1, offset 17):	 RW	  Enable IPv4 hash
 *   tcp6ex (size 1, offset 18):	 RW	  Enable TCP IPv6 Ex hash
 *   ipv6ex (size 1, offset 19):	 RW	  Enable IPv6 Ex hash
 *   ipv6 (size 1, offset 20):	 RW	  Enable IPv6 hash
 *   _anon21 (size 11, offset 21):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_mrq_t {
    e1000_mrqen_t	mrqe	:2;
    uint8_t	rssie	:1;
    uint16_t	_anon3	:13;
    uint8_t	tcp4	:1;
    uint8_t	ipv4	:1;
    uint8_t	tcp6ex	:1;
    uint8_t	ipv6ex	:1;
    uint8_t	ipv6	:1;
    uint16_t	_anon21	:11;
} __attribute__ ((packed))
 e1000_mrq_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_mrq_t, sizeof(uint32_t));

typedef union e1000_mrq_un {
    e1000_mrq_t	val;
    uint32_t	raw;
}
 e1000_mrq_un;
static inline int e1000_mrq_prtval( char * s, size_t sz, e1000_mrq_t v ) __attribute__ ((always_inline));
static inline int e1000_mrq_prtval( char * s, size_t sz, e1000_mrq_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " mrqe=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_mrqen_prt(s+r, _avail, v.mrqe);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Multiple rx queues enable)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rssie=0x%"PRIx8" (RSS interrupt enable)\n", (uint8_t)(v.rssie));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " tcp4=0x%"PRIx8" (Enable TCP IPv4 hash)\n", (uint8_t)(v.tcp4));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ipv4=0x%"PRIx8" (Enable IPv4 hash)\n", (uint8_t)(v.ipv4));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " tcp6ex=0x%"PRIx8" (Enable TCP IPv6 Ex hash)\n", (uint8_t)(v.tcp6ex));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ipv6ex=0x%"PRIx8" (Enable IPv6 Ex hash)\n", (uint8_t)(v.ipv6ex));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ipv6=0x%"PRIx8" (Enable IPv6 hash)\n", (uint8_t)(v.ipv6));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Wakeup control register
 */

/*
 * Dump of fields for register type: e1000_wuc_t
 *   apme (size 1, offset 0):	 RW	  Advanced power mgmt enable
 *   pme_en (size 1, offset 1):	 RW	  PME enable
 *   pme_stat (size 1, offset 2):	 RW	  PME status
 *   apmpme (size 1, offset 3):	 RW	  Assert PME on APM wakeup
 *   _anon4 (size 28, offset 4):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_wuc_t {
    uint8_t	apme	:1;
    uint8_t	pme_en	:1;
    uint8_t	pme_stat	:1;
    uint8_t	apmpme	:1;
    uint32_t	_anon4	:28;
} __attribute__ ((packed))
 e1000_wuc_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_wuc_t, sizeof(uint32_t));

typedef union e1000_wuc_un {
    e1000_wuc_t	val;
    uint32_t	raw;
}
 e1000_wuc_un;
static inline int e1000_wuc_prtval( char * s, size_t sz, e1000_wuc_t v ) __attribute__ ((always_inline));
static inline int e1000_wuc_prtval( char * s, size_t sz, e1000_wuc_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " apme=0x%"PRIx8" (Advanced power mgmt enable)\n", (uint8_t)(v.apme));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pme_en=0x%"PRIx8" (PME enable)\n", (uint8_t)(v.pme_en));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pme_stat=0x%"PRIx8" (PME status)\n", (uint8_t)(v.pme_stat));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " apmpme=0x%"PRIx8" (Assert PME on APM wakeup)\n", (uint8_t)(v.apmpme));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Wakeup register
 */

/*
 * Dump of fields for register type: e1000_wakeup_t
 *   lnkc (size 1, offset 0):	 NOATTR	  Link status change
 *   mag (size 1, offset 1):	 NOATTR	  Magic packet
 *   ex (size 1, offset 2):	 NOATTR	  Directed exact
 *   mc (size 1, offset 3):	 NOATTR	  Directed multicast
 *   bc (size 1, offset 4):	 NOATTR	  Broadcast
 *   arp (size 1, offset 5):	 NOATTR	  ARP request packet
 *   ipv4 (size 1, offset 6):	 NOATTR	  Directed IPv4
 *   ipv6 (size 1, offset 7):	 NOATTR	  Directed IPv6
 *   _anon8 (size 7, offset 8):	 MBZ	  _
 *   notco (size 1, offset 15):	 NOATTR	  Ignore TCO/management packets
 *   flx0 (size 1, offset 16):	 NOATTR	  Flexible filter 0 enable
 *   flx1 (size 1, offset 17):	 NOATTR	  Flexible filter 1 enable
 *   flx2 (size 1, offset 18):	 NOATTR	  Flexible filter 2 enable
 *   flx3 (size 1, offset 19):	 NOATTR	  Flexible filter 3 enable
 *   _anon20 (size 12, offset 20):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_wakeup_t {
    uint8_t	lnkc	:1;
    uint8_t	mag	:1;
    uint8_t	ex	:1;
    uint8_t	mc	:1;
    uint8_t	bc	:1;
    uint8_t	arp	:1;
    uint8_t	ipv4	:1;
    uint8_t	ipv6	:1;
    uint8_t	_anon8	:7;
    uint8_t	notco	:1;
    uint8_t	flx0	:1;
    uint8_t	flx1	:1;
    uint8_t	flx2	:1;
    uint8_t	flx3	:1;
    uint16_t	_anon20	:12;
} __attribute__ ((packed))
 e1000_wakeup_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_wakeup_t, sizeof(uint32_t));

typedef union e1000_wakeup_un {
    e1000_wakeup_t	val;
    uint32_t	raw;
}
 e1000_wakeup_un;
static inline int e1000_wakeup_prtval( char * s, size_t sz, e1000_wakeup_t v ) __attribute__ ((always_inline));
static inline int e1000_wakeup_prtval( char * s, size_t sz, e1000_wakeup_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " lnkc=0x%"PRIx8" (Link status change)\n", (uint8_t)(v.lnkc));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mag=0x%"PRIx8" (Magic packet)\n", (uint8_t)(v.mag));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ex=0x%"PRIx8" (Directed exact)\n", (uint8_t)(v.ex));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mc=0x%"PRIx8" (Directed multicast)\n", (uint8_t)(v.mc));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " bc=0x%"PRIx8" (Broadcast)\n", (uint8_t)(v.bc));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " arp=0x%"PRIx8" (ARP request packet)\n", (uint8_t)(v.arp));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ipv4=0x%"PRIx8" (Directed IPv4)\n", (uint8_t)(v.ipv4));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ipv6=0x%"PRIx8" (Directed IPv6)\n", (uint8_t)(v.ipv6));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " notco=0x%"PRIx8" (Ignore TCO/management packets)\n", (uint8_t)(v.notco));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " flx0=0x%"PRIx8" (Flexible filter 0 enable)\n", (uint8_t)(v.flx0));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " flx1=0x%"PRIx8" (Flexible filter 1 enable)\n", (uint8_t)(v.flx1));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " flx2=0x%"PRIx8" (Flexible filter 2 enable)\n", (uint8_t)(v.flx2));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " flx3=0x%"PRIx8" (Flexible filter 3 enable)\n", (uint8_t)(v.flx3));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of IP address valid register
 */

/*
 * Dump of fields for register type: e1000_ipav_t
 *   v40 (size 1, offset 0):	 RW	  IPv4 address 0 valid
 *   v41 (size 1, offset 1):	 RW	  IPv4 address 1 valid
 *   v42 (size 1, offset 2):	 RW	  IPv4 address 2 valid
 *   v43 (size 1, offset 3):	 RW	  IPv4 address 3 valid
 *   _anon4 (size 12, offset 4):	 MBZ	  _
 *   v60 (size 1, offset 16):	 RW	  IPv6 address 0 valid
 *   _anon17 (size 15, offset 17):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_ipav_t {
    uint8_t	v40	:1;
    uint8_t	v41	:1;
    uint8_t	v42	:1;
    uint8_t	v43	:1;
    uint16_t	_anon4	:12;
    uint8_t	v60	:1;
    uint16_t	_anon17	:15;
} __attribute__ ((packed))
 e1000_ipav_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_ipav_t, sizeof(uint32_t));

typedef union e1000_ipav_un {
    e1000_ipav_t	val;
    uint32_t	raw;
}
 e1000_ipav_un;
static inline int e1000_ipav_prtval( char * s, size_t sz, e1000_ipav_t v ) __attribute__ ((always_inline));
static inline int e1000_ipav_prtval( char * s, size_t sz, e1000_ipav_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " v40=0x%"PRIx8" (IPv4 address 0 valid)\n", (uint8_t)(v.v40));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " v41=0x%"PRIx8" (IPv4 address 1 valid)\n", (uint8_t)(v.v41));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " v42=0x%"PRIx8" (IPv4 address 2 valid)\n", (uint8_t)(v.v42));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " v43=0x%"PRIx8" (IPv4 address 3 valid)\n", (uint8_t)(v.v43));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " v60=0x%"PRIx8" (IPv6 address 0 valid)\n", (uint8_t)(v.v60));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Wakeup packet length register
 */

/*
 * Dump of fields for register type: e1000_wupl_t
 *   len (size 12, offset 0):	 RW	  Length
 *   _anon12 (size 20, offset 12):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_wupl_t {
    uint16_t	len	:12;
    uint32_t	_anon12	:20;
} __attribute__ ((packed))
 e1000_wupl_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_wupl_t, sizeof(uint32_t));

typedef union e1000_wupl_un {
    e1000_wupl_t	val;
    uint32_t	raw;
}
 e1000_wupl_un;
static inline int e1000_wupl_prtval( char * s, size_t sz, e1000_wupl_t v ) __attribute__ ((always_inline));
static inline int e1000_wupl_prtval( char * s, size_t sz, e1000_wupl_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " len=0x%0"PRIx16" (Length)\n", (uint16_t)(v.len));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Flexible filter length table register array
 */

/*
 * Dump of fields for register type: e1000_fflt_t
 *   len (size 11, offset 0):	 NOATTR	  Length
 *   _anon11 (size 21, offset 11):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_fflt_t {
    uint16_t	len	:11;
    uint32_t	_anon11	:21;
} __attribute__ ((packed))
 e1000_fflt_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_fflt_t, sizeof(uint32_t));

typedef union e1000_fflt_un {
    e1000_fflt_t	val;
    uint32_t	raw;
}
 e1000_fflt_un;
static inline int e1000_fflt_prtval( char * s, size_t sz, e1000_fflt_t v ) __attribute__ ((always_inline));
static inline int e1000_fflt_prtval( char * s, size_t sz, e1000_fflt_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " len=0x%0"PRIx16" (Length)\n", (uint16_t)(v.len));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Flexible filter length table register array
 */

/*
 * Dump of fields for register type: e1000_ffltco_t
 *   tcolen (size 11, offset 0):	 NOATTR	  Length
 *   _anon11 (size 21, offset 11):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_ffltco_t {
    uint16_t	tcolen	:11;
    uint32_t	_anon11	:21;
} __attribute__ ((packed))
 e1000_ffltco_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_ffltco_t, sizeof(uint32_t));

typedef union e1000_ffltco_un {
    e1000_ffltco_t	val;
    uint32_t	raw;
}
 e1000_ffltco_un;
static inline int e1000_ffltco_prtval( char * s, size_t sz, e1000_ffltco_t v ) __attribute__ ((always_inline));
static inline int e1000_ffltco_prtval( char * s, size_t sz, e1000_ffltco_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " tcolen=0x%0"PRIx16" (Length)\n", (uint16_t)(v.tcolen));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Flexible filter mask table register array
 */

/*
 * Dump of fields for register type: e1000_ffmt_t
 *   mask (size 4, offset 0):	 NOATTR	  mask
 *   _anon4 (size 28, offset 4):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_ffmt_t {
    uint8_t	mask	:4;
    uint32_t	_anon4	:28;
} __attribute__ ((packed))
 e1000_ffmt_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_ffmt_t, sizeof(uint32_t));

typedef union e1000_ffmt_un {
    e1000_ffmt_t	val;
    uint32_t	raw;
}
 e1000_ffmt_un;
static inline int e1000_ffmt_prtval( char * s, size_t sz, e1000_ffmt_t v ) __attribute__ ((always_inline));
static inline int e1000_ffmt_prtval( char * s, size_t sz, e1000_ffmt_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mask=0x%"PRIx8" (mask)\n", (uint8_t)(v.mask));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Flexible filter value table register array
 */

/*
 * Dump of fields for register type: e1000_ffvt_t
 *   val0 (size 8, offset 0):	 NOATTR	  Value 0
 *   val1 (size 8, offset 8):	 NOATTR	  Value 1
 *   val2 (size 8, offset 16):	 NOATTR	  Value 2
 *   val3 (size 8, offset 24):	 NOATTR	  Value 3
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_ffvt_t {
    uint8_t	val0	:8;
    uint8_t	val1	:8;
    uint8_t	val2	:8;
    uint8_t	val3	:8;
} __attribute__ ((packed))
 e1000_ffvt_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_ffvt_t, sizeof(uint32_t));

typedef union e1000_ffvt_un {
    e1000_ffvt_t	val;
    uint32_t	raw;
}
 e1000_ffvt_un;
static inline int e1000_ffvt_prtval( char * s, size_t sz, e1000_ffvt_t v ) __attribute__ ((always_inline));
static inline int e1000_ffvt_prtval( char * s, size_t sz, e1000_ffvt_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " val0=0x%"PRIx8" (Value 0)\n", (uint8_t)(v.val0));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " val1=0x%"PRIx8" (Value 1)\n", (uint8_t)(v.val1));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " val2=0x%"PRIx8" (Value 2)\n", (uint8_t)(v.val2));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " val3=0x%"PRIx8" (Value 3)\n", (uint8_t)(v.val3));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Management control register
 */

/*
 * Dump of fields for register type: e1000_manc_t
 *   _anon0 (size 3, offset 0):	 MBZ	  _
 *   en_flexport0 (size 1, offset 3):	 RW	  Enable flex UDP/TCP port 0 filtering
 *   en_flexport1 (size 1, offset 4):	 RW	  Enable flex UDP/TCP port 1 filtering
 *   en_flexport2 (size 1, offset 5):	 RW	  Enable flex UDP/TCP port 2 filtering
 *   flex_tco1_filter (size 1, offset 6):	 RW	  Enable TCO filter 1
 *   flex_tco0_filter (size 1, offset 7):	 RW	  Enable TCO filter 0
 *   rmcp_en (size 1, offset 8):	 RW	  Enable RMCP 0x026f filtering
 *   o298_en (size 1, offset 9):	 RW	  Enable RMCP 0x0298 filtering
 *   _anon10 (size 3, offset 10):	 MBZ	  _
 *   arp_req_en (size 1, offset 13):	 RW	  Enable ARP request filtering
 *   neighbor_en (size 1, offset 14):	 RW	  Enable neighbor discovery filtering
 *   arp_res_en (size 1, offset 15):	 RW	  Enable ARP response filtering
 *   tco_reset (size 1, offset 16):	 RW	  TCO reset occurred
 *   rcv_tco_en (size 1, offset 17):	 RW	  Receive TCO packets enable
 *   blk_phyrst_on_ide (size 1, offset 18):	 RW	  Block PHY reset and power on state changes
 *   rcv_all (size 1, offset 19):	 RW	  Receive all enable
 *   en_mac16_filter (size 1, offset 20):	 RW	  Enable MAC address 16 filtering
 *   en_mng2host (size 1, offset 21):	 RW	  Enable firmware packets to host memory
 *   en_ip_addrfilter (size 1, offset 22):	 RW	  Enable IP address filtering
 *   en_xsum_filter (size 1, offset 23):	 RW	  Enable Xsum filtering to firmware
 *   br_en (size 1, offset 24):	 RW	  Enable broadcast filtering
 *   _anon25 (size 7, offset 25):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_manc_t {
    uint8_t	_anon0	:3;
    uint8_t	en_flexport0	:1;
    uint8_t	en_flexport1	:1;
    uint8_t	en_flexport2	:1;
    uint8_t	flex_tco1_filter	:1;
    uint8_t	flex_tco0_filter	:1;
    uint8_t	rmcp_en	:1;
    uint8_t	o298_en	:1;
    uint8_t	_anon10	:3;
    uint8_t	arp_req_en	:1;
    uint8_t	neighbor_en	:1;
    uint8_t	arp_res_en	:1;
    uint8_t	tco_reset	:1;
    uint8_t	rcv_tco_en	:1;
    uint8_t	blk_phyrst_on_ide	:1;
    uint8_t	rcv_all	:1;
    uint8_t	en_mac16_filter	:1;
    uint8_t	en_mng2host	:1;
    uint8_t	en_ip_addrfilter	:1;
    uint8_t	en_xsum_filter	:1;
    uint8_t	br_en	:1;
    uint8_t	_anon25	:7;
} __attribute__ ((packed))
 e1000_manc_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_manc_t, sizeof(uint32_t));

typedef union e1000_manc_un {
    e1000_manc_t	val;
    uint32_t	raw;
}
 e1000_manc_un;
static inline int e1000_manc_prtval( char * s, size_t sz, e1000_manc_t v ) __attribute__ ((always_inline));
static inline int e1000_manc_prtval( char * s, size_t sz, e1000_manc_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " en_flexport0=0x%"PRIx8" (Enable flex UDP/TCP port 0 filtering)\n", (uint8_t)(v.en_flexport0));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " en_flexport1=0x%"PRIx8" (Enable flex UDP/TCP port 1 filtering)\n", (uint8_t)(v.en_flexport1));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " en_flexport2=0x%"PRIx8" (Enable flex UDP/TCP port 2 filtering)\n", (uint8_t)(v.en_flexport2));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " flex_tco1_filter=0x%"PRIx8" (Enable TCO filter 1)\n", (uint8_t)(v.flex_tco1_filter));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " flex_tco0_filter=0x%"PRIx8" (Enable TCO filter 0)\n", (uint8_t)(v.flex_tco0_filter));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rmcp_en=0x%"PRIx8" (Enable RMCP 0x026f filtering)\n", (uint8_t)(v.rmcp_en));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " o298_en=0x%"PRIx8" (Enable RMCP 0x0298 filtering)\n", (uint8_t)(v.o298_en));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " arp_req_en=0x%"PRIx8" (Enable ARP request filtering)\n", (uint8_t)(v.arp_req_en));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " neighbor_en=0x%"PRIx8" (Enable neighbor discovery filtering)\n", (uint8_t)(v.neighbor_en));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " arp_res_en=0x%"PRIx8" (Enable ARP response filtering)\n", (uint8_t)(v.arp_res_en));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " tco_reset=0x%"PRIx8" (TCO reset occurred)\n", (uint8_t)(v.tco_reset));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rcv_tco_en=0x%"PRIx8" (Receive TCO packets enable)\n", (uint8_t)(v.rcv_tco_en));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " blk_phyrst_on_ide=0x%"PRIx8" (Block PHY reset and power on state changes)\n", (uint8_t)(v.blk_phyrst_on_ide));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rcv_all=0x%"PRIx8" (Receive all enable)\n", (uint8_t)(v.rcv_all));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " en_mac16_filter=0x%"PRIx8" (Enable MAC address 16 filtering)\n", (uint8_t)(v.en_mac16_filter));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " en_mng2host=0x%"PRIx8" (Enable firmware packets to host memory)\n", (uint8_t)(v.en_mng2host));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " en_ip_addrfilter=0x%"PRIx8" (Enable IP address filtering)\n", (uint8_t)(v.en_ip_addrfilter));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " en_xsum_filter=0x%"PRIx8" (Enable Xsum filtering to firmware)\n", (uint8_t)(v.en_xsum_filter));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " br_en=0x%"PRIx8" (Enable broadcast filtering)\n", (uint8_t)(v.br_en));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of PCIe control register
 */

/*
 * Dump of fields for register type: e1000_gcr_t
 *   rxd_nosnoop (size 1, offset 0):	 RW	  Receive data write
 *   rxdscw_nosnoop (size 1, offset 1):	 RW	  Receive descriptor write
 *   rxdscr_nosnoop (size 1, offset 2):	 RW	  Receive descriptor read
 *   txd_nosnoop (size 1, offset 3):	 RW	  Transmit data write
 *   txdscw_nosnoop (size 1, offset 4):	 RW	  Transmit descriptor write
 *   txdscr_nosnoop (size 1, offset 5):	 RW	  Transmit descriptor read
 *   elec_idle_in0 (size 1, offset 6):	 RO	  SerDes0 internal electrical idle indicator
 *   elec_idle_in1 (size 1, offset 7):	 RO	  SerDes1 internal electrical idle indicator
 *   self_test_enable (size 1, offset 8):	 RW	  Perform self test
 *   _anon9 (size 12, offset 9):	 MBZ	  _
 *   logheader (size 1, offset 21):	 RW	  Log header into PCI config space
 *   _anon22 (size 1, offset 22):	 MBZ	  _
 *   l1el_msb (size 1, offset 23):	 RO	  L1 Entry latency msb
 *   l0s_el (size 1, offset 24):	 RW	  L0s entry latency
 *   l1el_lsb (size 2, offset 25):	 RO	  L1 Entry latency lsbs
 *   l1_aw_l0s (size 1, offset 27):	 RW	  L1 act without L0s_rx correlation
 *   gio_dis_rderr (size 1, offset 28):	 RW	  Disable running disparity err
 *   gio_good_10s (size 1, offset 29):	 RW	  Force good PCIe l0s training
 *   self_test_result (size 1, offset 30):	 RW	  Result of self test
 *   dis_tmout (size 1, offset 31):	 RW	  Disable PCIe timeout mechanism
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_gcr_t {
    uint8_t	rxd_nosnoop	:1;
    uint8_t	rxdscw_nosnoop	:1;
    uint8_t	rxdscr_nosnoop	:1;
    uint8_t	txd_nosnoop	:1;
    uint8_t	txdscw_nosnoop	:1;
    uint8_t	txdscr_nosnoop	:1;
    uint8_t	elec_idle_in0	:1;
    uint8_t	elec_idle_in1	:1;
    uint8_t	self_test_enable	:1;
    uint16_t	_anon9	:12;
    uint8_t	logheader	:1;
    uint8_t	_anon22	:1;
    uint8_t	l1el_msb	:1;
    uint8_t	l0s_el	:1;
    uint8_t	l1el_lsb	:2;
    uint8_t	l1_aw_l0s	:1;
    uint8_t	gio_dis_rderr	:1;
    uint8_t	gio_good_10s	:1;
    uint8_t	self_test_result	:1;
    uint8_t	dis_tmout	:1;
} __attribute__ ((packed))
 e1000_gcr_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_gcr_t, sizeof(uint32_t));

typedef union e1000_gcr_un {
    e1000_gcr_t	val;
    uint32_t	raw;
}
 e1000_gcr_un;
static inline int e1000_gcr_prtval( char * s, size_t sz, e1000_gcr_t v ) __attribute__ ((always_inline));
static inline int e1000_gcr_prtval( char * s, size_t sz, e1000_gcr_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rxd_nosnoop=0x%"PRIx8" (Receive data write)\n", (uint8_t)(v.rxd_nosnoop));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rxdscw_nosnoop=0x%"PRIx8" (Receive descriptor write)\n", (uint8_t)(v.rxdscw_nosnoop));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rxdscr_nosnoop=0x%"PRIx8" (Receive descriptor read)\n", (uint8_t)(v.rxdscr_nosnoop));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " txd_nosnoop=0x%"PRIx8" (Transmit data write)\n", (uint8_t)(v.txd_nosnoop));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " txdscw_nosnoop=0x%"PRIx8" (Transmit descriptor write)\n", (uint8_t)(v.txdscw_nosnoop));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " txdscr_nosnoop=0x%"PRIx8" (Transmit descriptor read)\n", (uint8_t)(v.txdscr_nosnoop));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " elec_idle_in0=0x%"PRIx8" (SerDes0 internal electrical idle indicator)\n", (uint8_t)(v.elec_idle_in0));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " elec_idle_in1=0x%"PRIx8" (SerDes1 internal electrical idle indicator)\n", (uint8_t)(v.elec_idle_in1));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " self_test_enable=0x%"PRIx8" (Perform self test)\n", (uint8_t)(v.self_test_enable));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " logheader=0x%"PRIx8" (Log header into PCI config space)\n", (uint8_t)(v.logheader));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " l1el_msb=0x%"PRIx8" (L1 Entry latency msb)\n", (uint8_t)(v.l1el_msb));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " l0s_el=0x%"PRIx8" (L0s entry latency)\n", (uint8_t)(v.l0s_el));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " l1el_lsb=0x%"PRIx8" (L1 Entry latency lsbs)\n", (uint8_t)(v.l1el_lsb));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " l1_aw_l0s=0x%"PRIx8" (L1 act without L0s_rx correlation)\n", (uint8_t)(v.l1_aw_l0s));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " gio_dis_rderr=0x%"PRIx8" (Disable running disparity err)\n", (uint8_t)(v.gio_dis_rderr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " gio_good_10s=0x%"PRIx8" (Force good PCIe l0s training)\n", (uint8_t)(v.gio_good_10s));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " self_test_result=0x%"PRIx8" (Result of self test)\n", (uint8_t)(v.self_test_result));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " dis_tmout=0x%"PRIx8" (Disable PCIe timeout mechanism)\n", (uint8_t)(v.dis_tmout));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of PCIe statistics control 1 register
 */

/*
 * Dump of fields for register type: e1000_gscl1_t
 *   count_en0 (size 1, offset 0):	 RW	  Enable PCIe stats counter 0
 *   count_en1 (size 1, offset 1):	 RW	  Enable PCIe stats counter 1
 *   count_en2 (size 1, offset 2):	 RW	  Enable PCIe stats counter 2
 *   count_en3 (size 1, offset 3):	 RW	  Enable PCIe stats counter 3
 *   _anon4 (size 23, offset 4):	 RSVD	  _
 *   count_test (size 1, offset 27):	 RW	  Test bit
 *   en_64bit (size 1, offset 28):	 RW	  Enable two 64-bit counters instead of 4 32-bit
 *   count_reset (size 1, offset 29):	 RW	  Reset indication of PCIe stats
 *   count_stop (size 1, offset 30):	 RW	  Stop indication
 *   count_start (size 1, offset 31):	 RW	  Start indication
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_gscl1_t {
    uint8_t	count_en0	:1;
    uint8_t	count_en1	:1;
    uint8_t	count_en2	:1;
    uint8_t	count_en3	:1;
    uint32_t	_anon4	:23;
    uint8_t	count_test	:1;
    uint8_t	en_64bit	:1;
    uint8_t	count_reset	:1;
    uint8_t	count_stop	:1;
    uint8_t	count_start	:1;
} __attribute__ ((packed))
 e1000_gscl1_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_gscl1_t, sizeof(uint32_t));

typedef union e1000_gscl1_un {
    e1000_gscl1_t	val;
    uint32_t	raw;
}
 e1000_gscl1_un;
static inline int e1000_gscl1_prtval( char * s, size_t sz, e1000_gscl1_t v ) __attribute__ ((always_inline));
static inline int e1000_gscl1_prtval( char * s, size_t sz, e1000_gscl1_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " count_en0=0x%"PRIx8" (Enable PCIe stats counter 0)\n", (uint8_t)(v.count_en0));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " count_en1=0x%"PRIx8" (Enable PCIe stats counter 1)\n", (uint8_t)(v.count_en1));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " count_en2=0x%"PRIx8" (Enable PCIe stats counter 2)\n", (uint8_t)(v.count_en2));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " count_en3=0x%"PRIx8" (Enable PCIe stats counter 3)\n", (uint8_t)(v.count_en3));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " count_test=0x%"PRIx8" (Test bit)\n", (uint8_t)(v.count_test));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " en_64bit=0x%"PRIx8" (Enable two 64-bit counters instead of 4 32-bit)\n", (uint8_t)(v.en_64bit));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " count_reset=0x%"PRIx8" (Reset indication of PCIe stats)\n", (uint8_t)(v.count_reset));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " count_stop=0x%"PRIx8" (Stop indication)\n", (uint8_t)(v.count_stop));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " count_start=0x%"PRIx8" (Start indication)\n", (uint8_t)(v.count_start));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of PCIe statistics control 2 register
 */

/*
 * Dump of fields for register type: e1000_gscl2_t
 *   event0 (size 8, offset 0):	 RW	  Event number that counter 0 counts
 *   event1 (size 8, offset 8):	 RW	  Event number that counter 1 counts
 *   event2 (size 8, offset 16):	 RW	  Event number that counter 2 counts
 *   event3 (size 8, offset 24):	 RW	  Event number that counter 3 counts
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_gscl2_t {
    uint8_t	event0	:8;
    uint8_t	event1	:8;
    uint8_t	event2	:8;
    uint8_t	event3	:8;
} __attribute__ ((packed))
 e1000_gscl2_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_gscl2_t, sizeof(uint32_t));

typedef union e1000_gscl2_un {
    e1000_gscl2_t	val;
    uint32_t	raw;
}
 e1000_gscl2_un;
static inline int e1000_gscl2_prtval( char * s, size_t sz, e1000_gscl2_t v ) __attribute__ ((always_inline));
static inline int e1000_gscl2_prtval( char * s, size_t sz, e1000_gscl2_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " event0=0x%"PRIx8" (Event number that counter 0 counts)\n", (uint8_t)(v.event0));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " event1=0x%"PRIx8" (Event number that counter 1 counts)\n", (uint8_t)(v.event1));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " event2=0x%"PRIx8" (Event number that counter 2 counts)\n", (uint8_t)(v.event2));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " event3=0x%"PRIx8" (Event number that counter 3 counts)\n", (uint8_t)(v.event3));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of PCIe statistics control 3 register
 */

/*
 * Dump of fields for register type: e1000_gscl3_t
 *   fc_th0 (size 12, offset 0):	 RW	  Threshold of flow control credits 0
 *   _anon12 (size 4, offset 12):	 RSVD	  _
 *   fc_th1 (size 12, offset 16):	 RW	  Threshold of flow control credits 1
 *   _anon28 (size 4, offset 28):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_gscl3_t {
    uint16_t	fc_th0	:12;
    uint8_t	_anon12	:4;
    uint16_t	fc_th1	:12;
    uint8_t	_anon28	:4;
} __attribute__ ((packed))
 e1000_gscl3_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_gscl3_t, sizeof(uint32_t));

typedef union e1000_gscl3_un {
    e1000_gscl3_t	val;
    uint32_t	raw;
}
 e1000_gscl3_un;
static inline int e1000_gscl3_prtval( char * s, size_t sz, e1000_gscl3_t v ) __attribute__ ((always_inline));
static inline int e1000_gscl3_prtval( char * s, size_t sz, e1000_gscl3_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fc_th0=0x%0"PRIx16" (Threshold of flow control credits 0)\n", (uint16_t)(v.fc_th0));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fc_th1=0x%0"PRIx16" (Threshold of flow control credits 1)\n", (uint16_t)(v.fc_th1));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of PCIe statistics control 4 register
 */

/*
 * Dump of fields for register type: e1000_gscl4_t
 *   coml_th (size 10, offset 0):	 RW	  Completions latency threshold
 *   rb_th (size 6, offset 10):	 RW	  Retry buffer threshold
 *   _anon16 (size 16, offset 16):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_gscl4_t {
    uint16_t	coml_th	:10;
    uint8_t	rb_th	:6;
    uint16_t	_anon16	:16;
} __attribute__ ((packed))
 e1000_gscl4_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_gscl4_t, sizeof(uint32_t));

typedef union e1000_gscl4_un {
    e1000_gscl4_t	val;
    uint32_t	raw;
}
 e1000_gscl4_un;
static inline int e1000_gscl4_prtval( char * s, size_t sz, e1000_gscl4_t v ) __attribute__ ((always_inline));
static inline int e1000_gscl4_prtval( char * s, size_t sz, e1000_gscl4_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " coml_th=0x%0"PRIx16" (Completions latency threshold)\n", (uint16_t)(v.coml_th));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rb_th=0x%"PRIx8" (Retry buffer threshold)\n", (uint8_t)(v.rb_th));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Fn. active & power state to MNG register
 */

/*
 * Dump of fields for register type: e1000_factps_t
 *   f0ps (size 2, offset 0):	 RO	  Power state of fn. 0
 *   lan0v (size 1, offset 2):	 RO	  LAN 0 valid enable
 *   f0aux (size 1, offset 3):	 RO	  Fn. 0 aux power enable shadow
 *   lan0en (size 1, offset 4):	 RO	  LAN 0 enabled
 *   _anon5 (size 1, offset 5):	 RSVD	  _
 *   f1ps (size 2, offset 6):	 RO	  Power state of fn. 1
 *   lan1v (size 1, offset 8):	 RO	  LAN 1 valid enable
 *   f1aux (size 1, offset 9):	 RO	  Fn. 1 aux power enable shadow
 *   lan1en (size 1, offset 10):	 RO	  LAN 1 enabled
 *   _anon11 (size 1, offset 11):	 RSVD	  _
 *   f2ps (size 2, offset 12):	 RO	  Power state of fn. 2
 *   ide_en (size 1, offset 14):	 RO	  IDE (function 2) enable
 *   f2aux (size 1, offset 15):	 RO	  Fn. 2 aux power enable shadow
 *   _anon16 (size 2, offset 16):	 RSVD	  _
 *   f3ps (size 2, offset 18):	 RO	  Power state of fn. 3
 *   sp_en (size 1, offset 20):	 RO	  SP (function 3) enable
 *   f3aux (size 1, offset 21):	 RO	  Fn. 3 aux power enable shadow
 *   _anon22 (size 2, offset 22):	 RSVD	  _
 *   f4ps (size 2, offset 24):	 RO	  Power state of fn. 4
 *   ipmi_en (size 1, offset 26):	 RO	  IPMI (function 4) enable
 *   f4aux (size 1, offset 27):	 RO	  Fn. 4 aux power enable shadow
 *   _anon28 (size 1, offset 28):	 RSVD	  _
 *   mngcg (size 1, offset 29):	 RO	  MNG clock gated
 *   lanfs (size 1, offset 30):	 RO	  LAN function select
 *   pmchg (size 1, offset 31):	 RO	  PM state changed
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_factps_t {
    e1000_fps_t	f0ps	:2;
    uint8_t	lan0v	:1;
    uint8_t	f0aux	:1;
    uint8_t	lan0en	:1;
    uint8_t	_anon5	:1;
    e1000_fps_t	f1ps	:2;
    uint8_t	lan1v	:1;
    uint8_t	f1aux	:1;
    uint8_t	lan1en	:1;
    uint8_t	_anon11	:1;
    e1000_fps_t	f2ps	:2;
    uint8_t	ide_en	:1;
    uint8_t	f2aux	:1;
    uint8_t	_anon16	:2;
    e1000_fps_t	f3ps	:2;
    uint8_t	sp_en	:1;
    uint8_t	f3aux	:1;
    uint8_t	_anon22	:2;
    e1000_fps_t	f4ps	:2;
    uint8_t	ipmi_en	:1;
    uint8_t	f4aux	:1;
    uint8_t	_anon28	:1;
    uint8_t	mngcg	:1;
    uint8_t	lanfs	:1;
    uint8_t	pmchg	:1;
} __attribute__ ((packed))
 e1000_factps_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_factps_t, sizeof(uint32_t));

typedef union e1000_factps_un {
    e1000_factps_t	val;
    uint32_t	raw;
}
 e1000_factps_un;
static inline int e1000_factps_prtval( char * s, size_t sz, e1000_factps_t v ) __attribute__ ((always_inline));
static inline int e1000_factps_prtval( char * s, size_t sz, e1000_factps_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " f0ps=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_fps_prt(s+r, _avail, v.f0ps);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Power state of fn. 0)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " lan0v=0x%"PRIx8" (LAN 0 valid enable)\n", (uint8_t)(v.lan0v));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " f0aux=0x%"PRIx8" (Fn. 0 aux power enable shadow)\n", (uint8_t)(v.f0aux));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " lan0en=0x%"PRIx8" (LAN 0 enabled)\n", (uint8_t)(v.lan0en));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " f1ps=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_fps_prt(s+r, _avail, v.f1ps);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Power state of fn. 1)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " lan1v=0x%"PRIx8" (LAN 1 valid enable)\n", (uint8_t)(v.lan1v));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " f1aux=0x%"PRIx8" (Fn. 1 aux power enable shadow)\n", (uint8_t)(v.f1aux));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " lan1en=0x%"PRIx8" (LAN 1 enabled)\n", (uint8_t)(v.lan1en));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " f2ps=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_fps_prt(s+r, _avail, v.f2ps);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Power state of fn. 2)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ide_en=0x%"PRIx8" (IDE (function 2) enable)\n", (uint8_t)(v.ide_en));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " f2aux=0x%"PRIx8" (Fn. 2 aux power enable shadow)\n", (uint8_t)(v.f2aux));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " f3ps=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_fps_prt(s+r, _avail, v.f3ps);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Power state of fn. 3)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sp_en=0x%"PRIx8" (SP (function 3) enable)\n", (uint8_t)(v.sp_en));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " f3aux=0x%"PRIx8" (Fn. 3 aux power enable shadow)\n", (uint8_t)(v.f3aux));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " f4ps=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_fps_prt(s+r, _avail, v.f4ps);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Power state of fn. 4)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ipmi_en=0x%"PRIx8" (IPMI (function 4) enable)\n", (uint8_t)(v.ipmi_en));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " f4aux=0x%"PRIx8" (Fn. 4 aux power enable shadow)\n", (uint8_t)(v.f4aux));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mngcg=0x%"PRIx8" (MNG clock gated)\n", (uint8_t)(v.mngcg));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " lanfs=0x%"PRIx8" (LAN function select)\n", (uint8_t)(v.lanfs));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pmchg=0x%"PRIx8" (PM state changed)\n", (uint8_t)(v.pmchg));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Analog circuit configuration
 */

/*
 * Dump of fields for register type: e1000_anal_ctl_t
 *   data (size 8, offset 0):	 NOATTR	  Data to SerDes
 *   address (size 8, offset 8):	 NOATTR	  Address to SerDes
 *   _anon16 (size 15, offset 16):	 RSVD	  _
 *   done (size 1, offset 31):	 NOATTR	  Done indicator
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_anal_ctl_t {
    uint8_t	data	:8;
    uint8_t	address	:8;
    uint16_t	_anon16	:15;
    uint8_t	done	:1;
} __attribute__ ((packed))
 e1000_anal_ctl_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_anal_ctl_t, sizeof(uint32_t));

typedef union e1000_anal_ctl_un {
    e1000_anal_ctl_t	val;
    uint32_t	raw;
}
 e1000_anal_ctl_un;
static inline int e1000_anal_ctl_prtval( char * s, size_t sz, e1000_anal_ctl_t v ) __attribute__ ((always_inline));
static inline int e1000_anal_ctl_prtval( char * s, size_t sz, e1000_anal_ctl_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " data=0x%"PRIx8" (Data to SerDes)\n", (uint8_t)(v.data));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " address=0x%"PRIx8" (Address to SerDes)\n", (uint8_t)(v.address));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " done=0x%"PRIx8" (Done indicator)\n", (uint8_t)(v.done));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Analog control register
 */

/*
 * Dump of fields for register type: e1000_anactl_t
 *   data (size 8, offset 0):	 RW	  Data to/from analog register
 *   address (size 8, offset 8):	 RW	  Address of analog register
 *   _anon16 (size 14, offset 16):	 RSVD	  _
 *   write (size 1, offset 30):	 RW	  Read/write command
 *   done (size 1, offset 31):	 RW	  Done indication
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_anactl_t {
    uint8_t	data	:8;
    uint8_t	address	:8;
    uint16_t	_anon16	:14;
    uint8_t	write	:1;
    uint8_t	done	:1;
} __attribute__ ((packed))
 e1000_anactl_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_anactl_t, sizeof(uint32_t));

typedef union e1000_anactl_un {
    e1000_anactl_t	val;
    uint32_t	raw;
}
 e1000_anactl_un;
static inline int e1000_anactl_prtval( char * s, size_t sz, e1000_anactl_t v ) __attribute__ ((always_inline));
static inline int e1000_anactl_prtval( char * s, size_t sz, e1000_anactl_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " data=0x%"PRIx8" (Data to/from analog register)\n", (uint8_t)(v.data));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " address=0x%"PRIx8" (Address of analog register)\n", (uint8_t)(v.address));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " write=0x%"PRIx8" (Read/write command)\n", (uint8_t)(v.write));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " done=0x%"PRIx8" (Done indication)\n", (uint8_t)(v.done));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Software semaphore register
 */

/*
 * Dump of fields for register type: e1000_swsm_t
 *   smbi (size 1, offset 0):	 RW	  Semaphore bit
 *   swesmbi (size 1, offset 1):	 RW	  Software EEPROM semaphore bit
 *   wmng (size 1, offset 2):	 RW	  Wake MNG clock
 *   _anon3 (size 29, offset 3):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_swsm_t {
    uint8_t	smbi	:1;
    uint8_t	swesmbi	:1;
    uint8_t	wmng	:1;
    uint32_t	_anon3	:29;
} __attribute__ ((packed))
 e1000_swsm_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_swsm_t, sizeof(uint32_t));

typedef union e1000_swsm_un {
    e1000_swsm_t	val;
    uint32_t	raw;
}
 e1000_swsm_un;
static inline int e1000_swsm_prtval( char * s, size_t sz, e1000_swsm_t v ) __attribute__ ((always_inline));
static inline int e1000_swsm_prtval( char * s, size_t sz, e1000_swsm_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " smbi=0x%"PRIx8" (Semaphore bit)\n", (uint8_t)(v.smbi));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " swesmbi=0x%"PRIx8" (Software EEPROM semaphore bit)\n", (uint8_t)(v.swesmbi));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wmng=0x%"PRIx8" (Wake MNG clock)\n", (uint8_t)(v.wmng));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Firmware semaphore register
 */

/*
 * Dump of fields for register type: e1000_fwsm_t
 *   eep_fw (size 1, offset 0):	 RW	  EEPROM firmware semaphore
 *   fw_mode (size 3, offset 1):	 RW	  Firmware mode
 *   ide_on (size 1, offset 4):	 RW	  IDE redirection on
 *   sol_on (size 1, offset 5):	 RW	  SOL on
 *   eep_rl (size 1, offset 6):	 RW	  EEPROM reloaded indication
 *   _anon7 (size 8, offset 7):	 RSVD	  _
 *   fwval (size 1, offset 15):	 RW	  Firmware valid bit
 *   rstcnt (size 3, offset 16):	 RW	  Reset counter
 *   error (size 6, offset 19):	 RW	  External error indication
 *   _anon25 (size 7, offset 25):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct e1000_fwsm_t {
    uint8_t	eep_fw	:1;
    e1000_fwmode_t	fw_mode	:3;
    uint8_t	ide_on	:1;
    uint8_t	sol_on	:1;
    uint8_t	eep_rl	:1;
    uint8_t	_anon7	:8;
    uint8_t	fwval	:1;
    uint8_t	rstcnt	:3;
    e1000_pcierr_t	error	:6;
    uint8_t	_anon25	:7;
} __attribute__ ((packed))
 e1000_fwsm_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(e1000_fwsm_t, sizeof(uint32_t));

typedef union e1000_fwsm_un {
    e1000_fwsm_t	val;
    uint32_t	raw;
}
 e1000_fwsm_un;
static inline int e1000_fwsm_prtval( char * s, size_t sz, e1000_fwsm_t v ) __attribute__ ((always_inline));
static inline int e1000_fwsm_prtval( char * s, size_t sz, e1000_fwsm_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " eep_fw=0x%"PRIx8" (EEPROM firmware semaphore)\n", (uint8_t)(v.eep_fw));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " fw_mode=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_fwmode_prt(s+r, _avail, v.fw_mode);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Firmware mode)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ide_on=0x%"PRIx8" (IDE redirection on)\n", (uint8_t)(v.ide_on));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sol_on=0x%"PRIx8" (SOL on)\n", (uint8_t)(v.sol_on));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " eep_rl=0x%"PRIx8" (EEPROM reloaded indication)\n", (uint8_t)(v.eep_rl));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fwval=0x%"PRIx8" (Firmware valid bit)\n", (uint8_t)(v.fwval));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rstcnt=0x%"PRIx8" (Reset counter)\n", (uint8_t)(v.rstcnt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " error=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = e1000_pcierr_prt(s+r, _avail, v.error);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (External error indication)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Device representation structure
 */
typedef struct __DN(t) {
    // Device arguments
    mackerel_addr_t	base;
    // Shadow registers
    e1000_intreg_un	ics_shadow;
    e1000_intreg_un	imc_shadow;
    e1000_tidv_un	tidv_shadow;
}
 __DN(t);

/*
 * Device Initialization function
 */
static inline void __DN(initialize)( __DN(t) * _dev, mackerel_addr_t base ) __attribute__ ((always_inline));
static inline void __DN(initialize)( __DN(t) * _dev, mackerel_addr_t base )
{
    /* Setting up device arguments*/
    _dev->base = base;
    /* Setting up shadow registers*/
    _dev->ics_shadow.raw = 0x0;
    _dev->imc_shadow.raw = 0x0;
    _dev->tidv_shadow.raw = 0x0;
}

// No user-defined spaces

/*
 * Register ctrl (Device control); type e1000.ctrl (Implicit type of Device control register)
 */

/*
 * Dump of fields for register: ctrl
 *   fd (size 1, offset 0):	 RW	  full-duplex
 *   _anon1 (size 1, offset 1):	 MBZ	  _
 *   gio_md (size 1, offset 2):	 RW	  GIO master disable
 *   lrst (size 1, offset 3):	 RW	  Link reset
 *   _anon4 (size 2, offset 4):	 MBZ	  _
 *   slu (size 1, offset 6):	 RW	  Set link up
 *   _anon7 (size 1, offset 7):	 MBZ	  _
 *   speed (size 2, offset 8):	 RW	  Speed selection
 *   _anon10 (size 1, offset 10):	 MBZ	  _
 *   frcspd (size 1, offset 11):	 RW	  Force speed
 *   frcdplx (size 1, offset 12):	 RW	  Force duplex
 *   _anon13 (size 5, offset 13):	 MBZ	  _
 *   sdp0_data (size 1, offset 18):	 RW	  SDP0 data value, or dock/undock status
 *   sdp1_data (size 1, offset 19):	 RW	  SDP1 data value
 *   advd3wuc (size 1, offset 20):	 RW	  D3cold wakeup capability
 *   _anon21 (size 1, offset 21):	 MBZ	  _
 *   sdp0_iodir (size 1, offset 22):	 RW	  SDP0 pin I/O directionality
 *   sdp1_iodir (size 1, offset 23):	 RW	  SDP1 pin I/O directionality
 *   _anon24 (size 2, offset 24):	 MBZ	  _
 *   rst (size 1, offset 26):	 RW	  Device reset
 *   rfce (size 1, offset 27):	 RW	  Receive flow control enable
 *   tfce (size 1, offset 28):	 RW	  Transmit flow control enable
 *   _anon29 (size 1, offset 29):	 MBZ	  _
 *   vme (size 1, offset 30):	 RW	  VLAN mode enable
 *   phy_rst (size 1, offset 31):	 RW	  PHY reset
 */

static inline uint32_t __DP(ctrl_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ctrl_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x0));
}

static inline e1000_ctrl_t __DP(ctrl_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_ctrl_t __DP(ctrl_rd)( __DN(t) * _dev )
{
    e1000_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    return u.val;
}

static inline void __DP(ctrl_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrl_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x0),val);
}

static inline void __DP(ctrl_wr)( __DN(t) * _dev, e1000_ctrl_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrl_wr)( __DN(t) * _dev, e1000_ctrl_t val )
{
    e1000_ctrl_un  u;
    u.val = val;
    u.val._anon1 	= 0;
    u.val._anon4 	= 0;
    u.val._anon7 	= 0;
    u.val._anon10 	= 0;
    u.val._anon13 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon29 	= 0;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(ctrl_fd_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrl_fd_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val._anon1 	= 0;
    u.val._anon4 	= 0;
    u.val._anon7 	= 0;
    u.val._anon10 	= 0;
    u.val._anon13 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon29 	= 0;
    u.val.fd = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(ctrl_gio_md_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrl_gio_md_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val._anon1 	= 0;
    u.val._anon4 	= 0;
    u.val._anon7 	= 0;
    u.val._anon10 	= 0;
    u.val._anon13 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon29 	= 0;
    u.val.gio_md = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(ctrl_lrst_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrl_lrst_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val._anon1 	= 0;
    u.val._anon4 	= 0;
    u.val._anon7 	= 0;
    u.val._anon10 	= 0;
    u.val._anon13 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon29 	= 0;
    u.val.lrst = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(ctrl_slu_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrl_slu_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val._anon1 	= 0;
    u.val._anon4 	= 0;
    u.val._anon7 	= 0;
    u.val._anon10 	= 0;
    u.val._anon13 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon29 	= 0;
    u.val.slu = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(ctrl_speed_wrf)( __DN(t) * _dev, e1000_linkspeed_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrl_speed_wrf)( __DN(t) * _dev, e1000_linkspeed_t val )
{
    e1000_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val._anon1 	= 0;
    u.val._anon4 	= 0;
    u.val._anon7 	= 0;
    u.val._anon10 	= 0;
    u.val._anon13 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon29 	= 0;
    u.val.speed = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(ctrl_frcspd_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrl_frcspd_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val._anon1 	= 0;
    u.val._anon4 	= 0;
    u.val._anon7 	= 0;
    u.val._anon10 	= 0;
    u.val._anon13 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon29 	= 0;
    u.val.frcspd = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(ctrl_frcdplx_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrl_frcdplx_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val._anon1 	= 0;
    u.val._anon4 	= 0;
    u.val._anon7 	= 0;
    u.val._anon10 	= 0;
    u.val._anon13 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon29 	= 0;
    u.val.frcdplx = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(ctrl_sdp0_data_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrl_sdp0_data_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val._anon1 	= 0;
    u.val._anon4 	= 0;
    u.val._anon7 	= 0;
    u.val._anon10 	= 0;
    u.val._anon13 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon29 	= 0;
    u.val.sdp0_data = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(ctrl_sdp1_data_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrl_sdp1_data_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val._anon1 	= 0;
    u.val._anon4 	= 0;
    u.val._anon7 	= 0;
    u.val._anon10 	= 0;
    u.val._anon13 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon29 	= 0;
    u.val.sdp1_data = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(ctrl_advd3wuc_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrl_advd3wuc_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val._anon1 	= 0;
    u.val._anon4 	= 0;
    u.val._anon7 	= 0;
    u.val._anon10 	= 0;
    u.val._anon13 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon29 	= 0;
    u.val.advd3wuc = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(ctrl_sdp0_iodir_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrl_sdp0_iodir_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val._anon1 	= 0;
    u.val._anon4 	= 0;
    u.val._anon7 	= 0;
    u.val._anon10 	= 0;
    u.val._anon13 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon29 	= 0;
    u.val.sdp0_iodir = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(ctrl_sdp1_iodir_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrl_sdp1_iodir_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val._anon1 	= 0;
    u.val._anon4 	= 0;
    u.val._anon7 	= 0;
    u.val._anon10 	= 0;
    u.val._anon13 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon29 	= 0;
    u.val.sdp1_iodir = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(ctrl_rst_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrl_rst_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val._anon1 	= 0;
    u.val._anon4 	= 0;
    u.val._anon7 	= 0;
    u.val._anon10 	= 0;
    u.val._anon13 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon29 	= 0;
    u.val.rst = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(ctrl_rfce_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrl_rfce_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val._anon1 	= 0;
    u.val._anon4 	= 0;
    u.val._anon7 	= 0;
    u.val._anon10 	= 0;
    u.val._anon13 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon29 	= 0;
    u.val.rfce = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(ctrl_tfce_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrl_tfce_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val._anon1 	= 0;
    u.val._anon4 	= 0;
    u.val._anon7 	= 0;
    u.val._anon10 	= 0;
    u.val._anon13 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon29 	= 0;
    u.val.tfce = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(ctrl_vme_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrl_vme_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val._anon1 	= 0;
    u.val._anon4 	= 0;
    u.val._anon7 	= 0;
    u.val._anon10 	= 0;
    u.val._anon13 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon29 	= 0;
    u.val.vme = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(ctrl_phy_rst_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrl_phy_rst_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val._anon1 	= 0;
    u.val._anon4 	= 0;
    u.val._anon7 	= 0;
    u.val._anon10 	= 0;
    u.val._anon13 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon29 	= 0;
    u.val.phy_rst = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}


static inline int __DP(ctrl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ctrl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ctrl (Device control):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.fd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fd =\t0x%"PRIx8" (full-duplex", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.gio_md;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " gio_md =\t0x%"PRIx8" (GIO master disable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.lrst;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lrst =\t0x%"PRIx8" (Link reset", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.slu;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " slu =\t0x%"PRIx8" (Set link up", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.speed;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " speed =\t0x%"PRIx8" (Speed selection", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_linkspeed_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.frcspd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " frcspd =\t0x%"PRIx8" (Force speed", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.frcdplx;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " frcdplx =\t0x%"PRIx8" (Force duplex", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.sdp0_data;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sdp0_data =\t0x%"PRIx8" (SDP0 data value, or dock/undock status", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sdp1_data;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sdp1_data =\t0x%"PRIx8" (SDP1 data value", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.advd3wuc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " advd3wuc =\t0x%"PRIx8" (D3cold wakeup capability", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.sdp0_iodir;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sdp0_iodir =\t0x%"PRIx8" (SDP0 pin I/O directionality", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sdp1_iodir;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sdp1_iodir =\t0x%"PRIx8" (SDP1 pin I/O directionality", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.rst;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rst =\t0x%"PRIx8" (Device reset", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rfce;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rfce =\t0x%"PRIx8" (Receive flow control enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.tfce;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tfce =\t0x%"PRIx8" (Transmit flow control enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.vme;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vme =\t0x%"PRIx8" (VLAN mode enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.phy_rst;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " phy_rst =\t0x%"PRIx8" (PHY reset", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register status (Device status); type e1000.status (Implicit type of Device status register)
 */

/*
 * Dump of fields for register: status
 *   fd (size 1, offset 0):	 RW	  Link full duplex configuration
 *   lu (size 1, offset 1):	 RW	  Link up
 *   lan_id (size 2, offset 2):	 RW	  LAN ID
 *   txoff (size 1, offset 4):	 RW	  Transmission paused
 *   tbimode (size 1, offset 5):	 RW	  TBI mode
 *   speed (size 2, offset 6):	 RW	  Link speed setting
 *   asdv (size 2, offset 8):	 RW	  Auto speed detection value
 *   phyra (size 1, offset 10):	 RW	  PHY reset asserted
 *   _anon11 (size 8, offset 11):	 MBZ	  _
 *   gio_mes (size 1, offset 19):	 RW	  GIO master enable status
 *   _anon20 (size 12, offset 20):	 RSVD	  _
 */

static inline uint32_t __DP(status_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(status_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x8));
}

static inline e1000_status_t __DP(status_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_status_t __DP(status_rd)( __DN(t) * _dev )
{
    e1000_status_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    return u.val;
}

static inline void __DP(status_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(status_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x8),val);
}

static inline void __DP(status_wr)( __DN(t) * _dev, e1000_status_t val ) __attribute__ ((always_inline));
static inline void __DP(status_wr)( __DN(t) * _dev, e1000_status_t val )
{
    e1000_status_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.fd 	= val.fd;
    u.val.lu 	= val.lu;
    u.val.lan_id 	= val.lan_id;
    u.val.txoff 	= val.txoff;
    u.val.tbimode 	= val.tbimode;
    u.val.speed 	= val.speed;
    u.val.asdv 	= val.asdv;
    u.val.phyra 	= val.phyra;
    u.val._anon11 	= val._anon11;
    u.val.gio_mes 	= val.gio_mes;
    u.val._anon11 	= 0;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(status_fd_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(status_fd_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_status_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val._anon11 	= 0;
    u.val.fd = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(status_lu_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(status_lu_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_status_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val._anon11 	= 0;
    u.val.lu = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(status_lan_id_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(status_lan_id_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_status_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val._anon11 	= 0;
    u.val.lan_id = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(status_txoff_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(status_txoff_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_status_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val._anon11 	= 0;
    u.val.txoff = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(status_tbimode_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(status_tbimode_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_status_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val._anon11 	= 0;
    u.val.tbimode = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(status_speed_wrf)( __DN(t) * _dev, e1000_linkspeed_t val ) __attribute__ ((always_inline));
static inline void __DP(status_speed_wrf)( __DN(t) * _dev, e1000_linkspeed_t val )
{
    e1000_status_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val._anon11 	= 0;
    u.val.speed = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(status_asdv_wrf)( __DN(t) * _dev, e1000_linkspeed_t val ) __attribute__ ((always_inline));
static inline void __DP(status_asdv_wrf)( __DN(t) * _dev, e1000_linkspeed_t val )
{
    e1000_status_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val._anon11 	= 0;
    u.val.asdv = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(status_phyra_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(status_phyra_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_status_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val._anon11 	= 0;
    u.val.phyra = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(status_gio_mes_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(status_gio_mes_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_status_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val._anon11 	= 0;
    u.val.gio_mes = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}


static inline int __DP(status_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(status_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_status_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register status (Device status):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.fd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fd =\t0x%"PRIx8" (Link full duplex configuration", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.lu;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lu =\t0x%"PRIx8" (Link up", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.lan_id;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lan_id =\t0x%"PRIx8" (LAN ID", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.txoff;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txoff =\t0x%"PRIx8" (Transmission paused", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.tbimode;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tbimode =\t0x%"PRIx8" (TBI mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.speed;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " speed =\t0x%"PRIx8" (Link speed setting", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_linkspeed_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.asdv;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " asdv =\t0x%"PRIx8" (Auto speed detection value", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_linkspeed_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.phyra;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " phyra =\t0x%"PRIx8" (PHY reset asserted", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.gio_mes;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " gio_mes =\t0x%"PRIx8" (GIO master enable status", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eec (EEPROM/Flash control); type e1000.eec (Implicit type of EEPROM/Flash control register)
 */

/*
 * Dump of fields for register: eec
 *   ee_sk (size 1, offset 0):	 RW	  Clock input to EEPROM
 *   ee_cs (size 1, offset 1):	 RW	  Chip select to EEPROM
 *   ee_di (size 1, offset 2):	 RW	  Data input to EEPROM
 *   ee_do (size 1, offset 3):	 RW	  Data output bit from EEPROM
 *   fwe (size 2, offset 4):	 RW	  Flash write enable control
 *   ee_req (size 1, offset 6):	 RW	  Request EEPROM access
 *   ee_gnt (size 1, offset 7):	 RW	  Grant EEPROM access
 *   ee_pres (size 1, offset 8):	 RW	  EEPROM present
 *   auto_rd (size 1, offset 9):	 RW	  EEPROM auto read done
 *   ee_addr_sz (size 1, offset 10):	 RW	  EEPROM address size
 *   ee_size (size 4, offset 11):	 RW	  EEPROM size (x128 bytes)
 *   nvadds (size 2, offset 15):	 RW	  NVM address size in bytes
 *   _anon17 (size 3, offset 17):	 RSVD	  _
 *   aupden (size 1, offset 20):	 RW	  Enable automatic Flash update
 *   _anon21 (size 2, offset 21):	 RSVD	  _
 *   nvmtype (size 2, offset 23):	 RO	  NVM type
 *   _anon25 (size 7, offset 25):	 RSVD	  _
 */

static inline uint32_t __DP(eec_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eec_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x10));
}

static inline e1000_eec_t __DP(eec_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_eec_t __DP(eec_rd)( __DN(t) * _dev )
{
    e1000_eec_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x10));
    return u.val;
}

static inline void __DP(eec_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eec_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x10),val);
}

static inline void __DP(eec_wr)( __DN(t) * _dev, e1000_eec_t val ) __attribute__ ((always_inline));
static inline void __DP(eec_wr)( __DN(t) * _dev, e1000_eec_t val )
{
    e1000_eec_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x10));
    u.val.ee_sk 	= val.ee_sk;
    u.val.ee_cs 	= val.ee_cs;
    u.val.ee_di 	= val.ee_di;
    u.val.ee_do 	= val.ee_do;
    u.val.fwe 	= val.fwe;
    u.val.ee_req 	= val.ee_req;
    u.val.ee_gnt 	= val.ee_gnt;
    u.val.ee_pres 	= val.ee_pres;
    u.val.auto_rd 	= val.auto_rd;
    u.val.ee_addr_sz 	= val.ee_addr_sz;
    u.val.ee_size 	= val.ee_size;
    u.val.nvadds 	= val.nvadds;
    u.val.aupden 	= val.aupden;
    u.val.nvmtype 	= val.nvmtype;
    mackerel_write_addr_32(_dev->base,(0x10),u.raw);
}

static inline void __DP(eec_ee_sk_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eec_ee_sk_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_eec_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x10));
    u.val.ee_sk = val;
    mackerel_write_addr_32(_dev->base,(0x10),u.raw);
}

static inline void __DP(eec_ee_cs_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eec_ee_cs_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_eec_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x10));
    u.val.ee_cs = val;
    mackerel_write_addr_32(_dev->base,(0x10),u.raw);
}

static inline void __DP(eec_ee_di_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eec_ee_di_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_eec_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x10));
    u.val.ee_di = val;
    mackerel_write_addr_32(_dev->base,(0x10),u.raw);
}

static inline void __DP(eec_ee_do_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eec_ee_do_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_eec_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x10));
    u.val.ee_do = val;
    mackerel_write_addr_32(_dev->base,(0x10),u.raw);
}

static inline void __DP(eec_fwe_wrf)( __DN(t) * _dev, e1000_flashenable_t val ) __attribute__ ((always_inline));
static inline void __DP(eec_fwe_wrf)( __DN(t) * _dev, e1000_flashenable_t val )
{
    e1000_eec_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x10));
    u.val.fwe = val;
    mackerel_write_addr_32(_dev->base,(0x10),u.raw);
}

static inline void __DP(eec_ee_req_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eec_ee_req_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_eec_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x10));
    u.val.ee_req = val;
    mackerel_write_addr_32(_dev->base,(0x10),u.raw);
}

static inline void __DP(eec_ee_gnt_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eec_ee_gnt_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_eec_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x10));
    u.val.ee_gnt = val;
    mackerel_write_addr_32(_dev->base,(0x10),u.raw);
}

static inline void __DP(eec_ee_pres_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eec_ee_pres_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_eec_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x10));
    u.val.ee_pres = val;
    mackerel_write_addr_32(_dev->base,(0x10),u.raw);
}

static inline void __DP(eec_auto_rd_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eec_auto_rd_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_eec_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x10));
    u.val.auto_rd = val;
    mackerel_write_addr_32(_dev->base,(0x10),u.raw);
}

static inline void __DP(eec_ee_addr_sz_wrf)( __DN(t) * _dev, e1000_eeaddrsize_t val ) __attribute__ ((always_inline));
static inline void __DP(eec_ee_addr_sz_wrf)( __DN(t) * _dev, e1000_eeaddrsize_t val )
{
    e1000_eec_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x10));
    u.val.ee_addr_sz = val;
    mackerel_write_addr_32(_dev->base,(0x10),u.raw);
}

static inline void __DP(eec_ee_size_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eec_ee_size_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_eec_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x10));
    u.val.ee_size = val;
    mackerel_write_addr_32(_dev->base,(0x10),u.raw);
}

static inline void __DP(eec_nvadds_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eec_nvadds_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_eec_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x10));
    u.val.nvadds = val;
    mackerel_write_addr_32(_dev->base,(0x10),u.raw);
}

static inline void __DP(eec_aupden_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eec_aupden_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_eec_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x10));
    u.val.aupden = val;
    mackerel_write_addr_32(_dev->base,(0x10),u.raw);
}


static inline int __DP(eec_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eec_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_eec_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x10));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eec (EEPROM/Flash control):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.ee_sk;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ee_sk =\t0x%"PRIx8" (Clock input to EEPROM", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ee_cs;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ee_cs =\t0x%"PRIx8" (Chip select to EEPROM", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ee_di;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ee_di =\t0x%"PRIx8" (Data input to EEPROM", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ee_do;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ee_do =\t0x%"PRIx8" (Data output bit from EEPROM", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.fwe;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fwe =\t0x%"PRIx8" (Flash write enable control", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_flashenable_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ee_req;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ee_req =\t0x%"PRIx8" (Request EEPROM access", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ee_gnt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ee_gnt =\t0x%"PRIx8" (Grant EEPROM access", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ee_pres;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ee_pres =\t0x%"PRIx8" (EEPROM present", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.auto_rd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " auto_rd =\t0x%"PRIx8" (EEPROM auto read done", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ee_addr_sz;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ee_addr_sz =\t0x%"PRIx8" (EEPROM address size", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_eeaddrsize_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ee_size;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ee_size =\t0x%"PRIx8" (EEPROM size (x128 bytes)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.nvadds;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " nvadds =\t0x%"PRIx8" (NVM address size in bytes", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.aupden;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " aupden =\t0x%"PRIx8" (Enable automatic Flash update", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.nvmtype;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " nvmtype =\t0x%"PRIx8" (NVM type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_nvmtype_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eerd (EEPROM read); type e1000.eerd (Implicit type of EEPROM read register)
 */

/*
 * Dump of fields for register: eerd
 *   start (size 1, offset 0):	 RW	  Start read
 *   done (size 1, offset 1):	 RO	  Read done
 *   addr (size 14, offset 2):	 RW	  Read address
 *   data (size 16, offset 16):	 RW	  Read data
 */

static inline uint32_t __DP(eerd_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eerd_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x14));
}

static inline e1000_eerd_t __DP(eerd_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_eerd_t __DP(eerd_rd)( __DN(t) * _dev )
{
    e1000_eerd_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x14));
    return u.val;
}

static inline void __DP(eerd_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eerd_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x14),val);
}

static inline void __DP(eerd_wr)( __DN(t) * _dev, e1000_eerd_t val ) __attribute__ ((always_inline));
static inline void __DP(eerd_wr)( __DN(t) * _dev, e1000_eerd_t val )
{
    e1000_eerd_un  u;
    u.val = val;
    mackerel_write_addr_32(_dev->base,(0x14),u.raw);
}

static inline void __DP(eerd_start_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eerd_start_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_eerd_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x14));
    u.val.start = val;
    mackerel_write_addr_32(_dev->base,(0x14),u.raw);
}

static inline void __DP(eerd_addr_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eerd_addr_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_eerd_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x14));
    u.val.addr = val;
    mackerel_write_addr_32(_dev->base,(0x14),u.raw);
}

static inline void __DP(eerd_data_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eerd_data_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_eerd_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x14));
    u.val.data = val;
    mackerel_write_addr_32(_dev->base,(0x14),u.raw);
}


static inline int __DP(eerd_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eerd_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_eerd_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x14));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eerd (EEPROM read):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.start;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " start =\t0x%"PRIx8" (Start read", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.done;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " done =\t0x%"PRIx8" (Read done", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint16_t pv = (uint16_t)u.val.addr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " addr =\t0x%0"PRIx16" (Read address", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint16_t pv = (uint16_t)u.val.data;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " data =\t0x%0"PRIx16" (Read data", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register ctrlext (Extended device control); type e1000.ctrlext (Implicit type of Extended device control register)
 */

/*
 * Dump of fields for register: ctrlext
 *   _anon0 (size 2, offset 0):	 MBZ	  _
 *   sdp2_gpien (size 1, offset 2):	 RW	  General-purpose interrupt detection for SDP2
 *   sdp3_gpien (size 1, offset 3):	 RW	  General-purpose interrupt detection for SDP3
 *   _anon4 (size 2, offset 4):	 RSVD	  _
 *   sdp2_data (size 1, offset 6):	 RW	  SDP2 data value
 *   sdp3_data (size 1, offset 7):	 RW	  SDP3 data value
 *   _anon8 (size 2, offset 8):	 MBZ	  _
 *   sdp2_iodir (size 1, offset 10):	 RW	  SDP2 pin directionality
 *   sdp3_iodir (size 1, offset 11):	 RW	  SDP3 pin directionality
 *   asdchk (size 1, offset 12):	 RW	  Auto-speed-detection check
 *   ee_rst (size 1, offset 13):	 RW	  EEPROM reset
 *   _anon14 (size 1, offset 14):	 MBZ	  _
 *   spd_byps (size 1, offset 15):	 RW	  Speed select bypass
 *   _anon16 (size 1, offset 16):	 RSVD	  _
 *   rodis (size 1, offset 17):	 RW	  Relaxed ordering disabled
 *   serdeslpe (size 1, offset 18):	 RW	  SERDES low power enable
 *   dmadge (size 1, offset 19):	 RW	  DMA dynamic gating enable
 *   phypde (size 1, offset 20):	 RW	  PHY power down enable
 *   _anon21 (size 1, offset 21):	 RSVD	  _
 *   link_mode (size 2, offset 22):	 RW	  Link mode
 *   pb_paren (size 1, offset 24):	 RW	  Packet buffer parity error detection enable
 *   df_paren (size 1, offset 25):	 RW	  Descriptor FIFO parity error detection enable
 *   _anon26 (size 1, offset 26):	 MBZ	  _
 *   iame (size 1, offset 27):	 RW	  Interrupt acknowledge auto-mask enable
 *   drv_load (size 1, offset 28):	 RW	  Driver loaded
 *   int_tca (size 1, offset 29):	 RW	  Timers clear enable
 *   host_paren (size 1, offset 30):	 RW	  Host data FIFO parity enable
 *   _anon31 (size 1, offset 31):	 RSVD	  _
 */

static inline uint32_t __DP(ctrlext_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ctrlext_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x18));
}

static inline e1000_ctrlext_t __DP(ctrlext_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_ctrlext_t __DP(ctrlext_rd)( __DN(t) * _dev )
{
    e1000_ctrlext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x18));
    return u.val;
}

static inline void __DP(ctrlext_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrlext_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x18),val);
}

static inline void __DP(ctrlext_wr)( __DN(t) * _dev, e1000_ctrlext_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrlext_wr)( __DN(t) * _dev, e1000_ctrlext_t val )
{
    e1000_ctrlext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x18));
    u.val._anon0 	= val._anon0;
    u.val.sdp2_gpien 	= val.sdp2_gpien;
    u.val.sdp3_gpien 	= val.sdp3_gpien;
    u.val.sdp2_data 	= val.sdp2_data;
    u.val.sdp3_data 	= val.sdp3_data;
    u.val._anon8 	= val._anon8;
    u.val.sdp2_iodir 	= val.sdp2_iodir;
    u.val.sdp3_iodir 	= val.sdp3_iodir;
    u.val.asdchk 	= val.asdchk;
    u.val.ee_rst 	= val.ee_rst;
    u.val._anon14 	= val._anon14;
    u.val.spd_byps 	= val.spd_byps;
    u.val.rodis 	= val.rodis;
    u.val.serdeslpe 	= val.serdeslpe;
    u.val.dmadge 	= val.dmadge;
    u.val.phypde 	= val.phypde;
    u.val.link_mode 	= val.link_mode;
    u.val.pb_paren 	= val.pb_paren;
    u.val.df_paren 	= val.df_paren;
    u.val._anon26 	= val._anon26;
    u.val.iame 	= val.iame;
    u.val.drv_load 	= val.drv_load;
    u.val.int_tca 	= val.int_tca;
    u.val.host_paren 	= val.host_paren;
    u.val._anon0 	= 0;
    u.val._anon8 	= 0;
    u.val._anon14 	= 0;
    u.val._anon26 	= 0;
    mackerel_write_addr_32(_dev->base,(0x18),u.raw);
}

static inline void __DP(ctrlext_sdp2_gpien_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrlext_sdp2_gpien_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrlext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x18));
    u.val._anon0 	= 0;
    u.val._anon8 	= 0;
    u.val._anon14 	= 0;
    u.val._anon26 	= 0;
    u.val.sdp2_gpien = val;
    mackerel_write_addr_32(_dev->base,(0x18),u.raw);
}

static inline void __DP(ctrlext_sdp3_gpien_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrlext_sdp3_gpien_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrlext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x18));
    u.val._anon0 	= 0;
    u.val._anon8 	= 0;
    u.val._anon14 	= 0;
    u.val._anon26 	= 0;
    u.val.sdp3_gpien = val;
    mackerel_write_addr_32(_dev->base,(0x18),u.raw);
}

static inline void __DP(ctrlext_sdp2_data_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrlext_sdp2_data_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrlext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x18));
    u.val._anon0 	= 0;
    u.val._anon8 	= 0;
    u.val._anon14 	= 0;
    u.val._anon26 	= 0;
    u.val.sdp2_data = val;
    mackerel_write_addr_32(_dev->base,(0x18),u.raw);
}

static inline void __DP(ctrlext_sdp3_data_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrlext_sdp3_data_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrlext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x18));
    u.val._anon0 	= 0;
    u.val._anon8 	= 0;
    u.val._anon14 	= 0;
    u.val._anon26 	= 0;
    u.val.sdp3_data = val;
    mackerel_write_addr_32(_dev->base,(0x18),u.raw);
}

static inline void __DP(ctrlext_sdp2_iodir_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrlext_sdp2_iodir_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrlext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x18));
    u.val._anon0 	= 0;
    u.val._anon8 	= 0;
    u.val._anon14 	= 0;
    u.val._anon26 	= 0;
    u.val.sdp2_iodir = val;
    mackerel_write_addr_32(_dev->base,(0x18),u.raw);
}

static inline void __DP(ctrlext_sdp3_iodir_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrlext_sdp3_iodir_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrlext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x18));
    u.val._anon0 	= 0;
    u.val._anon8 	= 0;
    u.val._anon14 	= 0;
    u.val._anon26 	= 0;
    u.val.sdp3_iodir = val;
    mackerel_write_addr_32(_dev->base,(0x18),u.raw);
}

static inline void __DP(ctrlext_asdchk_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrlext_asdchk_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrlext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x18));
    u.val._anon0 	= 0;
    u.val._anon8 	= 0;
    u.val._anon14 	= 0;
    u.val._anon26 	= 0;
    u.val.asdchk = val;
    mackerel_write_addr_32(_dev->base,(0x18),u.raw);
}

static inline void __DP(ctrlext_ee_rst_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrlext_ee_rst_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrlext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x18));
    u.val._anon0 	= 0;
    u.val._anon8 	= 0;
    u.val._anon14 	= 0;
    u.val._anon26 	= 0;
    u.val.ee_rst = val;
    mackerel_write_addr_32(_dev->base,(0x18),u.raw);
}

static inline void __DP(ctrlext_spd_byps_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrlext_spd_byps_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrlext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x18));
    u.val._anon0 	= 0;
    u.val._anon8 	= 0;
    u.val._anon14 	= 0;
    u.val._anon26 	= 0;
    u.val.spd_byps = val;
    mackerel_write_addr_32(_dev->base,(0x18),u.raw);
}

static inline void __DP(ctrlext_rodis_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrlext_rodis_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrlext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x18));
    u.val._anon0 	= 0;
    u.val._anon8 	= 0;
    u.val._anon14 	= 0;
    u.val._anon26 	= 0;
    u.val.rodis = val;
    mackerel_write_addr_32(_dev->base,(0x18),u.raw);
}

static inline void __DP(ctrlext_serdeslpe_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrlext_serdeslpe_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrlext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x18));
    u.val._anon0 	= 0;
    u.val._anon8 	= 0;
    u.val._anon14 	= 0;
    u.val._anon26 	= 0;
    u.val.serdeslpe = val;
    mackerel_write_addr_32(_dev->base,(0x18),u.raw);
}

static inline void __DP(ctrlext_dmadge_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrlext_dmadge_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrlext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x18));
    u.val._anon0 	= 0;
    u.val._anon8 	= 0;
    u.val._anon14 	= 0;
    u.val._anon26 	= 0;
    u.val.dmadge = val;
    mackerel_write_addr_32(_dev->base,(0x18),u.raw);
}

static inline void __DP(ctrlext_phypde_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrlext_phypde_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrlext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x18));
    u.val._anon0 	= 0;
    u.val._anon8 	= 0;
    u.val._anon14 	= 0;
    u.val._anon26 	= 0;
    u.val.phypde = val;
    mackerel_write_addr_32(_dev->base,(0x18),u.raw);
}

static inline void __DP(ctrlext_link_mode_wrf)( __DN(t) * _dev, e1000_linkmode_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrlext_link_mode_wrf)( __DN(t) * _dev, e1000_linkmode_t val )
{
    e1000_ctrlext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x18));
    u.val._anon0 	= 0;
    u.val._anon8 	= 0;
    u.val._anon14 	= 0;
    u.val._anon26 	= 0;
    u.val.link_mode = val;
    mackerel_write_addr_32(_dev->base,(0x18),u.raw);
}

static inline void __DP(ctrlext_pb_paren_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrlext_pb_paren_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrlext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x18));
    u.val._anon0 	= 0;
    u.val._anon8 	= 0;
    u.val._anon14 	= 0;
    u.val._anon26 	= 0;
    u.val.pb_paren = val;
    mackerel_write_addr_32(_dev->base,(0x18),u.raw);
}

static inline void __DP(ctrlext_df_paren_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrlext_df_paren_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrlext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x18));
    u.val._anon0 	= 0;
    u.val._anon8 	= 0;
    u.val._anon14 	= 0;
    u.val._anon26 	= 0;
    u.val.df_paren = val;
    mackerel_write_addr_32(_dev->base,(0x18),u.raw);
}

static inline void __DP(ctrlext_iame_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrlext_iame_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrlext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x18));
    u.val._anon0 	= 0;
    u.val._anon8 	= 0;
    u.val._anon14 	= 0;
    u.val._anon26 	= 0;
    u.val.iame = val;
    mackerel_write_addr_32(_dev->base,(0x18),u.raw);
}

static inline void __DP(ctrlext_drv_load_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrlext_drv_load_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrlext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x18));
    u.val._anon0 	= 0;
    u.val._anon8 	= 0;
    u.val._anon14 	= 0;
    u.val._anon26 	= 0;
    u.val.drv_load = val;
    mackerel_write_addr_32(_dev->base,(0x18),u.raw);
}

static inline void __DP(ctrlext_int_tca_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrlext_int_tca_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrlext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x18));
    u.val._anon0 	= 0;
    u.val._anon8 	= 0;
    u.val._anon14 	= 0;
    u.val._anon26 	= 0;
    u.val.int_tca = val;
    mackerel_write_addr_32(_dev->base,(0x18),u.raw);
}

static inline void __DP(ctrlext_host_paren_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ctrlext_host_paren_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ctrlext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x18));
    u.val._anon0 	= 0;
    u.val._anon8 	= 0;
    u.val._anon14 	= 0;
    u.val._anon26 	= 0;
    u.val.host_paren = val;
    mackerel_write_addr_32(_dev->base,(0x18),u.raw);
}


static inline int __DP(ctrlext_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ctrlext_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_ctrlext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x18));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ctrlext (Extended device control):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.sdp2_gpien;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sdp2_gpien =\t0x%"PRIx8" (General-purpose interrupt detection for SDP2", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sdp3_gpien;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sdp3_gpien =\t0x%"PRIx8" (General-purpose interrupt detection for SDP3", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.sdp2_data;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sdp2_data =\t0x%"PRIx8" (SDP2 data value", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sdp3_data;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sdp3_data =\t0x%"PRIx8" (SDP3 data value", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.sdp2_iodir;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sdp2_iodir =\t0x%"PRIx8" (SDP2 pin directionality", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sdp3_iodir;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sdp3_iodir =\t0x%"PRIx8" (SDP3 pin directionality", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.asdchk;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " asdchk =\t0x%"PRIx8" (Auto-speed-detection check", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ee_rst;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ee_rst =\t0x%"PRIx8" (EEPROM reset", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.spd_byps;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " spd_byps =\t0x%"PRIx8" (Speed select bypass", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.rodis;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rodis =\t0x%"PRIx8" (Relaxed ordering disabled", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.serdeslpe;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " serdeslpe =\t0x%"PRIx8" (SERDES low power enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dmadge;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dmadge =\t0x%"PRIx8" (DMA dynamic gating enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.phypde;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " phypde =\t0x%"PRIx8" (PHY power down enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.link_mode;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " link_mode =\t0x%"PRIx8" (Link mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_linkmode_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pb_paren;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pb_paren =\t0x%"PRIx8" (Packet buffer parity error detection enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.df_paren;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " df_paren =\t0x%"PRIx8" (Descriptor FIFO parity error detection enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.iame;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " iame =\t0x%"PRIx8" (Interrupt acknowledge auto-mask enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.drv_load;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " drv_load =\t0x%"PRIx8" (Driver loaded", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.int_tca;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " int_tca =\t0x%"PRIx8" (Timers clear enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.host_paren;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " host_paren =\t0x%"PRIx8" (Host data FIFO parity enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register fla (Flash access); type e1000.fla (Implicit type of Flash access register)
 */

/*
 * Dump of fields for register: fla
 *   fl_sk (size 1, offset 0):	 RW	  Clock input to Flash
 *   fl_ce (size 1, offset 1):	 RW	  Chip select to Flash
 *   fl_si (size 1, offset 2):	 RW	  Data input to Flash
 *   fl_so (size 1, offset 3):	 RW	  Data output bit from Flash
 *   fl_req (size 1, offset 4):	 RW	  Request Flash access
 *   fl_gnt (size 1, offset 5):	 RW	  Grant Flash access
 *   fl_addr_sz (size 1, offset 6):	 RW	  Flash address size
 *   _anon7 (size 2, offset 7):	 RSVD	  _
 *   sw_wr_done (size 1, offset 9):	 RW	  Last write done
 *   rd_status (size 1, offset 10):	 RW	  Flash status
 *   _anon11 (size 5, offset 11):	 RSVD	  _
 *   ide_bo (size 14, offset 16):	 RW	  Base address of IDE Boot expansion ROM
 *   fl_busy (size 1, offset 30):	 RW	  Flash busy
 *   fl_er (size 1, offset 31):	 RW	  Flash erase command
 */

static inline uint32_t __DP(fla_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(fla_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x1c));
}

static inline e1000_fla_t __DP(fla_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_fla_t __DP(fla_rd)( __DN(t) * _dev )
{
    e1000_fla_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x1c));
    return u.val;
}

static inline void __DP(fla_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(fla_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x1c),val);
}

static inline void __DP(fla_wr)( __DN(t) * _dev, e1000_fla_t val ) __attribute__ ((always_inline));
static inline void __DP(fla_wr)( __DN(t) * _dev, e1000_fla_t val )
{
    e1000_fla_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x1c));
    u.val.fl_sk 	= val.fl_sk;
    u.val.fl_ce 	= val.fl_ce;
    u.val.fl_si 	= val.fl_si;
    u.val.fl_so 	= val.fl_so;
    u.val.fl_req 	= val.fl_req;
    u.val.fl_gnt 	= val.fl_gnt;
    u.val.fl_addr_sz 	= val.fl_addr_sz;
    u.val.sw_wr_done 	= val.sw_wr_done;
    u.val.rd_status 	= val.rd_status;
    u.val.ide_bo 	= val.ide_bo;
    u.val.fl_busy 	= val.fl_busy;
    u.val.fl_er 	= val.fl_er;
    mackerel_write_addr_32(_dev->base,(0x1c),u.raw);
}

static inline void __DP(fla_fl_sk_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fla_fl_sk_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_fla_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x1c));
    u.val.fl_sk = val;
    mackerel_write_addr_32(_dev->base,(0x1c),u.raw);
}

static inline void __DP(fla_fl_ce_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fla_fl_ce_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_fla_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x1c));
    u.val.fl_ce = val;
    mackerel_write_addr_32(_dev->base,(0x1c),u.raw);
}

static inline void __DP(fla_fl_si_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fla_fl_si_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_fla_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x1c));
    u.val.fl_si = val;
    mackerel_write_addr_32(_dev->base,(0x1c),u.raw);
}

static inline void __DP(fla_fl_so_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fla_fl_so_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_fla_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x1c));
    u.val.fl_so = val;
    mackerel_write_addr_32(_dev->base,(0x1c),u.raw);
}

static inline void __DP(fla_fl_req_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fla_fl_req_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_fla_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x1c));
    u.val.fl_req = val;
    mackerel_write_addr_32(_dev->base,(0x1c),u.raw);
}

static inline void __DP(fla_fl_gnt_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fla_fl_gnt_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_fla_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x1c));
    u.val.fl_gnt = val;
    mackerel_write_addr_32(_dev->base,(0x1c),u.raw);
}

static inline void __DP(fla_fl_addr_sz_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fla_fl_addr_sz_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_fla_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x1c));
    u.val.fl_addr_sz = val;
    mackerel_write_addr_32(_dev->base,(0x1c),u.raw);
}

static inline void __DP(fla_sw_wr_done_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fla_sw_wr_done_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_fla_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x1c));
    u.val.sw_wr_done = val;
    mackerel_write_addr_32(_dev->base,(0x1c),u.raw);
}

static inline void __DP(fla_rd_status_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fla_rd_status_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_fla_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x1c));
    u.val.rd_status = val;
    mackerel_write_addr_32(_dev->base,(0x1c),u.raw);
}

static inline void __DP(fla_ide_bo_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(fla_ide_bo_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_fla_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x1c));
    u.val.ide_bo = val;
    mackerel_write_addr_32(_dev->base,(0x1c),u.raw);
}

static inline void __DP(fla_fl_busy_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fla_fl_busy_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_fla_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x1c));
    u.val.fl_busy = val;
    mackerel_write_addr_32(_dev->base,(0x1c),u.raw);
}

static inline void __DP(fla_fl_er_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fla_fl_er_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_fla_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x1c));
    u.val.fl_er = val;
    mackerel_write_addr_32(_dev->base,(0x1c),u.raw);
}


static inline int __DP(fla_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(fla_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_fla_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x1c));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register fla (Flash access):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.fl_sk;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fl_sk =\t0x%"PRIx8" (Clock input to Flash", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.fl_ce;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fl_ce =\t0x%"PRIx8" (Chip select to Flash", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.fl_si;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fl_si =\t0x%"PRIx8" (Data input to Flash", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.fl_so;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fl_so =\t0x%"PRIx8" (Data output bit from Flash", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.fl_req;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fl_req =\t0x%"PRIx8" (Request Flash access", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.fl_gnt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fl_gnt =\t0x%"PRIx8" (Grant Flash access", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.fl_addr_sz;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fl_addr_sz =\t0x%"PRIx8" (Flash address size", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.sw_wr_done;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sw_wr_done =\t0x%"PRIx8" (Last write done", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rd_status;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rd_status =\t0x%"PRIx8" (Flash status", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint16_t pv = (uint16_t)u.val.ide_bo;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ide_bo =\t0x%0"PRIx16" (Base address of IDE Boot expansion ROM", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.fl_busy;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fl_busy =\t0x%"PRIx8" (Flash busy", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.fl_er;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fl_er =\t0x%"PRIx8" (Flash erase command", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register mdic (MDI control); type e1000.mdic (Implicit type of MDI control register)
 */

/*
 * Dump of fields for register: mdic
 *   data (size 16, offset 0):	 RW	  Data
 *   regadd (size 5, offset 16):	 RW	  PHY register address
 *   phyadd (size 5, offset 21):	 RW	  PHY address
 *   op (size 2, offset 26):	 RW	  Opcode
 *   r (size 1, offset 28):	 RW	  Ready bit
 *   i (size 1, offset 29):	 RW	  Interript enable
 *   e (size 1, offset 30):	 RW	  Error
 *   _anon31 (size 1, offset 31):	 MBZ	  _
 */

static inline uint32_t __DP(mdic_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(mdic_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x20));
}

static inline e1000_mdic_t __DP(mdic_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_mdic_t __DP(mdic_rd)( __DN(t) * _dev )
{
    e1000_mdic_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x20));
    return u.val;
}

static inline void __DP(mdic_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(mdic_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x20),val);
}

static inline void __DP(mdic_wr)( __DN(t) * _dev, e1000_mdic_t val ) __attribute__ ((always_inline));
static inline void __DP(mdic_wr)( __DN(t) * _dev, e1000_mdic_t val )
{
    e1000_mdic_un  u;
    u.val = val;
    u.val._anon31 	= 0;
    mackerel_write_addr_32(_dev->base,(0x20),u.raw);
}

static inline void __DP(mdic_data_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(mdic_data_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_mdic_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x20));
    u.val._anon31 	= 0;
    u.val.data = val;
    mackerel_write_addr_32(_dev->base,(0x20),u.raw);
}

static inline void __DP(mdic_regadd_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(mdic_regadd_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_mdic_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x20));
    u.val._anon31 	= 0;
    u.val.regadd = val;
    mackerel_write_addr_32(_dev->base,(0x20),u.raw);
}

static inline void __DP(mdic_phyadd_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(mdic_phyadd_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_mdic_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x20));
    u.val._anon31 	= 0;
    u.val.phyadd = val;
    mackerel_write_addr_32(_dev->base,(0x20),u.raw);
}

static inline void __DP(mdic_op_wrf)( __DN(t) * _dev, e1000_phyop_t val ) __attribute__ ((always_inline));
static inline void __DP(mdic_op_wrf)( __DN(t) * _dev, e1000_phyop_t val )
{
    e1000_mdic_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x20));
    u.val._anon31 	= 0;
    u.val.op = val;
    mackerel_write_addr_32(_dev->base,(0x20),u.raw);
}

static inline void __DP(mdic_r_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(mdic_r_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_mdic_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x20));
    u.val._anon31 	= 0;
    u.val.r = val;
    mackerel_write_addr_32(_dev->base,(0x20),u.raw);
}

static inline void __DP(mdic_i_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(mdic_i_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_mdic_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x20));
    u.val._anon31 	= 0;
    u.val.i = val;
    mackerel_write_addr_32(_dev->base,(0x20),u.raw);
}

static inline void __DP(mdic_e_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(mdic_e_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_mdic_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x20));
    u.val._anon31 	= 0;
    u.val.e = val;
    mackerel_write_addr_32(_dev->base,(0x20),u.raw);
}


static inline int __DP(mdic_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(mdic_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_mdic_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x20));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register mdic (MDI control):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.data;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " data =\t0x%0"PRIx16" (Data", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.regadd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " regadd =\t0x%"PRIx8" (PHY register address", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.phyadd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " phyadd =\t0x%"PRIx8" (PHY address", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.op;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " op =\t0x%"PRIx8" (Opcode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_phyop_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.r;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " r =\t0x%"PRIx8" (Ready bit", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.i;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " i =\t0x%"PRIx8" (Interript enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.e;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " e =\t0x%"PRIx8" (Error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register serdesctl (SERDES ANA); type e1000.serdesctl (Implicit type of SERDES ANA register)
 */

/*
 * Dump of fields for register: serdesctl
 *   data (size 8, offset 0):	 RW	  Data to SerDes
 *   addr (size 8, offset 8):	 RW	  Address to SerDes
 *   _anon16 (size 15, offset 16):	 RSVD	  _
 *   done (size 1, offset 31):	 RW	  Done
 */

static inline uint32_t __DP(serdesctl_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(serdesctl_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x24));
}

static inline e1000_serdesctl_t __DP(serdesctl_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_serdesctl_t __DP(serdesctl_rd)( __DN(t) * _dev )
{
    e1000_serdesctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x24));
    return u.val;
}

static inline void __DP(serdesctl_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(serdesctl_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x24),val);
}

static inline void __DP(serdesctl_wr)( __DN(t) * _dev, e1000_serdesctl_t val ) __attribute__ ((always_inline));
static inline void __DP(serdesctl_wr)( __DN(t) * _dev, e1000_serdesctl_t val )
{
    e1000_serdesctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x24));
    u.val.data 	= val.data;
    u.val.addr 	= val.addr;
    u.val.done 	= val.done;
    mackerel_write_addr_32(_dev->base,(0x24),u.raw);
}

static inline void __DP(serdesctl_data_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(serdesctl_data_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_serdesctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x24));
    u.val.data = val;
    mackerel_write_addr_32(_dev->base,(0x24),u.raw);
}

static inline void __DP(serdesctl_addr_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(serdesctl_addr_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_serdesctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x24));
    u.val.addr = val;
    mackerel_write_addr_32(_dev->base,(0x24),u.raw);
}

static inline void __DP(serdesctl_done_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(serdesctl_done_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_serdesctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x24));
    u.val.done = val;
    mackerel_write_addr_32(_dev->base,(0x24),u.raw);
}


static inline int __DP(serdesctl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(serdesctl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_serdesctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x24));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register serdesctl (SERDES ANA):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.data;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " data =\t0x%"PRIx8" (Data to SerDes", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.addr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " addr =\t0x%"PRIx8" (Address to SerDes", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.done;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " done =\t0x%"PRIx8" (Done", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register fcal (Flow control address low); type e1000.uint32
 */

static inline uint32_t __DP(fcal_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(fcal_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x28));
}

static inline uint32_t __DP(fcal_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(fcal_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x28));
}

static inline void __DP(fcal_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(fcal_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x28),val);
}

static inline void __DP(fcal_wr)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(fcal_wr)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x28),val);
}


static inline int __DP(fcal_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(fcal_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register fcal (Flow control address low):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x28)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register fcah (Flow control address low); type e1000.uint32
 */

static inline uint32_t __DP(fcah_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(fcah_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x2c));
}

static inline uint32_t __DP(fcah_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(fcah_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x2c));
}

static inline void __DP(fcah_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(fcah_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x2c),val);
}

static inline void __DP(fcah_wr)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(fcah_wr)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x2c),val);
}


static inline int __DP(fcah_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(fcah_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register fcah (Flow control address low):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x2c)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register fct (Flow control type); type e1000.uint32
 */

static inline uint32_t __DP(fct_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(fct_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x30));
}

static inline uint32_t __DP(fct_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(fct_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x30));
}

static inline void __DP(fct_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(fct_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x30),val);
}

static inline void __DP(fct_wr)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(fct_wr)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x30),val);
}


static inline int __DP(fct_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(fct_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register fct (Flow control type):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x30)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register kumctrlsta (GLCI control and status); type e1000.kumctrlsta (Implicit type of GLCI control and status register)
 */

/*
 * Dump of fields for register: kumctrlsta
 *   data (size 16, offset 0):	 RW	  Data
 *   offset (size 5, offset 16):	 RW	  Offset of internal register
 *   ren (size 1, offset 21):	 RW	  Read enable (1=read)
 *   _anon22 (size 10, offset 22):	 RSVD	  _
 */

static inline uint32_t __DP(kumctrlsta_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(kumctrlsta_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x34));
}

static inline e1000_kumctrlsta_t __DP(kumctrlsta_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_kumctrlsta_t __DP(kumctrlsta_rd)( __DN(t) * _dev )
{
    e1000_kumctrlsta_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x34));
    return u.val;
}

static inline void __DP(kumctrlsta_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(kumctrlsta_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x34),val);
}

static inline void __DP(kumctrlsta_wr)( __DN(t) * _dev, e1000_kumctrlsta_t val ) __attribute__ ((always_inline));
static inline void __DP(kumctrlsta_wr)( __DN(t) * _dev, e1000_kumctrlsta_t val )
{
    e1000_kumctrlsta_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x34));
    u.val.data 	= val.data;
    u.val.offset 	= val.offset;
    u.val.ren 	= val.ren;
    mackerel_write_addr_32(_dev->base,(0x34),u.raw);
}

static inline void __DP(kumctrlsta_data_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(kumctrlsta_data_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_kumctrlsta_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x34));
    u.val.data = val;
    mackerel_write_addr_32(_dev->base,(0x34),u.raw);
}

static inline void __DP(kumctrlsta_offset_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(kumctrlsta_offset_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_kumctrlsta_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x34));
    u.val.offset = val;
    mackerel_write_addr_32(_dev->base,(0x34),u.raw);
}

static inline void __DP(kumctrlsta_ren_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(kumctrlsta_ren_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_kumctrlsta_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x34));
    u.val.ren = val;
    mackerel_write_addr_32(_dev->base,(0x34),u.raw);
}


static inline int __DP(kumctrlsta_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(kumctrlsta_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_kumctrlsta_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x34));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register kumctrlsta (GLCI control and status):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.data;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " data =\t0x%0"PRIx16" (Data", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.offset;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " offset =\t0x%"PRIx8" (Offset of internal register", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ren;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ren =\t0x%"PRIx8" (Read enable (1=read)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register vet (VLAN Ether type); type e1000.uint32
 */

static inline uint32_t __DP(vet_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(vet_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x38));
}

static inline uint32_t __DP(vet_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(vet_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x38));
}

static inline void __DP(vet_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(vet_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x38),val);
}

static inline void __DP(vet_wr)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(vet_wr)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x38),val);
}


static inline int __DP(vet_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(vet_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register vet (VLAN Ether type):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x38)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register mdphya (MDC/MDIO PHY address); type e1000.mdphya (Implicit type of MDC/MDIO PHY address register)
 */

/*
 * Dump of fields for register: mdphya
 *   phya (size 5, offset 0):	 RW	  PHY address
 *   _anon5 (size 27, offset 5):	 RSVD	  _
 */

static inline uint32_t __DP(mdphya_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(mdphya_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x3c));
}

static inline e1000_mdphya_t __DP(mdphya_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_mdphya_t __DP(mdphya_rd)( __DN(t) * _dev )
{
    e1000_mdphya_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3c));
    return u.val;
}

static inline void __DP(mdphya_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(mdphya_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x3c),val);
}

static inline void __DP(mdphya_wr)( __DN(t) * _dev, e1000_mdphya_t val ) __attribute__ ((always_inline));
static inline void __DP(mdphya_wr)( __DN(t) * _dev, e1000_mdphya_t val )
{
    e1000_mdphya_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3c));
    u.val.phya 	= val.phya;
    mackerel_write_addr_32(_dev->base,(0x3c),u.raw);
}

static inline void __DP(mdphya_phya_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(mdphya_phya_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_mdphya_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3c));
    u.val.phya = val;
    mackerel_write_addr_32(_dev->base,(0x3c),u.raw);
}


static inline int __DP(mdphya_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(mdphya_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_mdphya_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3c));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register mdphya (MDC/MDIO PHY address):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.phya;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " phya =\t0x%"PRIx8" (PHY address", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register ufuse3 (ULT Fuse register 3); type e1000.ufuse3 (Implicit type of ULT Fuse register 3 register)
 */

/*
 * Dump of fields for register: ufuse3
 *   drred (size 15, offset 0):	 RO	  Data RAM redundancy fuses
 *   crred (size 13, offset 15):	 RO	  Code RAM redundancy fuses
 *   enad (size 1, offset 28):	 RO	  Enable Data RAM redundancy fuses
 *   enac (size 1, offset 29):	 RO	  Enable Code RAM redundancy fuses
 *   _anon30 (size 2, offset 30):	 RSVD	  _
 */

static inline uint32_t __DP(ufuse3_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ufuse3_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0xf0));
}

static inline e1000_ufuse3_t __DP(ufuse3_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_ufuse3_t __DP(ufuse3_rd)( __DN(t) * _dev )
{
    e1000_ufuse3_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xf0));
    return u.val;
}

// Register ufuse3 is not writeable


static inline int __DP(ufuse3_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ufuse3_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_ufuse3_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xf0));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ufuse3 (ULT Fuse register 3):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.drred;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " drred =\t0x%0"PRIx16" (Data RAM redundancy fuses", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint16_t pv = (uint16_t)u.val.crred;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " crred =\t0x%0"PRIx16" (Code RAM redundancy fuses", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.enad;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " enad =\t0x%"PRIx8" (Enable Data RAM redundancy fuses", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.enac;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " enac =\t0x%"PRIx8" (Enable Code RAM redundancy fuses", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register fcttv (Flow control transmit timer value); type e1000.fcttv (Implicit type of Flow control transmit timer value register)
 */

/*
 * Dump of fields for register: fcttv
 *   ttv (size 16, offset 0):	 RW	  Transmit timer value
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */

static inline uint32_t __DP(fcttv_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(fcttv_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x170));
}

static inline e1000_fcttv_t __DP(fcttv_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_fcttv_t __DP(fcttv_rd)( __DN(t) * _dev )
{
    e1000_fcttv_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x170));
    return u.val;
}

static inline void __DP(fcttv_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(fcttv_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x170),val);
}

static inline void __DP(fcttv_wr)( __DN(t) * _dev, e1000_fcttv_t val ) __attribute__ ((always_inline));
static inline void __DP(fcttv_wr)( __DN(t) * _dev, e1000_fcttv_t val )
{
    e1000_fcttv_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0x170),u.raw);
}

static inline void __DP(fcttv_ttv_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(fcttv_ttv_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_fcttv_un  u;
    u.val._anon16 	= 0;
    u.val.ttv = val;
    mackerel_write_addr_32(_dev->base,(0x170),u.raw);
}


static inline int __DP(fcttv_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(fcttv_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_fcttv_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x170));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register fcttv (Flow control transmit timer value):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.ttv;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ttv =\t0x%0"PRIx16" (Transmit timer value", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register txcw (Transmit config word); type e1000.txcw (Implicit type of Transmit config word register)
 */

/*
 * Dump of fields for register: txcw
 *   _anon0 (size 5, offset 0):	 MBZ	  _
 *   txcw_fd (size 1, offset 5):	 RW	  TXCW full-duplex
 *   txcw_hd (size 1, offset 6):	 RW	  TXCW half-duplex
 *   txcw_pause (size 2, offset 7):	 RW	  TXCW pause
 *   _anon9 (size 3, offset 9):	 MBZ	  _
 *   txcw_rfi (size 2, offset 12):	 RW	  TXCW remote fault indication
 *   _anon14 (size 1, offset 14):	 MBZ	  _
 *   txcw_npr (size 1, offset 15):	 RW	  TXCW next page request
 *   _anon16 (size 14, offset 16):	 MBZ	  _
 *   txconfig (size 1, offset 30):	 RW	  Transmit config control bit
 *   ane (size 1, offset 31):	 RW	  Auto-negotiation enable
 */

static inline uint32_t __DP(txcw_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(txcw_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x178));
}

static inline e1000_txcw_t __DP(txcw_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_txcw_t __DP(txcw_rd)( __DN(t) * _dev )
{
    e1000_txcw_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x178));
    return u.val;
}

static inline void __DP(txcw_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(txcw_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x178),val);
}

static inline void __DP(txcw_wr)( __DN(t) * _dev, e1000_txcw_t val ) __attribute__ ((always_inline));
static inline void __DP(txcw_wr)( __DN(t) * _dev, e1000_txcw_t val )
{
    e1000_txcw_un  u;
    u.val = val;
    u.val._anon0 	= 0;
    u.val._anon9 	= 0;
    u.val._anon14 	= 0;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0x178),u.raw);
}

static inline void __DP(txcw_txcw_fd_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(txcw_txcw_fd_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_txcw_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x178));
    u.val._anon0 	= 0;
    u.val._anon9 	= 0;
    u.val._anon14 	= 0;
    u.val._anon16 	= 0;
    u.val.txcw_fd = val;
    mackerel_write_addr_32(_dev->base,(0x178),u.raw);
}

static inline void __DP(txcw_txcw_hd_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(txcw_txcw_hd_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_txcw_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x178));
    u.val._anon0 	= 0;
    u.val._anon9 	= 0;
    u.val._anon14 	= 0;
    u.val._anon16 	= 0;
    u.val.txcw_hd = val;
    mackerel_write_addr_32(_dev->base,(0x178),u.raw);
}

static inline void __DP(txcw_txcw_pause_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(txcw_txcw_pause_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_txcw_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x178));
    u.val._anon0 	= 0;
    u.val._anon9 	= 0;
    u.val._anon14 	= 0;
    u.val._anon16 	= 0;
    u.val.txcw_pause = val;
    mackerel_write_addr_32(_dev->base,(0x178),u.raw);
}

static inline void __DP(txcw_txcw_rfi_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(txcw_txcw_rfi_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_txcw_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x178));
    u.val._anon0 	= 0;
    u.val._anon9 	= 0;
    u.val._anon14 	= 0;
    u.val._anon16 	= 0;
    u.val.txcw_rfi = val;
    mackerel_write_addr_32(_dev->base,(0x178),u.raw);
}

static inline void __DP(txcw_txcw_npr_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(txcw_txcw_npr_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_txcw_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x178));
    u.val._anon0 	= 0;
    u.val._anon9 	= 0;
    u.val._anon14 	= 0;
    u.val._anon16 	= 0;
    u.val.txcw_npr = val;
    mackerel_write_addr_32(_dev->base,(0x178),u.raw);
}

static inline void __DP(txcw_txconfig_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(txcw_txconfig_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_txcw_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x178));
    u.val._anon0 	= 0;
    u.val._anon9 	= 0;
    u.val._anon14 	= 0;
    u.val._anon16 	= 0;
    u.val.txconfig = val;
    mackerel_write_addr_32(_dev->base,(0x178),u.raw);
}

static inline void __DP(txcw_ane_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(txcw_ane_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_txcw_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x178));
    u.val._anon0 	= 0;
    u.val._anon9 	= 0;
    u.val._anon14 	= 0;
    u.val._anon16 	= 0;
    u.val.ane = val;
    mackerel_write_addr_32(_dev->base,(0x178),u.raw);
}


static inline int __DP(txcw_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(txcw_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_txcw_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x178));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register txcw (Transmit config word):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.txcw_fd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txcw_fd =\t0x%"PRIx8" (TXCW full-duplex", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.txcw_hd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txcw_hd =\t0x%"PRIx8" (TXCW half-duplex", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.txcw_pause;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txcw_pause =\t0x%"PRIx8" (TXCW pause", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.txcw_rfi;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txcw_rfi =\t0x%"PRIx8" (TXCW remote fault indication", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.txcw_npr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txcw_npr =\t0x%"PRIx8" (TXCW next page request", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.txconfig;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txconfig =\t0x%"PRIx8" (Transmit config control bit", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ane;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ane =\t0x%"PRIx8" (Auto-negotiation enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register rxcw (Receive config word); type e1000.rxcw (Implicit type of Receive config word register)
 */

/*
 * Dump of fields for register: rxcw
 *   _anon0 (size 5, offset 0):	 MBZ	  _
 *   rxcw_fd (size 1, offset 5):	 RO	  RXCW full-duplex
 *   rxcw_hd (size 1, offset 6):	 RO	  RXCW half-duplex
 *   rxcw_pause (size 2, offset 7):	 RO	  RXCW pause
 *   _anon9 (size 3, offset 9):	 MBZ	  _
 *   rxcw_rfi (size 2, offset 12):	 RO	  RXCW remote fault indication
 *   _anon14 (size 1, offset 14):	 MBZ	  _
 *   rxcw_npr (size 1, offset 15):	 RO	  RXCW next page request
 *   _anon16 (size 10, offset 16):	 MBZ	  _
 *   nc (size 1, offset 26):	 RO	  Carrier sense indicator
 *   inv (size 1, offset 27):	 RO	  Invalid symbol during config process
 *   chg (size 1, offset 28):	 RO	  Change to RXCW indication
 *   rxconfig (size 1, offset 29):	 RO	  Reception indication
 *   sync (size 1, offset 30):	 RO	  Lost bit sync indication
 *   anc (size 1, offset 31):	 RO	  Auto-negotiation complete
 */

static inline uint32_t __DP(rxcw_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rxcw_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x180));
}

static inline e1000_rxcw_t __DP(rxcw_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_rxcw_t __DP(rxcw_rd)( __DN(t) * _dev )
{
    e1000_rxcw_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x180));
    return u.val;
}

// Register rxcw is not writeable


static inline int __DP(rxcw_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rxcw_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_rxcw_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x180));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rxcw (Receive config word):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.rxcw_fd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxcw_fd =\t0x%"PRIx8" (RXCW full-duplex", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rxcw_hd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxcw_hd =\t0x%"PRIx8" (RXCW half-duplex", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rxcw_pause;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxcw_pause =\t0x%"PRIx8" (RXCW pause", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.rxcw_rfi;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxcw_rfi =\t0x%"PRIx8" (RXCW remote fault indication", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.rxcw_npr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxcw_npr =\t0x%"PRIx8" (RXCW next page request", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.nc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " nc =\t0x%"PRIx8" (Carrier sense indicator", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.inv;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " inv =\t0x%"PRIx8" (Invalid symbol during config process", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.chg;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " chg =\t0x%"PRIx8" (Change to RXCW indication", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rxconfig;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxconfig =\t0x%"PRIx8" (Reception indication", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sync;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sync =\t0x%"PRIx8" (Lost bit sync indication", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.anc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " anc =\t0x%"PRIx8" (Auto-negotiation complete", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register ledctl (LED control); type e1000.ledctl (Implicit type of LED control register)
 */

/*
 * Dump of fields for register: ledctl
 *   led0_mode (size 4, offset 0):	 RW	  LED0/LINK# mode
 *   _anon4 (size 1, offset 4):	 MBZ	  _
 *   global_blink_mode (size 1, offset 5):	 RW	  Global blink mode
 *   led0_ivrt (size 1, offset 6):	 RW	  LED0 invert
 *   led0_blink (size 1, offset 7):	 RW	  LED0 blink
 *   led1_mode (size 4, offset 8):	 RW	  LED1/LINK# mode
 *   _anon12 (size 1, offset 12):	 MBZ	  _
 *   led1_blink_mode (size 1, offset 13):	 RW	  Global blink mode
 *   led1_ivrt (size 1, offset 14):	 RW	  LED1 invert
 *   led1_blink (size 1, offset 15):	 RW	  LED1 blink
 *   led2_mode (size 4, offset 16):	 RW	  LED2/LINK# mode
 *   _anon20 (size 1, offset 20):	 MBZ	  _
 *   led2_blink_mode (size 1, offset 21):	 RW	  Global blink mode
 *   led2_ivrt (size 1, offset 22):	 RW	  LED2 invert
 *   led2_blink (size 1, offset 23):	 RW	  LED2 blink
 *   led3_mode (size 4, offset 24):	 RW	  LED3/LINK# mode
 *   _anon28 (size 1, offset 28):	 MBZ	  _
 *   led3_blink_mode (size 1, offset 29):	 RW	  Global blink mode
 *   led3_ivrt (size 1, offset 30):	 RW	  LED3 invert
 *   led3_blink (size 1, offset 31):	 RW	  LED3 blink
 */

static inline uint32_t __DP(ledctl_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ledctl_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0xe00));
}

static inline e1000_ledctl_t __DP(ledctl_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_ledctl_t __DP(ledctl_rd)( __DN(t) * _dev )
{
    e1000_ledctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe00));
    return u.val;
}

static inline void __DP(ledctl_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(ledctl_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xe00),val);
}

static inline void __DP(ledctl_wr)( __DN(t) * _dev, e1000_ledctl_t val ) __attribute__ ((always_inline));
static inline void __DP(ledctl_wr)( __DN(t) * _dev, e1000_ledctl_t val )
{
    e1000_ledctl_un  u;
    u.val = val;
    u.val._anon4 	= 0;
    u.val._anon12 	= 0;
    u.val._anon20 	= 0;
    u.val._anon28 	= 0;
    mackerel_write_addr_32(_dev->base,(0xe00),u.raw);
}

static inline void __DP(ledctl_led0_mode_wrf)( __DN(t) * _dev, e1000_ledmode_t val ) __attribute__ ((always_inline));
static inline void __DP(ledctl_led0_mode_wrf)( __DN(t) * _dev, e1000_ledmode_t val )
{
    e1000_ledctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe00));
    u.val._anon4 	= 0;
    u.val._anon12 	= 0;
    u.val._anon20 	= 0;
    u.val._anon28 	= 0;
    u.val.led0_mode = val;
    mackerel_write_addr_32(_dev->base,(0xe00),u.raw);
}

static inline void __DP(ledctl_global_blink_mode_wrf)( __DN(t) * _dev, e1000_blmode_t val ) __attribute__ ((always_inline));
static inline void __DP(ledctl_global_blink_mode_wrf)( __DN(t) * _dev, e1000_blmode_t val )
{
    e1000_ledctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe00));
    u.val._anon4 	= 0;
    u.val._anon12 	= 0;
    u.val._anon20 	= 0;
    u.val._anon28 	= 0;
    u.val.global_blink_mode = val;
    mackerel_write_addr_32(_dev->base,(0xe00),u.raw);
}

static inline void __DP(ledctl_led0_ivrt_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ledctl_led0_ivrt_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ledctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe00));
    u.val._anon4 	= 0;
    u.val._anon12 	= 0;
    u.val._anon20 	= 0;
    u.val._anon28 	= 0;
    u.val.led0_ivrt = val;
    mackerel_write_addr_32(_dev->base,(0xe00),u.raw);
}

static inline void __DP(ledctl_led0_blink_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ledctl_led0_blink_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ledctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe00));
    u.val._anon4 	= 0;
    u.val._anon12 	= 0;
    u.val._anon20 	= 0;
    u.val._anon28 	= 0;
    u.val.led0_blink = val;
    mackerel_write_addr_32(_dev->base,(0xe00),u.raw);
}

static inline void __DP(ledctl_led1_mode_wrf)( __DN(t) * _dev, e1000_ledmode_t val ) __attribute__ ((always_inline));
static inline void __DP(ledctl_led1_mode_wrf)( __DN(t) * _dev, e1000_ledmode_t val )
{
    e1000_ledctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe00));
    u.val._anon4 	= 0;
    u.val._anon12 	= 0;
    u.val._anon20 	= 0;
    u.val._anon28 	= 0;
    u.val.led1_mode = val;
    mackerel_write_addr_32(_dev->base,(0xe00),u.raw);
}

static inline void __DP(ledctl_led1_blink_mode_wrf)( __DN(t) * _dev, e1000_blmode_t val ) __attribute__ ((always_inline));
static inline void __DP(ledctl_led1_blink_mode_wrf)( __DN(t) * _dev, e1000_blmode_t val )
{
    e1000_ledctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe00));
    u.val._anon4 	= 0;
    u.val._anon12 	= 0;
    u.val._anon20 	= 0;
    u.val._anon28 	= 0;
    u.val.led1_blink_mode = val;
    mackerel_write_addr_32(_dev->base,(0xe00),u.raw);
}

static inline void __DP(ledctl_led1_ivrt_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ledctl_led1_ivrt_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ledctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe00));
    u.val._anon4 	= 0;
    u.val._anon12 	= 0;
    u.val._anon20 	= 0;
    u.val._anon28 	= 0;
    u.val.led1_ivrt = val;
    mackerel_write_addr_32(_dev->base,(0xe00),u.raw);
}

static inline void __DP(ledctl_led1_blink_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ledctl_led1_blink_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ledctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe00));
    u.val._anon4 	= 0;
    u.val._anon12 	= 0;
    u.val._anon20 	= 0;
    u.val._anon28 	= 0;
    u.val.led1_blink = val;
    mackerel_write_addr_32(_dev->base,(0xe00),u.raw);
}

static inline void __DP(ledctl_led2_mode_wrf)( __DN(t) * _dev, e1000_ledmode_t val ) __attribute__ ((always_inline));
static inline void __DP(ledctl_led2_mode_wrf)( __DN(t) * _dev, e1000_ledmode_t val )
{
    e1000_ledctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe00));
    u.val._anon4 	= 0;
    u.val._anon12 	= 0;
    u.val._anon20 	= 0;
    u.val._anon28 	= 0;
    u.val.led2_mode = val;
    mackerel_write_addr_32(_dev->base,(0xe00),u.raw);
}

static inline void __DP(ledctl_led2_blink_mode_wrf)( __DN(t) * _dev, e1000_blmode_t val ) __attribute__ ((always_inline));
static inline void __DP(ledctl_led2_blink_mode_wrf)( __DN(t) * _dev, e1000_blmode_t val )
{
    e1000_ledctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe00));
    u.val._anon4 	= 0;
    u.val._anon12 	= 0;
    u.val._anon20 	= 0;
    u.val._anon28 	= 0;
    u.val.led2_blink_mode = val;
    mackerel_write_addr_32(_dev->base,(0xe00),u.raw);
}

static inline void __DP(ledctl_led2_ivrt_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ledctl_led2_ivrt_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ledctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe00));
    u.val._anon4 	= 0;
    u.val._anon12 	= 0;
    u.val._anon20 	= 0;
    u.val._anon28 	= 0;
    u.val.led2_ivrt = val;
    mackerel_write_addr_32(_dev->base,(0xe00),u.raw);
}

static inline void __DP(ledctl_led2_blink_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ledctl_led2_blink_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ledctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe00));
    u.val._anon4 	= 0;
    u.val._anon12 	= 0;
    u.val._anon20 	= 0;
    u.val._anon28 	= 0;
    u.val.led2_blink = val;
    mackerel_write_addr_32(_dev->base,(0xe00),u.raw);
}

static inline void __DP(ledctl_led3_mode_wrf)( __DN(t) * _dev, e1000_ledmode_t val ) __attribute__ ((always_inline));
static inline void __DP(ledctl_led3_mode_wrf)( __DN(t) * _dev, e1000_ledmode_t val )
{
    e1000_ledctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe00));
    u.val._anon4 	= 0;
    u.val._anon12 	= 0;
    u.val._anon20 	= 0;
    u.val._anon28 	= 0;
    u.val.led3_mode = val;
    mackerel_write_addr_32(_dev->base,(0xe00),u.raw);
}

static inline void __DP(ledctl_led3_blink_mode_wrf)( __DN(t) * _dev, e1000_blmode_t val ) __attribute__ ((always_inline));
static inline void __DP(ledctl_led3_blink_mode_wrf)( __DN(t) * _dev, e1000_blmode_t val )
{
    e1000_ledctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe00));
    u.val._anon4 	= 0;
    u.val._anon12 	= 0;
    u.val._anon20 	= 0;
    u.val._anon28 	= 0;
    u.val.led3_blink_mode = val;
    mackerel_write_addr_32(_dev->base,(0xe00),u.raw);
}

static inline void __DP(ledctl_led3_ivrt_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ledctl_led3_ivrt_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ledctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe00));
    u.val._anon4 	= 0;
    u.val._anon12 	= 0;
    u.val._anon20 	= 0;
    u.val._anon28 	= 0;
    u.val.led3_ivrt = val;
    mackerel_write_addr_32(_dev->base,(0xe00),u.raw);
}

static inline void __DP(ledctl_led3_blink_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ledctl_led3_blink_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ledctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe00));
    u.val._anon4 	= 0;
    u.val._anon12 	= 0;
    u.val._anon20 	= 0;
    u.val._anon28 	= 0;
    u.val.led3_blink = val;
    mackerel_write_addr_32(_dev->base,(0xe00),u.raw);
}


static inline int __DP(ledctl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ledctl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_ledctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe00));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ledctl (LED control):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.led0_mode;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " led0_mode =\t0x%"PRIx8" (LED0/LINK# mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_ledmode_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.global_blink_mode;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " global_blink_mode =\t0x%"PRIx8" (Global blink mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_blmode_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.led0_ivrt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " led0_ivrt =\t0x%"PRIx8" (LED0 invert", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.led0_blink;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " led0_blink =\t0x%"PRIx8" (LED0 blink", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.led1_mode;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " led1_mode =\t0x%"PRIx8" (LED1/LINK# mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_ledmode_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.led1_blink_mode;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " led1_blink_mode =\t0x%"PRIx8" (Global blink mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_blmode_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.led1_ivrt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " led1_ivrt =\t0x%"PRIx8" (LED1 invert", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.led1_blink;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " led1_blink =\t0x%"PRIx8" (LED1 blink", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.led2_mode;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " led2_mode =\t0x%"PRIx8" (LED2/LINK# mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_ledmode_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.led2_blink_mode;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " led2_blink_mode =\t0x%"PRIx8" (Global blink mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_blmode_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.led2_ivrt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " led2_ivrt =\t0x%"PRIx8" (LED2 invert", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.led2_blink;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " led2_blink =\t0x%"PRIx8" (LED2 blink", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.led3_mode;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " led3_mode =\t0x%"PRIx8" (LED3/LINK# mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_ledmode_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.led3_blink_mode;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " led3_blink_mode =\t0x%"PRIx8" (Global blink mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_blmode_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.led3_ivrt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " led3_ivrt =\t0x%"PRIx8" (LED3 invert", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.led3_blink;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " led3_blink =\t0x%"PRIx8" (LED3 blink", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register extcnf_ctrl (Extended config control); type e1000.extcnf_ctrl (Implicit type of Extended config control register)
 */

/*
 * Dump of fields for register: extcnf_ctrl
 *   _anon0 (size 1, offset 0):	 MBZ	  _
 *   phy_we (size 1, offset 1):	 RW	  PHY write enable
 *   dud_en (size 1, offset 2):	 RW	  Extended dock/undock configuration enable
 *   _anon3 (size 1, offset 3):	 RSVD	  _
 *   dock_own (size 1, offset 4):	 RW	  Dock config owner
 *   mdio_swown (size 1, offset 5):	 RW	  MDIO software ownership
 *   mdio_hwown (size 1, offset 6):	 RW	  MDIO hoftware ownership
 *   _anon7 (size 9, offset 7):	 RSVD	  _
 *   ecp (size 12, offset 16):	 RW	  Extended configuration pointer
 *   _anon28 (size 4, offset 28):	 RSVD	  _
 */

static inline uint32_t __DP(extcnf_ctrl_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(extcnf_ctrl_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0xf00));
}

static inline e1000_extcnf_ctrl_t __DP(extcnf_ctrl_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_extcnf_ctrl_t __DP(extcnf_ctrl_rd)( __DN(t) * _dev )
{
    e1000_extcnf_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xf00));
    return u.val;
}

static inline void __DP(extcnf_ctrl_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(extcnf_ctrl_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xf00),val);
}

static inline void __DP(extcnf_ctrl_wr)( __DN(t) * _dev, e1000_extcnf_ctrl_t val ) __attribute__ ((always_inline));
static inline void __DP(extcnf_ctrl_wr)( __DN(t) * _dev, e1000_extcnf_ctrl_t val )
{
    e1000_extcnf_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xf00));
    u.val._anon0 	= val._anon0;
    u.val.phy_we 	= val.phy_we;
    u.val.dud_en 	= val.dud_en;
    u.val.dock_own 	= val.dock_own;
    u.val.mdio_swown 	= val.mdio_swown;
    u.val.mdio_hwown 	= val.mdio_hwown;
    u.val.ecp 	= val.ecp;
    u.val._anon0 	= 0;
    mackerel_write_addr_32(_dev->base,(0xf00),u.raw);
}

static inline void __DP(extcnf_ctrl_phy_we_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(extcnf_ctrl_phy_we_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_extcnf_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xf00));
    u.val._anon0 	= 0;
    u.val.phy_we = val;
    mackerel_write_addr_32(_dev->base,(0xf00),u.raw);
}

static inline void __DP(extcnf_ctrl_dud_en_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(extcnf_ctrl_dud_en_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_extcnf_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xf00));
    u.val._anon0 	= 0;
    u.val.dud_en = val;
    mackerel_write_addr_32(_dev->base,(0xf00),u.raw);
}

static inline void __DP(extcnf_ctrl_dock_own_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(extcnf_ctrl_dock_own_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_extcnf_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xf00));
    u.val._anon0 	= 0;
    u.val.dock_own = val;
    mackerel_write_addr_32(_dev->base,(0xf00),u.raw);
}

static inline void __DP(extcnf_ctrl_mdio_swown_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(extcnf_ctrl_mdio_swown_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_extcnf_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xf00));
    u.val._anon0 	= 0;
    u.val.mdio_swown = val;
    mackerel_write_addr_32(_dev->base,(0xf00),u.raw);
}

static inline void __DP(extcnf_ctrl_mdio_hwown_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(extcnf_ctrl_mdio_hwown_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_extcnf_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xf00));
    u.val._anon0 	= 0;
    u.val.mdio_hwown = val;
    mackerel_write_addr_32(_dev->base,(0xf00),u.raw);
}

static inline void __DP(extcnf_ctrl_ecp_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(extcnf_ctrl_ecp_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_extcnf_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xf00));
    u.val._anon0 	= 0;
    u.val.ecp = val;
    mackerel_write_addr_32(_dev->base,(0xf00),u.raw);
}


static inline int __DP(extcnf_ctrl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(extcnf_ctrl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_extcnf_ctrl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xf00));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register extcnf_ctrl (Extended config control):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.phy_we;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " phy_we =\t0x%"PRIx8" (PHY write enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dud_en;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dud_en =\t0x%"PRIx8" (Extended dock/undock configuration enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.dock_own;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dock_own =\t0x%"PRIx8" (Dock config owner", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mdio_swown;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mdio_swown =\t0x%"PRIx8" (MDIO software ownership", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mdio_hwown;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mdio_hwown =\t0x%"PRIx8" (MDIO hoftware ownership", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint16_t pv = (uint16_t)u.val.ecp;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ecp =\t0x%0"PRIx16" (Extended configuration pointer", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register extcnf_size (Extended config size); type e1000.extcnf_size (Implicit type of Extended config size register)
 */

/*
 * Dump of fields for register: extcnf_size
 *   phy_len (size 8, offset 0):	 RW	  Extended PHY configuration area length
 *   dock_len (size 8, offset 8):	 RW	  Extended dock configuration area length
 *   _anon16 (size 8, offset 16):	 MBZ	  _
 *   _anon24 (size 8, offset 24):	 RSVD	  _
 */

static inline uint32_t __DP(extcnf_size_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(extcnf_size_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0xf08));
}

static inline e1000_extcnf_size_t __DP(extcnf_size_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_extcnf_size_t __DP(extcnf_size_rd)( __DN(t) * _dev )
{
    e1000_extcnf_size_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xf08));
    return u.val;
}

static inline void __DP(extcnf_size_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(extcnf_size_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xf08),val);
}

static inline void __DP(extcnf_size_wr)( __DN(t) * _dev, e1000_extcnf_size_t val ) __attribute__ ((always_inline));
static inline void __DP(extcnf_size_wr)( __DN(t) * _dev, e1000_extcnf_size_t val )
{
    e1000_extcnf_size_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xf08));
    u.val.phy_len 	= val.phy_len;
    u.val.dock_len 	= val.dock_len;
    u.val._anon16 	= val._anon16;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0xf08),u.raw);
}

static inline void __DP(extcnf_size_phy_len_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(extcnf_size_phy_len_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_extcnf_size_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xf08));
    u.val._anon16 	= 0;
    u.val.phy_len = val;
    mackerel_write_addr_32(_dev->base,(0xf08),u.raw);
}

static inline void __DP(extcnf_size_dock_len_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(extcnf_size_dock_len_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_extcnf_size_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xf08));
    u.val._anon16 	= 0;
    u.val.dock_len = val;
    mackerel_write_addr_32(_dev->base,(0xf08),u.raw);
}


static inline int __DP(extcnf_size_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(extcnf_size_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_extcnf_size_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xf08));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register extcnf_size (Extended config size):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.phy_len;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " phy_len =\t0x%"PRIx8" (Extended PHY configuration area length", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dock_len;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dock_len =\t0x%"PRIx8" (Extended dock configuration area length", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    // skipping anonymous field
    return r;
}


/*
 * Register pba (Packet buffer allocation); type e1000.pba (Implicit type of Packet buffer allocation register)
 */

/*
 * Dump of fields for register: pba
 *   rxa (size 16, offset 0):	 RW	  Rx packet buffer allocation in KB
 *   txa (size 16, offset 16):	 RW	  Tx packet buffer allocation in KB
 */

static inline uint32_t __DP(pba_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(pba_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x1000));
}

static inline e1000_pba_t __DP(pba_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_pba_t __DP(pba_rd)( __DN(t) * _dev )
{
    e1000_pba_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x1000));
    return u.val;
}

static inline void __DP(pba_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(pba_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x1000),val);
}

static inline void __DP(pba_wr)( __DN(t) * _dev, e1000_pba_t val ) __attribute__ ((always_inline));
static inline void __DP(pba_wr)( __DN(t) * _dev, e1000_pba_t val )
{
    e1000_pba_un  u;
    u.val = val;
    mackerel_write_addr_32(_dev->base,(0x1000),u.raw);
}

static inline void __DP(pba_rxa_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(pba_rxa_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_pba_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x1000));
    u.val.rxa = val;
    mackerel_write_addr_32(_dev->base,(0x1000),u.raw);
}

static inline void __DP(pba_txa_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(pba_txa_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_pba_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x1000));
    u.val.txa = val;
    mackerel_write_addr_32(_dev->base,(0x1000),u.raw);
}


static inline int __DP(pba_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(pba_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_pba_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x1000));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register pba (Packet buffer allocation):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.rxa;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxa =\t0x%0"PRIx16" (Rx packet buffer allocation in KB", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint16_t pv = (uint16_t)u.val.txa;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txa =\t0x%0"PRIx16" (Tx packet buffer allocation in KB", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eemngctl (MNG EEPROM control); type e1000.eemngctl (Implicit type of MNG EEPROM control register)
 */

/*
 * Dump of fields for register: eemngctl
 *   _anon0 (size 18, offset 0):	 RSVD	  _
 *   crg_done (size 1, offset 18):	 RW	  MNG configuration cycle done
 *   _anon19 (size 13, offset 19):	 RSVD	  _
 */

static inline uint32_t __DP(eemngctl_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eemngctl_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x1010));
}

static inline e1000_eemngctl_t __DP(eemngctl_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_eemngctl_t __DP(eemngctl_rd)( __DN(t) * _dev )
{
    e1000_eemngctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x1010));
    return u.val;
}

static inline void __DP(eemngctl_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eemngctl_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x1010),val);
}

static inline void __DP(eemngctl_wr)( __DN(t) * _dev, e1000_eemngctl_t val ) __attribute__ ((always_inline));
static inline void __DP(eemngctl_wr)( __DN(t) * _dev, e1000_eemngctl_t val )
{
    e1000_eemngctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x1010));
    u.val.crg_done 	= val.crg_done;
    mackerel_write_addr_32(_dev->base,(0x1010),u.raw);
}

static inline void __DP(eemngctl_crg_done_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eemngctl_crg_done_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_eemngctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x1010));
    u.val.crg_done = val;
    mackerel_write_addr_32(_dev->base,(0x1010),u.raw);
}


static inline int __DP(eemngctl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eemngctl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_eemngctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x1010));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eemngctl (MNG EEPROM control):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.crg_done;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " crg_done =\t0x%"PRIx8" (MNG configuration cycle done", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register sw_fw_sync (Software/firmware sync); type e1000.sw_fw_sync (Implicit type of Software/firmware sync register)
 */

/*
 * Dump of fields for register: sw_fw_sync
 *   sw_eep_sm (size 1, offset 0):	 RW	  EEPROM access owned by software
 *   sw_phy_sm0 (size 1, offset 1):	 RW	  PHY 0 access owned by software
 *   sw_phy_sm1 (size 1, offset 2):	 RW	  PHY 1 access owned by software
 *   sw_mac_csr_sm (size 1, offset 3):	 RW	  Shared CSR access owned by software
 *   _anon4 (size 12, offset 4):	 RSVD	  _
 *   fw_eep_sm (size 1, offset 16):	 RW	  EEPROM access owned by firmware
 *   fw_phy_sm0 (size 1, offset 17):	 RW	  PHY 0 access owned by firmware
 *   fw_phy_sm1 (size 1, offset 18):	 RW	  PHY 1 access owned by firmware
 *   fw_mac_csr_sm (size 1, offset 19):	 RW	  Shared CSR access owned by firmware
 *   _anon20 (size 12, offset 20):	 RSVD	  _
 */

static inline uint32_t __DP(sw_fw_sync_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(sw_fw_sync_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5b5c));
}

static inline e1000_sw_fw_sync_t __DP(sw_fw_sync_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_sw_fw_sync_t __DP(sw_fw_sync_rd)( __DN(t) * _dev )
{
    e1000_sw_fw_sync_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b5c));
    return u.val;
}

static inline void __DP(sw_fw_sync_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(sw_fw_sync_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5b5c),val);
}

static inline void __DP(sw_fw_sync_wr)( __DN(t) * _dev, e1000_sw_fw_sync_t val ) __attribute__ ((always_inline));
static inline void __DP(sw_fw_sync_wr)( __DN(t) * _dev, e1000_sw_fw_sync_t val )
{
    e1000_sw_fw_sync_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b5c));
    u.val.sw_eep_sm 	= val.sw_eep_sm;
    u.val.sw_phy_sm0 	= val.sw_phy_sm0;
    u.val.sw_phy_sm1 	= val.sw_phy_sm1;
    u.val.sw_mac_csr_sm 	= val.sw_mac_csr_sm;
    u.val.fw_eep_sm 	= val.fw_eep_sm;
    u.val.fw_phy_sm0 	= val.fw_phy_sm0;
    u.val.fw_phy_sm1 	= val.fw_phy_sm1;
    u.val.fw_mac_csr_sm 	= val.fw_mac_csr_sm;
    mackerel_write_addr_32(_dev->base,(0x5b5c),u.raw);
}

static inline void __DP(sw_fw_sync_sw_eep_sm_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(sw_fw_sync_sw_eep_sm_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_sw_fw_sync_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b5c));
    u.val.sw_eep_sm = val;
    mackerel_write_addr_32(_dev->base,(0x5b5c),u.raw);
}

static inline void __DP(sw_fw_sync_sw_phy_sm0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(sw_fw_sync_sw_phy_sm0_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_sw_fw_sync_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b5c));
    u.val.sw_phy_sm0 = val;
    mackerel_write_addr_32(_dev->base,(0x5b5c),u.raw);
}

static inline void __DP(sw_fw_sync_sw_phy_sm1_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(sw_fw_sync_sw_phy_sm1_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_sw_fw_sync_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b5c));
    u.val.sw_phy_sm1 = val;
    mackerel_write_addr_32(_dev->base,(0x5b5c),u.raw);
}

static inline void __DP(sw_fw_sync_sw_mac_csr_sm_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(sw_fw_sync_sw_mac_csr_sm_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_sw_fw_sync_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b5c));
    u.val.sw_mac_csr_sm = val;
    mackerel_write_addr_32(_dev->base,(0x5b5c),u.raw);
}

static inline void __DP(sw_fw_sync_fw_eep_sm_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(sw_fw_sync_fw_eep_sm_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_sw_fw_sync_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b5c));
    u.val.fw_eep_sm = val;
    mackerel_write_addr_32(_dev->base,(0x5b5c),u.raw);
}

static inline void __DP(sw_fw_sync_fw_phy_sm0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(sw_fw_sync_fw_phy_sm0_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_sw_fw_sync_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b5c));
    u.val.fw_phy_sm0 = val;
    mackerel_write_addr_32(_dev->base,(0x5b5c),u.raw);
}

static inline void __DP(sw_fw_sync_fw_phy_sm1_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(sw_fw_sync_fw_phy_sm1_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_sw_fw_sync_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b5c));
    u.val.fw_phy_sm1 = val;
    mackerel_write_addr_32(_dev->base,(0x5b5c),u.raw);
}

static inline void __DP(sw_fw_sync_fw_mac_csr_sm_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(sw_fw_sync_fw_mac_csr_sm_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_sw_fw_sync_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b5c));
    u.val.fw_mac_csr_sm = val;
    mackerel_write_addr_32(_dev->base,(0x5b5c),u.raw);
}


static inline int __DP(sw_fw_sync_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(sw_fw_sync_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_sw_fw_sync_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b5c));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register sw_fw_sync (Software/firmware sync):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.sw_eep_sm;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sw_eep_sm =\t0x%"PRIx8" (EEPROM access owned by software", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sw_phy_sm0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sw_phy_sm0 =\t0x%"PRIx8" (PHY 0 access owned by software", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sw_phy_sm1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sw_phy_sm1 =\t0x%"PRIx8" (PHY 1 access owned by software", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sw_mac_csr_sm;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sw_mac_csr_sm =\t0x%"PRIx8" (Shared CSR access owned by software", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.fw_eep_sm;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fw_eep_sm =\t0x%"PRIx8" (EEPROM access owned by firmware", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.fw_phy_sm0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fw_phy_sm0 =\t0x%"PRIx8" (PHY 0 access owned by firmware", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.fw_phy_sm1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fw_phy_sm1 =\t0x%"PRIx8" (PHY 1 access owned by firmware", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.fw_mac_csr_sm;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fw_mac_csr_sm =\t0x%"PRIx8" (Shared CSR access owned by firmware", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register icr (Interrupt cause read); type e1000.intreg (Interrupt register format)
 */

/*
 * Dump of fields for register: icr
 *   txdw (size 1, offset 0):	 RO	  Transmit descriptor written back
 *   txqe (size 1, offset 1):	 RO	  Transmit queue empty
 *   lsc (size 1, offset 2):	 RO	  Link status change
 *   rxseq (size 1, offset 3):	 RO	  Receive sequence error
 *   rxdmt0 (size 1, offset 4):	 RO	  Receive descriptor minimum threshold reached
 *   _anon5 (size 1, offset 5):	 RSVD	  _
 *   rxo (size 1, offset 6):	 RO	  Receiver overrun
 *   rxt0 (size 1, offset 7):	 RO	  Receiver timer interrupt
 *   _anon8 (size 1, offset 8):	 RSVD	  _
 *   mdac (size 1, offset 9):	 RO	  MDI/O access complete
 *   rxcfg (size 1, offset 10):	 RO	  Received configuration symbols
 *   _anon11 (size 2, offset 11):	 RSVD	  _
 *   gpi_sdp2 (size 1, offset 13):	 RO	  General-purpose interrupt on SPD2
 *   gpi_sdp3 (size 1, offset 14):	 RO	  General-purpose interrupt on SPD3
 *   txd_low (size 1, offset 15):	 RO	  Transmit descriptor low threshold
 *   srpd (size 1, offset 16):	 RO	  Small receive packet detected
 *   ack (size 1, offset 17):	 RO	  Receive ack frame detected
 *   _anon18 (size 2, offset 18):	 RSVD	  _
 *   rx_desc_fifo_par0 (size 1, offset 20):	 RO	  Rx descriptor FIFO parity error 0
 *   tx_desc_fifo_par0 (size 1, offset 21):	 RO	  Tx descriptor FIFO parity error 0
 *   pcie_master_par (size 1, offset 22):	 RO	  PCIe master data FIFO parity error
 *   pbpar (size 1, offset 23):	 RO	  Packet buffer parity error
 *   rx_desc_fifo_par1 (size 1, offset 24):	 RO	  Rx descriptor FIFO parity error 1
 *   tx_desc_fifo_par1 (size 1, offset 25):	 RO	  Tx descriptor FIFO parity error 1
 *   _anon26 (size 5, offset 26):	 RSVD	  _
 *   int_asserted (size 1, offset 31):	 RO	  Interrupt asserted
 */

static inline uint32_t __DP(icr_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(icr_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0xc0));
}

static inline e1000_intreg_t __DP(icr_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_intreg_t __DP(icr_rd)( __DN(t) * _dev )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc0));
    return u.val;
}

// Register icr is not writeable


static inline int __DP(icr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(icr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc0));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register icr (Interrupt cause read):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.txdw;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txdw =\t0x%"PRIx8" (Transmit descriptor written back", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.txqe;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txqe =\t0x%"PRIx8" (Transmit queue empty", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.lsc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lsc =\t0x%"PRIx8" (Link status change", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rxseq;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxseq =\t0x%"PRIx8" (Receive sequence error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rxdmt0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxdmt0 =\t0x%"PRIx8" (Receive descriptor minimum threshold reached", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.rxo;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxo =\t0x%"PRIx8" (Receiver overrun", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rxt0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxt0 =\t0x%"PRIx8" (Receiver timer interrupt", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.mdac;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mdac =\t0x%"PRIx8" (MDI/O access complete", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rxcfg;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxcfg =\t0x%"PRIx8" (Received configuration symbols", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.gpi_sdp2;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " gpi_sdp2 =\t0x%"PRIx8" (General-purpose interrupt on SPD2", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.gpi_sdp3;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " gpi_sdp3 =\t0x%"PRIx8" (General-purpose interrupt on SPD3", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.txd_low;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txd_low =\t0x%"PRIx8" (Transmit descriptor low threshold", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.srpd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " srpd =\t0x%"PRIx8" (Small receive packet detected", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ack;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ack =\t0x%"PRIx8" (Receive ack frame detected", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.rx_desc_fifo_par0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rx_desc_fifo_par0 =\t0x%"PRIx8" (Rx descriptor FIFO parity error 0", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.tx_desc_fifo_par0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tx_desc_fifo_par0 =\t0x%"PRIx8" (Tx descriptor FIFO parity error 0", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pcie_master_par;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pcie_master_par =\t0x%"PRIx8" (PCIe master data FIFO parity error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pbpar;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pbpar =\t0x%"PRIx8" (Packet buffer parity error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rx_desc_fifo_par1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rx_desc_fifo_par1 =\t0x%"PRIx8" (Rx descriptor FIFO parity error 1", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.tx_desc_fifo_par1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tx_desc_fifo_par1 =\t0x%"PRIx8" (Tx descriptor FIFO parity error 1", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.int_asserted;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " int_asserted =\t0x%"PRIx8" (Interrupt asserted", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register itr (Interrupt throttling rate); type e1000.itr (Implicit type of Interrupt throttling rate register)
 */

/*
 * Dump of fields for register: itr
 *   interval (size 16, offset 0):	 RW	  Minimum inter-interrupt interval (x256ns)
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */

static inline uint32_t __DP(itr_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(itr_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0xc4));
}

static inline e1000_itr_t __DP(itr_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_itr_t __DP(itr_rd)( __DN(t) * _dev )
{
    e1000_itr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc4));
    return u.val;
}

static inline void __DP(itr_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(itr_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xc4),val);
}

static inline void __DP(itr_wr)( __DN(t) * _dev, e1000_itr_t val ) __attribute__ ((always_inline));
static inline void __DP(itr_wr)( __DN(t) * _dev, e1000_itr_t val )
{
    e1000_itr_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0xc4),u.raw);
}

static inline void __DP(itr_interval_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(itr_interval_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_itr_un  u;
    u.val._anon16 	= 0;
    u.val.interval = val;
    mackerel_write_addr_32(_dev->base,(0xc4),u.raw);
}


static inline int __DP(itr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(itr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_itr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc4));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register itr (Interrupt throttling rate):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.interval;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " interval =\t0x%0"PRIx16" (Minimum inter-interrupt interval (x256ns)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register ics (Interrupt cause write); type e1000.intreg (Interrupt register format)
 */

/*
 * Dump of fields for register: ics
 *   txdw (size 1, offset 0):	 WO	  Transmit descriptor written back
 *   txqe (size 1, offset 1):	 WO	  Transmit queue empty
 *   lsc (size 1, offset 2):	 WO	  Link status change
 *   rxseq (size 1, offset 3):	 WO	  Receive sequence error
 *   rxdmt0 (size 1, offset 4):	 WO	  Receive descriptor minimum threshold reached
 *   _anon5 (size 1, offset 5):	 RSVD	  _
 *   rxo (size 1, offset 6):	 WO	  Receiver overrun
 *   rxt0 (size 1, offset 7):	 WO	  Receiver timer interrupt
 *   _anon8 (size 1, offset 8):	 RSVD	  _
 *   mdac (size 1, offset 9):	 WO	  MDI/O access complete
 *   rxcfg (size 1, offset 10):	 WO	  Received configuration symbols
 *   _anon11 (size 2, offset 11):	 RSVD	  _
 *   gpi_sdp2 (size 1, offset 13):	 WO	  General-purpose interrupt on SPD2
 *   gpi_sdp3 (size 1, offset 14):	 WO	  General-purpose interrupt on SPD3
 *   txd_low (size 1, offset 15):	 WO	  Transmit descriptor low threshold
 *   srpd (size 1, offset 16):	 WO	  Small receive packet detected
 *   ack (size 1, offset 17):	 WO	  Receive ack frame detected
 *   _anon18 (size 2, offset 18):	 RSVD	  _
 *   rx_desc_fifo_par0 (size 1, offset 20):	 WO	  Rx descriptor FIFO parity error 0
 *   tx_desc_fifo_par0 (size 1, offset 21):	 WO	  Tx descriptor FIFO parity error 0
 *   pcie_master_par (size 1, offset 22):	 WO	  PCIe master data FIFO parity error
 *   pbpar (size 1, offset 23):	 WO	  Packet buffer parity error
 *   rx_desc_fifo_par1 (size 1, offset 24):	 WO	  Rx descriptor FIFO parity error 1
 *   tx_desc_fifo_par1 (size 1, offset 25):	 WO	  Tx descriptor FIFO parity error 1
 *   _anon26 (size 5, offset 26):	 RSVD	  _
 *   int_asserted (size 1, offset 31):	 WO	  Interrupt asserted
 */

// Register ics is not readable
static inline e1000_intreg_t __DP(ics_rd_shadow)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_intreg_t __DP(ics_rd_shadow)( __DN(t) * _dev )
{
    return _dev->ics_shadow.val;
}

static inline void __DP(ics_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(ics_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xc8),val);
}

static inline void __DP(ics_wr)( __DN(t) * _dev, e1000_intreg_t val ) __attribute__ ((always_inline));
static inline void __DP(ics_wr)( __DN(t) * _dev, e1000_intreg_t val )
{
    e1000_intreg_un  u;
    u.raw = _dev->ics_shadow.raw;
    u.val.txdw 	= val.txdw;
    u.val.txqe 	= val.txqe;
    u.val.lsc 	= val.lsc;
    u.val.rxseq 	= val.rxseq;
    u.val.rxdmt0 	= val.rxdmt0;
    u.val.rxo 	= val.rxo;
    u.val.rxt0 	= val.rxt0;
    u.val.mdac 	= val.mdac;
    u.val.rxcfg 	= val.rxcfg;
    u.val.gpi_sdp2 	= val.gpi_sdp2;
    u.val.gpi_sdp3 	= val.gpi_sdp3;
    u.val.txd_low 	= val.txd_low;
    u.val.srpd 	= val.srpd;
    u.val.ack 	= val.ack;
    u.val.rx_desc_fifo_par0 	= val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 	= val.tx_desc_fifo_par0;
    u.val.pcie_master_par 	= val.pcie_master_par;
    u.val.pbpar 	= val.pbpar;
    u.val.rx_desc_fifo_par1 	= val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 	= val.tx_desc_fifo_par1;
    u.val.int_asserted 	= val.int_asserted;
    mackerel_write_addr_32(_dev->base,(0xc8),u.raw);
    _dev->ics_shadow.val = u.val;
}

static inline void __DP(ics_txdw_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ics_txdw_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc8));
    u.val.txqe = _dev->ics_shadow.val.txqe;
    u.val.lsc = _dev->ics_shadow.val.lsc;
    u.val.rxseq = _dev->ics_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->ics_shadow.val.rxdmt0;
    u.val.rxo = _dev->ics_shadow.val.rxo;
    u.val.rxt0 = _dev->ics_shadow.val.rxt0;
    u.val.mdac = _dev->ics_shadow.val.mdac;
    u.val.rxcfg = _dev->ics_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->ics_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->ics_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->ics_shadow.val.txd_low;
    u.val.srpd = _dev->ics_shadow.val.srpd;
    u.val.ack = _dev->ics_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->ics_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->ics_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->ics_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->ics_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->ics_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->ics_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->ics_shadow.val.int_asserted;
    u.val.txdw = val;
    mackerel_write_addr_32(_dev->base,(0xc8),u.raw);
    _dev->ics_shadow.val = u.val;
}

static inline void __DP(ics_txqe_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ics_txqe_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc8));
    u.val.txdw = _dev->ics_shadow.val.txdw;
    u.val.lsc = _dev->ics_shadow.val.lsc;
    u.val.rxseq = _dev->ics_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->ics_shadow.val.rxdmt0;
    u.val.rxo = _dev->ics_shadow.val.rxo;
    u.val.rxt0 = _dev->ics_shadow.val.rxt0;
    u.val.mdac = _dev->ics_shadow.val.mdac;
    u.val.rxcfg = _dev->ics_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->ics_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->ics_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->ics_shadow.val.txd_low;
    u.val.srpd = _dev->ics_shadow.val.srpd;
    u.val.ack = _dev->ics_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->ics_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->ics_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->ics_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->ics_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->ics_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->ics_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->ics_shadow.val.int_asserted;
    u.val.txqe = val;
    mackerel_write_addr_32(_dev->base,(0xc8),u.raw);
    _dev->ics_shadow.val = u.val;
}

static inline void __DP(ics_lsc_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ics_lsc_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc8));
    u.val.txdw = _dev->ics_shadow.val.txdw;
    u.val.txqe = _dev->ics_shadow.val.txqe;
    u.val.rxseq = _dev->ics_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->ics_shadow.val.rxdmt0;
    u.val.rxo = _dev->ics_shadow.val.rxo;
    u.val.rxt0 = _dev->ics_shadow.val.rxt0;
    u.val.mdac = _dev->ics_shadow.val.mdac;
    u.val.rxcfg = _dev->ics_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->ics_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->ics_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->ics_shadow.val.txd_low;
    u.val.srpd = _dev->ics_shadow.val.srpd;
    u.val.ack = _dev->ics_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->ics_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->ics_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->ics_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->ics_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->ics_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->ics_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->ics_shadow.val.int_asserted;
    u.val.lsc = val;
    mackerel_write_addr_32(_dev->base,(0xc8),u.raw);
    _dev->ics_shadow.val = u.val;
}

static inline void __DP(ics_rxseq_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ics_rxseq_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc8));
    u.val.txdw = _dev->ics_shadow.val.txdw;
    u.val.txqe = _dev->ics_shadow.val.txqe;
    u.val.lsc = _dev->ics_shadow.val.lsc;
    u.val.rxdmt0 = _dev->ics_shadow.val.rxdmt0;
    u.val.rxo = _dev->ics_shadow.val.rxo;
    u.val.rxt0 = _dev->ics_shadow.val.rxt0;
    u.val.mdac = _dev->ics_shadow.val.mdac;
    u.val.rxcfg = _dev->ics_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->ics_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->ics_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->ics_shadow.val.txd_low;
    u.val.srpd = _dev->ics_shadow.val.srpd;
    u.val.ack = _dev->ics_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->ics_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->ics_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->ics_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->ics_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->ics_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->ics_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->ics_shadow.val.int_asserted;
    u.val.rxseq = val;
    mackerel_write_addr_32(_dev->base,(0xc8),u.raw);
    _dev->ics_shadow.val = u.val;
}

static inline void __DP(ics_rxdmt0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ics_rxdmt0_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc8));
    u.val.txdw = _dev->ics_shadow.val.txdw;
    u.val.txqe = _dev->ics_shadow.val.txqe;
    u.val.lsc = _dev->ics_shadow.val.lsc;
    u.val.rxseq = _dev->ics_shadow.val.rxseq;
    u.val.rxo = _dev->ics_shadow.val.rxo;
    u.val.rxt0 = _dev->ics_shadow.val.rxt0;
    u.val.mdac = _dev->ics_shadow.val.mdac;
    u.val.rxcfg = _dev->ics_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->ics_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->ics_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->ics_shadow.val.txd_low;
    u.val.srpd = _dev->ics_shadow.val.srpd;
    u.val.ack = _dev->ics_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->ics_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->ics_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->ics_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->ics_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->ics_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->ics_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->ics_shadow.val.int_asserted;
    u.val.rxdmt0 = val;
    mackerel_write_addr_32(_dev->base,(0xc8),u.raw);
    _dev->ics_shadow.val = u.val;
}

static inline void __DP(ics_rxo_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ics_rxo_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc8));
    u.val.txdw = _dev->ics_shadow.val.txdw;
    u.val.txqe = _dev->ics_shadow.val.txqe;
    u.val.lsc = _dev->ics_shadow.val.lsc;
    u.val.rxseq = _dev->ics_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->ics_shadow.val.rxdmt0;
    u.val.rxt0 = _dev->ics_shadow.val.rxt0;
    u.val.mdac = _dev->ics_shadow.val.mdac;
    u.val.rxcfg = _dev->ics_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->ics_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->ics_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->ics_shadow.val.txd_low;
    u.val.srpd = _dev->ics_shadow.val.srpd;
    u.val.ack = _dev->ics_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->ics_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->ics_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->ics_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->ics_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->ics_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->ics_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->ics_shadow.val.int_asserted;
    u.val.rxo = val;
    mackerel_write_addr_32(_dev->base,(0xc8),u.raw);
    _dev->ics_shadow.val = u.val;
}

static inline void __DP(ics_rxt0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ics_rxt0_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc8));
    u.val.txdw = _dev->ics_shadow.val.txdw;
    u.val.txqe = _dev->ics_shadow.val.txqe;
    u.val.lsc = _dev->ics_shadow.val.lsc;
    u.val.rxseq = _dev->ics_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->ics_shadow.val.rxdmt0;
    u.val.rxo = _dev->ics_shadow.val.rxo;
    u.val.mdac = _dev->ics_shadow.val.mdac;
    u.val.rxcfg = _dev->ics_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->ics_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->ics_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->ics_shadow.val.txd_low;
    u.val.srpd = _dev->ics_shadow.val.srpd;
    u.val.ack = _dev->ics_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->ics_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->ics_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->ics_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->ics_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->ics_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->ics_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->ics_shadow.val.int_asserted;
    u.val.rxt0 = val;
    mackerel_write_addr_32(_dev->base,(0xc8),u.raw);
    _dev->ics_shadow.val = u.val;
}

static inline void __DP(ics_mdac_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ics_mdac_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc8));
    u.val.txdw = _dev->ics_shadow.val.txdw;
    u.val.txqe = _dev->ics_shadow.val.txqe;
    u.val.lsc = _dev->ics_shadow.val.lsc;
    u.val.rxseq = _dev->ics_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->ics_shadow.val.rxdmt0;
    u.val.rxo = _dev->ics_shadow.val.rxo;
    u.val.rxt0 = _dev->ics_shadow.val.rxt0;
    u.val.rxcfg = _dev->ics_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->ics_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->ics_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->ics_shadow.val.txd_low;
    u.val.srpd = _dev->ics_shadow.val.srpd;
    u.val.ack = _dev->ics_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->ics_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->ics_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->ics_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->ics_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->ics_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->ics_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->ics_shadow.val.int_asserted;
    u.val.mdac = val;
    mackerel_write_addr_32(_dev->base,(0xc8),u.raw);
    _dev->ics_shadow.val = u.val;
}

static inline void __DP(ics_rxcfg_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ics_rxcfg_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc8));
    u.val.txdw = _dev->ics_shadow.val.txdw;
    u.val.txqe = _dev->ics_shadow.val.txqe;
    u.val.lsc = _dev->ics_shadow.val.lsc;
    u.val.rxseq = _dev->ics_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->ics_shadow.val.rxdmt0;
    u.val.rxo = _dev->ics_shadow.val.rxo;
    u.val.rxt0 = _dev->ics_shadow.val.rxt0;
    u.val.mdac = _dev->ics_shadow.val.mdac;
    u.val.gpi_sdp2 = _dev->ics_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->ics_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->ics_shadow.val.txd_low;
    u.val.srpd = _dev->ics_shadow.val.srpd;
    u.val.ack = _dev->ics_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->ics_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->ics_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->ics_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->ics_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->ics_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->ics_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->ics_shadow.val.int_asserted;
    u.val.rxcfg = val;
    mackerel_write_addr_32(_dev->base,(0xc8),u.raw);
    _dev->ics_shadow.val = u.val;
}

static inline void __DP(ics_gpi_sdp2_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ics_gpi_sdp2_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc8));
    u.val.txdw = _dev->ics_shadow.val.txdw;
    u.val.txqe = _dev->ics_shadow.val.txqe;
    u.val.lsc = _dev->ics_shadow.val.lsc;
    u.val.rxseq = _dev->ics_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->ics_shadow.val.rxdmt0;
    u.val.rxo = _dev->ics_shadow.val.rxo;
    u.val.rxt0 = _dev->ics_shadow.val.rxt0;
    u.val.mdac = _dev->ics_shadow.val.mdac;
    u.val.rxcfg = _dev->ics_shadow.val.rxcfg;
    u.val.gpi_sdp3 = _dev->ics_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->ics_shadow.val.txd_low;
    u.val.srpd = _dev->ics_shadow.val.srpd;
    u.val.ack = _dev->ics_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->ics_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->ics_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->ics_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->ics_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->ics_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->ics_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->ics_shadow.val.int_asserted;
    u.val.gpi_sdp2 = val;
    mackerel_write_addr_32(_dev->base,(0xc8),u.raw);
    _dev->ics_shadow.val = u.val;
}

static inline void __DP(ics_gpi_sdp3_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ics_gpi_sdp3_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc8));
    u.val.txdw = _dev->ics_shadow.val.txdw;
    u.val.txqe = _dev->ics_shadow.val.txqe;
    u.val.lsc = _dev->ics_shadow.val.lsc;
    u.val.rxseq = _dev->ics_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->ics_shadow.val.rxdmt0;
    u.val.rxo = _dev->ics_shadow.val.rxo;
    u.val.rxt0 = _dev->ics_shadow.val.rxt0;
    u.val.mdac = _dev->ics_shadow.val.mdac;
    u.val.rxcfg = _dev->ics_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->ics_shadow.val.gpi_sdp2;
    u.val.txd_low = _dev->ics_shadow.val.txd_low;
    u.val.srpd = _dev->ics_shadow.val.srpd;
    u.val.ack = _dev->ics_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->ics_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->ics_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->ics_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->ics_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->ics_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->ics_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->ics_shadow.val.int_asserted;
    u.val.gpi_sdp3 = val;
    mackerel_write_addr_32(_dev->base,(0xc8),u.raw);
    _dev->ics_shadow.val = u.val;
}

static inline void __DP(ics_txd_low_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ics_txd_low_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc8));
    u.val.txdw = _dev->ics_shadow.val.txdw;
    u.val.txqe = _dev->ics_shadow.val.txqe;
    u.val.lsc = _dev->ics_shadow.val.lsc;
    u.val.rxseq = _dev->ics_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->ics_shadow.val.rxdmt0;
    u.val.rxo = _dev->ics_shadow.val.rxo;
    u.val.rxt0 = _dev->ics_shadow.val.rxt0;
    u.val.mdac = _dev->ics_shadow.val.mdac;
    u.val.rxcfg = _dev->ics_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->ics_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->ics_shadow.val.gpi_sdp3;
    u.val.srpd = _dev->ics_shadow.val.srpd;
    u.val.ack = _dev->ics_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->ics_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->ics_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->ics_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->ics_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->ics_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->ics_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->ics_shadow.val.int_asserted;
    u.val.txd_low = val;
    mackerel_write_addr_32(_dev->base,(0xc8),u.raw);
    _dev->ics_shadow.val = u.val;
}

static inline void __DP(ics_srpd_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ics_srpd_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc8));
    u.val.txdw = _dev->ics_shadow.val.txdw;
    u.val.txqe = _dev->ics_shadow.val.txqe;
    u.val.lsc = _dev->ics_shadow.val.lsc;
    u.val.rxseq = _dev->ics_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->ics_shadow.val.rxdmt0;
    u.val.rxo = _dev->ics_shadow.val.rxo;
    u.val.rxt0 = _dev->ics_shadow.val.rxt0;
    u.val.mdac = _dev->ics_shadow.val.mdac;
    u.val.rxcfg = _dev->ics_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->ics_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->ics_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->ics_shadow.val.txd_low;
    u.val.ack = _dev->ics_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->ics_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->ics_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->ics_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->ics_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->ics_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->ics_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->ics_shadow.val.int_asserted;
    u.val.srpd = val;
    mackerel_write_addr_32(_dev->base,(0xc8),u.raw);
    _dev->ics_shadow.val = u.val;
}

static inline void __DP(ics_ack_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ics_ack_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc8));
    u.val.txdw = _dev->ics_shadow.val.txdw;
    u.val.txqe = _dev->ics_shadow.val.txqe;
    u.val.lsc = _dev->ics_shadow.val.lsc;
    u.val.rxseq = _dev->ics_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->ics_shadow.val.rxdmt0;
    u.val.rxo = _dev->ics_shadow.val.rxo;
    u.val.rxt0 = _dev->ics_shadow.val.rxt0;
    u.val.mdac = _dev->ics_shadow.val.mdac;
    u.val.rxcfg = _dev->ics_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->ics_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->ics_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->ics_shadow.val.txd_low;
    u.val.srpd = _dev->ics_shadow.val.srpd;
    u.val.rx_desc_fifo_par0 = _dev->ics_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->ics_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->ics_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->ics_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->ics_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->ics_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->ics_shadow.val.int_asserted;
    u.val.ack = val;
    mackerel_write_addr_32(_dev->base,(0xc8),u.raw);
    _dev->ics_shadow.val = u.val;
}

static inline void __DP(ics_rx_desc_fifo_par0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ics_rx_desc_fifo_par0_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc8));
    u.val.txdw = _dev->ics_shadow.val.txdw;
    u.val.txqe = _dev->ics_shadow.val.txqe;
    u.val.lsc = _dev->ics_shadow.val.lsc;
    u.val.rxseq = _dev->ics_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->ics_shadow.val.rxdmt0;
    u.val.rxo = _dev->ics_shadow.val.rxo;
    u.val.rxt0 = _dev->ics_shadow.val.rxt0;
    u.val.mdac = _dev->ics_shadow.val.mdac;
    u.val.rxcfg = _dev->ics_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->ics_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->ics_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->ics_shadow.val.txd_low;
    u.val.srpd = _dev->ics_shadow.val.srpd;
    u.val.ack = _dev->ics_shadow.val.ack;
    u.val.tx_desc_fifo_par0 = _dev->ics_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->ics_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->ics_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->ics_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->ics_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->ics_shadow.val.int_asserted;
    u.val.rx_desc_fifo_par0 = val;
    mackerel_write_addr_32(_dev->base,(0xc8),u.raw);
    _dev->ics_shadow.val = u.val;
}

static inline void __DP(ics_tx_desc_fifo_par0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ics_tx_desc_fifo_par0_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc8));
    u.val.txdw = _dev->ics_shadow.val.txdw;
    u.val.txqe = _dev->ics_shadow.val.txqe;
    u.val.lsc = _dev->ics_shadow.val.lsc;
    u.val.rxseq = _dev->ics_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->ics_shadow.val.rxdmt0;
    u.val.rxo = _dev->ics_shadow.val.rxo;
    u.val.rxt0 = _dev->ics_shadow.val.rxt0;
    u.val.mdac = _dev->ics_shadow.val.mdac;
    u.val.rxcfg = _dev->ics_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->ics_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->ics_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->ics_shadow.val.txd_low;
    u.val.srpd = _dev->ics_shadow.val.srpd;
    u.val.ack = _dev->ics_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->ics_shadow.val.rx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->ics_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->ics_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->ics_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->ics_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->ics_shadow.val.int_asserted;
    u.val.tx_desc_fifo_par0 = val;
    mackerel_write_addr_32(_dev->base,(0xc8),u.raw);
    _dev->ics_shadow.val = u.val;
}

static inline void __DP(ics_pcie_master_par_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ics_pcie_master_par_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc8));
    u.val.txdw = _dev->ics_shadow.val.txdw;
    u.val.txqe = _dev->ics_shadow.val.txqe;
    u.val.lsc = _dev->ics_shadow.val.lsc;
    u.val.rxseq = _dev->ics_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->ics_shadow.val.rxdmt0;
    u.val.rxo = _dev->ics_shadow.val.rxo;
    u.val.rxt0 = _dev->ics_shadow.val.rxt0;
    u.val.mdac = _dev->ics_shadow.val.mdac;
    u.val.rxcfg = _dev->ics_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->ics_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->ics_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->ics_shadow.val.txd_low;
    u.val.srpd = _dev->ics_shadow.val.srpd;
    u.val.ack = _dev->ics_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->ics_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->ics_shadow.val.tx_desc_fifo_par0;
    u.val.pbpar = _dev->ics_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->ics_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->ics_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->ics_shadow.val.int_asserted;
    u.val.pcie_master_par = val;
    mackerel_write_addr_32(_dev->base,(0xc8),u.raw);
    _dev->ics_shadow.val = u.val;
}

static inline void __DP(ics_pbpar_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ics_pbpar_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc8));
    u.val.txdw = _dev->ics_shadow.val.txdw;
    u.val.txqe = _dev->ics_shadow.val.txqe;
    u.val.lsc = _dev->ics_shadow.val.lsc;
    u.val.rxseq = _dev->ics_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->ics_shadow.val.rxdmt0;
    u.val.rxo = _dev->ics_shadow.val.rxo;
    u.val.rxt0 = _dev->ics_shadow.val.rxt0;
    u.val.mdac = _dev->ics_shadow.val.mdac;
    u.val.rxcfg = _dev->ics_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->ics_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->ics_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->ics_shadow.val.txd_low;
    u.val.srpd = _dev->ics_shadow.val.srpd;
    u.val.ack = _dev->ics_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->ics_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->ics_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->ics_shadow.val.pcie_master_par;
    u.val.rx_desc_fifo_par1 = _dev->ics_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->ics_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->ics_shadow.val.int_asserted;
    u.val.pbpar = val;
    mackerel_write_addr_32(_dev->base,(0xc8),u.raw);
    _dev->ics_shadow.val = u.val;
}

static inline void __DP(ics_rx_desc_fifo_par1_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ics_rx_desc_fifo_par1_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc8));
    u.val.txdw = _dev->ics_shadow.val.txdw;
    u.val.txqe = _dev->ics_shadow.val.txqe;
    u.val.lsc = _dev->ics_shadow.val.lsc;
    u.val.rxseq = _dev->ics_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->ics_shadow.val.rxdmt0;
    u.val.rxo = _dev->ics_shadow.val.rxo;
    u.val.rxt0 = _dev->ics_shadow.val.rxt0;
    u.val.mdac = _dev->ics_shadow.val.mdac;
    u.val.rxcfg = _dev->ics_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->ics_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->ics_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->ics_shadow.val.txd_low;
    u.val.srpd = _dev->ics_shadow.val.srpd;
    u.val.ack = _dev->ics_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->ics_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->ics_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->ics_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->ics_shadow.val.pbpar;
    u.val.tx_desc_fifo_par1 = _dev->ics_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->ics_shadow.val.int_asserted;
    u.val.rx_desc_fifo_par1 = val;
    mackerel_write_addr_32(_dev->base,(0xc8),u.raw);
    _dev->ics_shadow.val = u.val;
}

static inline void __DP(ics_tx_desc_fifo_par1_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ics_tx_desc_fifo_par1_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc8));
    u.val.txdw = _dev->ics_shadow.val.txdw;
    u.val.txqe = _dev->ics_shadow.val.txqe;
    u.val.lsc = _dev->ics_shadow.val.lsc;
    u.val.rxseq = _dev->ics_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->ics_shadow.val.rxdmt0;
    u.val.rxo = _dev->ics_shadow.val.rxo;
    u.val.rxt0 = _dev->ics_shadow.val.rxt0;
    u.val.mdac = _dev->ics_shadow.val.mdac;
    u.val.rxcfg = _dev->ics_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->ics_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->ics_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->ics_shadow.val.txd_low;
    u.val.srpd = _dev->ics_shadow.val.srpd;
    u.val.ack = _dev->ics_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->ics_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->ics_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->ics_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->ics_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->ics_shadow.val.rx_desc_fifo_par1;
    u.val.int_asserted = _dev->ics_shadow.val.int_asserted;
    u.val.tx_desc_fifo_par1 = val;
    mackerel_write_addr_32(_dev->base,(0xc8),u.raw);
    _dev->ics_shadow.val = u.val;
}

static inline void __DP(ics_int_asserted_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ics_int_asserted_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc8));
    u.val.txdw = _dev->ics_shadow.val.txdw;
    u.val.txqe = _dev->ics_shadow.val.txqe;
    u.val.lsc = _dev->ics_shadow.val.lsc;
    u.val.rxseq = _dev->ics_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->ics_shadow.val.rxdmt0;
    u.val.rxo = _dev->ics_shadow.val.rxo;
    u.val.rxt0 = _dev->ics_shadow.val.rxt0;
    u.val.mdac = _dev->ics_shadow.val.mdac;
    u.val.rxcfg = _dev->ics_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->ics_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->ics_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->ics_shadow.val.txd_low;
    u.val.srpd = _dev->ics_shadow.val.srpd;
    u.val.ack = _dev->ics_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->ics_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->ics_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->ics_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->ics_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->ics_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->ics_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = val;
    mackerel_write_addr_32(_dev->base,(0xc8),u.raw);
    _dev->ics_shadow.val = u.val;
}


static inline int __DP(ics_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ics_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is not readable
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ics (Interrupt cause write):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)_dev->ics_shadow.val.txdw;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txdw =\t0x%"PRIx8" (SHADOW of Transmit descriptor written back", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->ics_shadow.val.txqe;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txqe =\t0x%"PRIx8" (SHADOW of Transmit queue empty", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->ics_shadow.val.lsc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lsc =\t0x%"PRIx8" (SHADOW of Link status change", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->ics_shadow.val.rxseq;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxseq =\t0x%"PRIx8" (SHADOW of Receive sequence error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->ics_shadow.val.rxdmt0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxdmt0 =\t0x%"PRIx8" (SHADOW of Receive descriptor minimum threshold reached", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)_dev->ics_shadow.val.rxo;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxo =\t0x%"PRIx8" (SHADOW of Receiver overrun", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->ics_shadow.val.rxt0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxt0 =\t0x%"PRIx8" (SHADOW of Receiver timer interrupt", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)_dev->ics_shadow.val.mdac;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mdac =\t0x%"PRIx8" (SHADOW of MDI/O access complete", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->ics_shadow.val.rxcfg;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxcfg =\t0x%"PRIx8" (SHADOW of Received configuration symbols", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)_dev->ics_shadow.val.gpi_sdp2;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " gpi_sdp2 =\t0x%"PRIx8" (SHADOW of General-purpose interrupt on SPD2", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->ics_shadow.val.gpi_sdp3;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " gpi_sdp3 =\t0x%"PRIx8" (SHADOW of General-purpose interrupt on SPD3", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->ics_shadow.val.txd_low;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txd_low =\t0x%"PRIx8" (SHADOW of Transmit descriptor low threshold", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->ics_shadow.val.srpd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " srpd =\t0x%"PRIx8" (SHADOW of Small receive packet detected", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->ics_shadow.val.ack;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ack =\t0x%"PRIx8" (SHADOW of Receive ack frame detected", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)_dev->ics_shadow.val.rx_desc_fifo_par0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rx_desc_fifo_par0 =\t0x%"PRIx8" (SHADOW of Rx descriptor FIFO parity error 0", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->ics_shadow.val.tx_desc_fifo_par0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tx_desc_fifo_par0 =\t0x%"PRIx8" (SHADOW of Tx descriptor FIFO parity error 0", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->ics_shadow.val.pcie_master_par;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pcie_master_par =\t0x%"PRIx8" (SHADOW of PCIe master data FIFO parity error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->ics_shadow.val.pbpar;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pbpar =\t0x%"PRIx8" (SHADOW of Packet buffer parity error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->ics_shadow.val.rx_desc_fifo_par1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rx_desc_fifo_par1 =\t0x%"PRIx8" (SHADOW of Rx descriptor FIFO parity error 1", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->ics_shadow.val.tx_desc_fifo_par1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tx_desc_fifo_par1 =\t0x%"PRIx8" (SHADOW of Tx descriptor FIFO parity error 1", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)_dev->ics_shadow.val.int_asserted;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " int_asserted =\t0x%"PRIx8" (SHADOW of Interrupt asserted", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register ims (Interrupt mask set/read); type e1000.intreg (Interrupt register format)
 */

/*
 * Dump of fields for register: ims
 *   txdw (size 1, offset 0):	 RW	  Transmit descriptor written back
 *   txqe (size 1, offset 1):	 RW	  Transmit queue empty
 *   lsc (size 1, offset 2):	 RW	  Link status change
 *   rxseq (size 1, offset 3):	 RW	  Receive sequence error
 *   rxdmt0 (size 1, offset 4):	 RW	  Receive descriptor minimum threshold reached
 *   _anon5 (size 1, offset 5):	 RSVD	  _
 *   rxo (size 1, offset 6):	 RW	  Receiver overrun
 *   rxt0 (size 1, offset 7):	 RW	  Receiver timer interrupt
 *   _anon8 (size 1, offset 8):	 RSVD	  _
 *   mdac (size 1, offset 9):	 RW	  MDI/O access complete
 *   rxcfg (size 1, offset 10):	 RW	  Received configuration symbols
 *   _anon11 (size 2, offset 11):	 RSVD	  _
 *   gpi_sdp2 (size 1, offset 13):	 RW	  General-purpose interrupt on SPD2
 *   gpi_sdp3 (size 1, offset 14):	 RW	  General-purpose interrupt on SPD3
 *   txd_low (size 1, offset 15):	 RW	  Transmit descriptor low threshold
 *   srpd (size 1, offset 16):	 RW	  Small receive packet detected
 *   ack (size 1, offset 17):	 RW	  Receive ack frame detected
 *   _anon18 (size 2, offset 18):	 RSVD	  _
 *   rx_desc_fifo_par0 (size 1, offset 20):	 RW	  Rx descriptor FIFO parity error 0
 *   tx_desc_fifo_par0 (size 1, offset 21):	 RW	  Tx descriptor FIFO parity error 0
 *   pcie_master_par (size 1, offset 22):	 RW	  PCIe master data FIFO parity error
 *   pbpar (size 1, offset 23):	 RW	  Packet buffer parity error
 *   rx_desc_fifo_par1 (size 1, offset 24):	 RW	  Rx descriptor FIFO parity error 1
 *   tx_desc_fifo_par1 (size 1, offset 25):	 RW	  Tx descriptor FIFO parity error 1
 *   _anon26 (size 5, offset 26):	 RSVD	  _
 *   int_asserted (size 1, offset 31):	 RW	  Interrupt asserted
 */

static inline uint32_t __DP(ims_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ims_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0xd0));
}

static inline e1000_intreg_t __DP(ims_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_intreg_t __DP(ims_rd)( __DN(t) * _dev )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd0));
    return u.val;
}

static inline void __DP(ims_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(ims_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xd0),val);
}

static inline void __DP(ims_wr)( __DN(t) * _dev, e1000_intreg_t val ) __attribute__ ((always_inline));
static inline void __DP(ims_wr)( __DN(t) * _dev, e1000_intreg_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd0));
    u.val.txdw 	= val.txdw;
    u.val.txqe 	= val.txqe;
    u.val.lsc 	= val.lsc;
    u.val.rxseq 	= val.rxseq;
    u.val.rxdmt0 	= val.rxdmt0;
    u.val.rxo 	= val.rxo;
    u.val.rxt0 	= val.rxt0;
    u.val.mdac 	= val.mdac;
    u.val.rxcfg 	= val.rxcfg;
    u.val.gpi_sdp2 	= val.gpi_sdp2;
    u.val.gpi_sdp3 	= val.gpi_sdp3;
    u.val.txd_low 	= val.txd_low;
    u.val.srpd 	= val.srpd;
    u.val.ack 	= val.ack;
    u.val.rx_desc_fifo_par0 	= val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 	= val.tx_desc_fifo_par0;
    u.val.pcie_master_par 	= val.pcie_master_par;
    u.val.pbpar 	= val.pbpar;
    u.val.rx_desc_fifo_par1 	= val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 	= val.tx_desc_fifo_par1;
    u.val.int_asserted 	= val.int_asserted;
    mackerel_write_addr_32(_dev->base,(0xd0),u.raw);
}

static inline void __DP(ims_txdw_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ims_txdw_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd0));
    u.val.txdw = val;
    mackerel_write_addr_32(_dev->base,(0xd0),u.raw);
}

static inline void __DP(ims_txqe_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ims_txqe_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd0));
    u.val.txqe = val;
    mackerel_write_addr_32(_dev->base,(0xd0),u.raw);
}

static inline void __DP(ims_lsc_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ims_lsc_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd0));
    u.val.lsc = val;
    mackerel_write_addr_32(_dev->base,(0xd0),u.raw);
}

static inline void __DP(ims_rxseq_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ims_rxseq_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd0));
    u.val.rxseq = val;
    mackerel_write_addr_32(_dev->base,(0xd0),u.raw);
}

static inline void __DP(ims_rxdmt0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ims_rxdmt0_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd0));
    u.val.rxdmt0 = val;
    mackerel_write_addr_32(_dev->base,(0xd0),u.raw);
}

static inline void __DP(ims_rxo_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ims_rxo_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd0));
    u.val.rxo = val;
    mackerel_write_addr_32(_dev->base,(0xd0),u.raw);
}

static inline void __DP(ims_rxt0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ims_rxt0_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd0));
    u.val.rxt0 = val;
    mackerel_write_addr_32(_dev->base,(0xd0),u.raw);
}

static inline void __DP(ims_mdac_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ims_mdac_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd0));
    u.val.mdac = val;
    mackerel_write_addr_32(_dev->base,(0xd0),u.raw);
}

static inline void __DP(ims_rxcfg_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ims_rxcfg_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd0));
    u.val.rxcfg = val;
    mackerel_write_addr_32(_dev->base,(0xd0),u.raw);
}

static inline void __DP(ims_gpi_sdp2_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ims_gpi_sdp2_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd0));
    u.val.gpi_sdp2 = val;
    mackerel_write_addr_32(_dev->base,(0xd0),u.raw);
}

static inline void __DP(ims_gpi_sdp3_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ims_gpi_sdp3_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd0));
    u.val.gpi_sdp3 = val;
    mackerel_write_addr_32(_dev->base,(0xd0),u.raw);
}

static inline void __DP(ims_txd_low_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ims_txd_low_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd0));
    u.val.txd_low = val;
    mackerel_write_addr_32(_dev->base,(0xd0),u.raw);
}

static inline void __DP(ims_srpd_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ims_srpd_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd0));
    u.val.srpd = val;
    mackerel_write_addr_32(_dev->base,(0xd0),u.raw);
}

static inline void __DP(ims_ack_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ims_ack_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd0));
    u.val.ack = val;
    mackerel_write_addr_32(_dev->base,(0xd0),u.raw);
}

static inline void __DP(ims_rx_desc_fifo_par0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ims_rx_desc_fifo_par0_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd0));
    u.val.rx_desc_fifo_par0 = val;
    mackerel_write_addr_32(_dev->base,(0xd0),u.raw);
}

static inline void __DP(ims_tx_desc_fifo_par0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ims_tx_desc_fifo_par0_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd0));
    u.val.tx_desc_fifo_par0 = val;
    mackerel_write_addr_32(_dev->base,(0xd0),u.raw);
}

static inline void __DP(ims_pcie_master_par_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ims_pcie_master_par_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd0));
    u.val.pcie_master_par = val;
    mackerel_write_addr_32(_dev->base,(0xd0),u.raw);
}

static inline void __DP(ims_pbpar_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ims_pbpar_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd0));
    u.val.pbpar = val;
    mackerel_write_addr_32(_dev->base,(0xd0),u.raw);
}

static inline void __DP(ims_rx_desc_fifo_par1_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ims_rx_desc_fifo_par1_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd0));
    u.val.rx_desc_fifo_par1 = val;
    mackerel_write_addr_32(_dev->base,(0xd0),u.raw);
}

static inline void __DP(ims_tx_desc_fifo_par1_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ims_tx_desc_fifo_par1_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd0));
    u.val.tx_desc_fifo_par1 = val;
    mackerel_write_addr_32(_dev->base,(0xd0),u.raw);
}

static inline void __DP(ims_int_asserted_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ims_int_asserted_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd0));
    u.val.int_asserted = val;
    mackerel_write_addr_32(_dev->base,(0xd0),u.raw);
}


static inline int __DP(ims_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ims_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd0));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ims (Interrupt mask set/read):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.txdw;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txdw =\t0x%"PRIx8" (Transmit descriptor written back", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.txqe;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txqe =\t0x%"PRIx8" (Transmit queue empty", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.lsc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lsc =\t0x%"PRIx8" (Link status change", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rxseq;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxseq =\t0x%"PRIx8" (Receive sequence error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rxdmt0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxdmt0 =\t0x%"PRIx8" (Receive descriptor minimum threshold reached", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.rxo;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxo =\t0x%"PRIx8" (Receiver overrun", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rxt0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxt0 =\t0x%"PRIx8" (Receiver timer interrupt", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.mdac;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mdac =\t0x%"PRIx8" (MDI/O access complete", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rxcfg;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxcfg =\t0x%"PRIx8" (Received configuration symbols", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.gpi_sdp2;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " gpi_sdp2 =\t0x%"PRIx8" (General-purpose interrupt on SPD2", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.gpi_sdp3;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " gpi_sdp3 =\t0x%"PRIx8" (General-purpose interrupt on SPD3", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.txd_low;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txd_low =\t0x%"PRIx8" (Transmit descriptor low threshold", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.srpd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " srpd =\t0x%"PRIx8" (Small receive packet detected", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ack;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ack =\t0x%"PRIx8" (Receive ack frame detected", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.rx_desc_fifo_par0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rx_desc_fifo_par0 =\t0x%"PRIx8" (Rx descriptor FIFO parity error 0", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.tx_desc_fifo_par0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tx_desc_fifo_par0 =\t0x%"PRIx8" (Tx descriptor FIFO parity error 0", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pcie_master_par;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pcie_master_par =\t0x%"PRIx8" (PCIe master data FIFO parity error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pbpar;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pbpar =\t0x%"PRIx8" (Packet buffer parity error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rx_desc_fifo_par1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rx_desc_fifo_par1 =\t0x%"PRIx8" (Rx descriptor FIFO parity error 1", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.tx_desc_fifo_par1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tx_desc_fifo_par1 =\t0x%"PRIx8" (Tx descriptor FIFO parity error 1", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.int_asserted;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " int_asserted =\t0x%"PRIx8" (Interrupt asserted", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register imc (Interrupt mask clear); type e1000.intreg (Interrupt register format)
 */

/*
 * Dump of fields for register: imc
 *   txdw (size 1, offset 0):	 WO	  Transmit descriptor written back
 *   txqe (size 1, offset 1):	 WO	  Transmit queue empty
 *   lsc (size 1, offset 2):	 WO	  Link status change
 *   rxseq (size 1, offset 3):	 WO	  Receive sequence error
 *   rxdmt0 (size 1, offset 4):	 WO	  Receive descriptor minimum threshold reached
 *   _anon5 (size 1, offset 5):	 RSVD	  _
 *   rxo (size 1, offset 6):	 WO	  Receiver overrun
 *   rxt0 (size 1, offset 7):	 WO	  Receiver timer interrupt
 *   _anon8 (size 1, offset 8):	 RSVD	  _
 *   mdac (size 1, offset 9):	 WO	  MDI/O access complete
 *   rxcfg (size 1, offset 10):	 WO	  Received configuration symbols
 *   _anon11 (size 2, offset 11):	 RSVD	  _
 *   gpi_sdp2 (size 1, offset 13):	 WO	  General-purpose interrupt on SPD2
 *   gpi_sdp3 (size 1, offset 14):	 WO	  General-purpose interrupt on SPD3
 *   txd_low (size 1, offset 15):	 WO	  Transmit descriptor low threshold
 *   srpd (size 1, offset 16):	 WO	  Small receive packet detected
 *   ack (size 1, offset 17):	 WO	  Receive ack frame detected
 *   _anon18 (size 2, offset 18):	 RSVD	  _
 *   rx_desc_fifo_par0 (size 1, offset 20):	 WO	  Rx descriptor FIFO parity error 0
 *   tx_desc_fifo_par0 (size 1, offset 21):	 WO	  Tx descriptor FIFO parity error 0
 *   pcie_master_par (size 1, offset 22):	 WO	  PCIe master data FIFO parity error
 *   pbpar (size 1, offset 23):	 WO	  Packet buffer parity error
 *   rx_desc_fifo_par1 (size 1, offset 24):	 WO	  Rx descriptor FIFO parity error 1
 *   tx_desc_fifo_par1 (size 1, offset 25):	 WO	  Tx descriptor FIFO parity error 1
 *   _anon26 (size 5, offset 26):	 RSVD	  _
 *   int_asserted (size 1, offset 31):	 WO	  Interrupt asserted
 */

// Register imc is not readable
static inline e1000_intreg_t __DP(imc_rd_shadow)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_intreg_t __DP(imc_rd_shadow)( __DN(t) * _dev )
{
    return _dev->imc_shadow.val;
}

static inline void __DP(imc_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(imc_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xd8),val);
}

static inline void __DP(imc_wr)( __DN(t) * _dev, e1000_intreg_t val ) __attribute__ ((always_inline));
static inline void __DP(imc_wr)( __DN(t) * _dev, e1000_intreg_t val )
{
    e1000_intreg_un  u;
    u.raw = _dev->imc_shadow.raw;
    u.val.txdw 	= val.txdw;
    u.val.txqe 	= val.txqe;
    u.val.lsc 	= val.lsc;
    u.val.rxseq 	= val.rxseq;
    u.val.rxdmt0 	= val.rxdmt0;
    u.val.rxo 	= val.rxo;
    u.val.rxt0 	= val.rxt0;
    u.val.mdac 	= val.mdac;
    u.val.rxcfg 	= val.rxcfg;
    u.val.gpi_sdp2 	= val.gpi_sdp2;
    u.val.gpi_sdp3 	= val.gpi_sdp3;
    u.val.txd_low 	= val.txd_low;
    u.val.srpd 	= val.srpd;
    u.val.ack 	= val.ack;
    u.val.rx_desc_fifo_par0 	= val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 	= val.tx_desc_fifo_par0;
    u.val.pcie_master_par 	= val.pcie_master_par;
    u.val.pbpar 	= val.pbpar;
    u.val.rx_desc_fifo_par1 	= val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 	= val.tx_desc_fifo_par1;
    u.val.int_asserted 	= val.int_asserted;
    mackerel_write_addr_32(_dev->base,(0xd8),u.raw);
    _dev->imc_shadow.val = u.val;
}

static inline void __DP(imc_txdw_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(imc_txdw_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd8));
    u.val.txqe = _dev->imc_shadow.val.txqe;
    u.val.lsc = _dev->imc_shadow.val.lsc;
    u.val.rxseq = _dev->imc_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->imc_shadow.val.rxdmt0;
    u.val.rxo = _dev->imc_shadow.val.rxo;
    u.val.rxt0 = _dev->imc_shadow.val.rxt0;
    u.val.mdac = _dev->imc_shadow.val.mdac;
    u.val.rxcfg = _dev->imc_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->imc_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->imc_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->imc_shadow.val.txd_low;
    u.val.srpd = _dev->imc_shadow.val.srpd;
    u.val.ack = _dev->imc_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->imc_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->imc_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->imc_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->imc_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->imc_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->imc_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->imc_shadow.val.int_asserted;
    u.val.txdw = val;
    mackerel_write_addr_32(_dev->base,(0xd8),u.raw);
    _dev->imc_shadow.val = u.val;
}

static inline void __DP(imc_txqe_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(imc_txqe_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd8));
    u.val.txdw = _dev->imc_shadow.val.txdw;
    u.val.lsc = _dev->imc_shadow.val.lsc;
    u.val.rxseq = _dev->imc_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->imc_shadow.val.rxdmt0;
    u.val.rxo = _dev->imc_shadow.val.rxo;
    u.val.rxt0 = _dev->imc_shadow.val.rxt0;
    u.val.mdac = _dev->imc_shadow.val.mdac;
    u.val.rxcfg = _dev->imc_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->imc_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->imc_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->imc_shadow.val.txd_low;
    u.val.srpd = _dev->imc_shadow.val.srpd;
    u.val.ack = _dev->imc_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->imc_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->imc_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->imc_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->imc_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->imc_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->imc_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->imc_shadow.val.int_asserted;
    u.val.txqe = val;
    mackerel_write_addr_32(_dev->base,(0xd8),u.raw);
    _dev->imc_shadow.val = u.val;
}

static inline void __DP(imc_lsc_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(imc_lsc_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd8));
    u.val.txdw = _dev->imc_shadow.val.txdw;
    u.val.txqe = _dev->imc_shadow.val.txqe;
    u.val.rxseq = _dev->imc_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->imc_shadow.val.rxdmt0;
    u.val.rxo = _dev->imc_shadow.val.rxo;
    u.val.rxt0 = _dev->imc_shadow.val.rxt0;
    u.val.mdac = _dev->imc_shadow.val.mdac;
    u.val.rxcfg = _dev->imc_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->imc_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->imc_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->imc_shadow.val.txd_low;
    u.val.srpd = _dev->imc_shadow.val.srpd;
    u.val.ack = _dev->imc_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->imc_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->imc_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->imc_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->imc_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->imc_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->imc_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->imc_shadow.val.int_asserted;
    u.val.lsc = val;
    mackerel_write_addr_32(_dev->base,(0xd8),u.raw);
    _dev->imc_shadow.val = u.val;
}

static inline void __DP(imc_rxseq_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(imc_rxseq_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd8));
    u.val.txdw = _dev->imc_shadow.val.txdw;
    u.val.txqe = _dev->imc_shadow.val.txqe;
    u.val.lsc = _dev->imc_shadow.val.lsc;
    u.val.rxdmt0 = _dev->imc_shadow.val.rxdmt0;
    u.val.rxo = _dev->imc_shadow.val.rxo;
    u.val.rxt0 = _dev->imc_shadow.val.rxt0;
    u.val.mdac = _dev->imc_shadow.val.mdac;
    u.val.rxcfg = _dev->imc_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->imc_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->imc_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->imc_shadow.val.txd_low;
    u.val.srpd = _dev->imc_shadow.val.srpd;
    u.val.ack = _dev->imc_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->imc_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->imc_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->imc_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->imc_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->imc_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->imc_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->imc_shadow.val.int_asserted;
    u.val.rxseq = val;
    mackerel_write_addr_32(_dev->base,(0xd8),u.raw);
    _dev->imc_shadow.val = u.val;
}

static inline void __DP(imc_rxdmt0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(imc_rxdmt0_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd8));
    u.val.txdw = _dev->imc_shadow.val.txdw;
    u.val.txqe = _dev->imc_shadow.val.txqe;
    u.val.lsc = _dev->imc_shadow.val.lsc;
    u.val.rxseq = _dev->imc_shadow.val.rxseq;
    u.val.rxo = _dev->imc_shadow.val.rxo;
    u.val.rxt0 = _dev->imc_shadow.val.rxt0;
    u.val.mdac = _dev->imc_shadow.val.mdac;
    u.val.rxcfg = _dev->imc_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->imc_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->imc_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->imc_shadow.val.txd_low;
    u.val.srpd = _dev->imc_shadow.val.srpd;
    u.val.ack = _dev->imc_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->imc_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->imc_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->imc_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->imc_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->imc_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->imc_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->imc_shadow.val.int_asserted;
    u.val.rxdmt0 = val;
    mackerel_write_addr_32(_dev->base,(0xd8),u.raw);
    _dev->imc_shadow.val = u.val;
}

static inline void __DP(imc_rxo_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(imc_rxo_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd8));
    u.val.txdw = _dev->imc_shadow.val.txdw;
    u.val.txqe = _dev->imc_shadow.val.txqe;
    u.val.lsc = _dev->imc_shadow.val.lsc;
    u.val.rxseq = _dev->imc_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->imc_shadow.val.rxdmt0;
    u.val.rxt0 = _dev->imc_shadow.val.rxt0;
    u.val.mdac = _dev->imc_shadow.val.mdac;
    u.val.rxcfg = _dev->imc_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->imc_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->imc_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->imc_shadow.val.txd_low;
    u.val.srpd = _dev->imc_shadow.val.srpd;
    u.val.ack = _dev->imc_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->imc_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->imc_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->imc_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->imc_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->imc_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->imc_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->imc_shadow.val.int_asserted;
    u.val.rxo = val;
    mackerel_write_addr_32(_dev->base,(0xd8),u.raw);
    _dev->imc_shadow.val = u.val;
}

static inline void __DP(imc_rxt0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(imc_rxt0_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd8));
    u.val.txdw = _dev->imc_shadow.val.txdw;
    u.val.txqe = _dev->imc_shadow.val.txqe;
    u.val.lsc = _dev->imc_shadow.val.lsc;
    u.val.rxseq = _dev->imc_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->imc_shadow.val.rxdmt0;
    u.val.rxo = _dev->imc_shadow.val.rxo;
    u.val.mdac = _dev->imc_shadow.val.mdac;
    u.val.rxcfg = _dev->imc_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->imc_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->imc_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->imc_shadow.val.txd_low;
    u.val.srpd = _dev->imc_shadow.val.srpd;
    u.val.ack = _dev->imc_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->imc_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->imc_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->imc_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->imc_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->imc_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->imc_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->imc_shadow.val.int_asserted;
    u.val.rxt0 = val;
    mackerel_write_addr_32(_dev->base,(0xd8),u.raw);
    _dev->imc_shadow.val = u.val;
}

static inline void __DP(imc_mdac_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(imc_mdac_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd8));
    u.val.txdw = _dev->imc_shadow.val.txdw;
    u.val.txqe = _dev->imc_shadow.val.txqe;
    u.val.lsc = _dev->imc_shadow.val.lsc;
    u.val.rxseq = _dev->imc_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->imc_shadow.val.rxdmt0;
    u.val.rxo = _dev->imc_shadow.val.rxo;
    u.val.rxt0 = _dev->imc_shadow.val.rxt0;
    u.val.rxcfg = _dev->imc_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->imc_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->imc_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->imc_shadow.val.txd_low;
    u.val.srpd = _dev->imc_shadow.val.srpd;
    u.val.ack = _dev->imc_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->imc_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->imc_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->imc_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->imc_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->imc_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->imc_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->imc_shadow.val.int_asserted;
    u.val.mdac = val;
    mackerel_write_addr_32(_dev->base,(0xd8),u.raw);
    _dev->imc_shadow.val = u.val;
}

static inline void __DP(imc_rxcfg_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(imc_rxcfg_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd8));
    u.val.txdw = _dev->imc_shadow.val.txdw;
    u.val.txqe = _dev->imc_shadow.val.txqe;
    u.val.lsc = _dev->imc_shadow.val.lsc;
    u.val.rxseq = _dev->imc_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->imc_shadow.val.rxdmt0;
    u.val.rxo = _dev->imc_shadow.val.rxo;
    u.val.rxt0 = _dev->imc_shadow.val.rxt0;
    u.val.mdac = _dev->imc_shadow.val.mdac;
    u.val.gpi_sdp2 = _dev->imc_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->imc_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->imc_shadow.val.txd_low;
    u.val.srpd = _dev->imc_shadow.val.srpd;
    u.val.ack = _dev->imc_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->imc_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->imc_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->imc_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->imc_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->imc_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->imc_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->imc_shadow.val.int_asserted;
    u.val.rxcfg = val;
    mackerel_write_addr_32(_dev->base,(0xd8),u.raw);
    _dev->imc_shadow.val = u.val;
}

static inline void __DP(imc_gpi_sdp2_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(imc_gpi_sdp2_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd8));
    u.val.txdw = _dev->imc_shadow.val.txdw;
    u.val.txqe = _dev->imc_shadow.val.txqe;
    u.val.lsc = _dev->imc_shadow.val.lsc;
    u.val.rxseq = _dev->imc_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->imc_shadow.val.rxdmt0;
    u.val.rxo = _dev->imc_shadow.val.rxo;
    u.val.rxt0 = _dev->imc_shadow.val.rxt0;
    u.val.mdac = _dev->imc_shadow.val.mdac;
    u.val.rxcfg = _dev->imc_shadow.val.rxcfg;
    u.val.gpi_sdp3 = _dev->imc_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->imc_shadow.val.txd_low;
    u.val.srpd = _dev->imc_shadow.val.srpd;
    u.val.ack = _dev->imc_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->imc_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->imc_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->imc_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->imc_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->imc_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->imc_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->imc_shadow.val.int_asserted;
    u.val.gpi_sdp2 = val;
    mackerel_write_addr_32(_dev->base,(0xd8),u.raw);
    _dev->imc_shadow.val = u.val;
}

static inline void __DP(imc_gpi_sdp3_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(imc_gpi_sdp3_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd8));
    u.val.txdw = _dev->imc_shadow.val.txdw;
    u.val.txqe = _dev->imc_shadow.val.txqe;
    u.val.lsc = _dev->imc_shadow.val.lsc;
    u.val.rxseq = _dev->imc_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->imc_shadow.val.rxdmt0;
    u.val.rxo = _dev->imc_shadow.val.rxo;
    u.val.rxt0 = _dev->imc_shadow.val.rxt0;
    u.val.mdac = _dev->imc_shadow.val.mdac;
    u.val.rxcfg = _dev->imc_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->imc_shadow.val.gpi_sdp2;
    u.val.txd_low = _dev->imc_shadow.val.txd_low;
    u.val.srpd = _dev->imc_shadow.val.srpd;
    u.val.ack = _dev->imc_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->imc_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->imc_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->imc_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->imc_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->imc_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->imc_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->imc_shadow.val.int_asserted;
    u.val.gpi_sdp3 = val;
    mackerel_write_addr_32(_dev->base,(0xd8),u.raw);
    _dev->imc_shadow.val = u.val;
}

static inline void __DP(imc_txd_low_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(imc_txd_low_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd8));
    u.val.txdw = _dev->imc_shadow.val.txdw;
    u.val.txqe = _dev->imc_shadow.val.txqe;
    u.val.lsc = _dev->imc_shadow.val.lsc;
    u.val.rxseq = _dev->imc_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->imc_shadow.val.rxdmt0;
    u.val.rxo = _dev->imc_shadow.val.rxo;
    u.val.rxt0 = _dev->imc_shadow.val.rxt0;
    u.val.mdac = _dev->imc_shadow.val.mdac;
    u.val.rxcfg = _dev->imc_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->imc_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->imc_shadow.val.gpi_sdp3;
    u.val.srpd = _dev->imc_shadow.val.srpd;
    u.val.ack = _dev->imc_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->imc_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->imc_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->imc_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->imc_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->imc_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->imc_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->imc_shadow.val.int_asserted;
    u.val.txd_low = val;
    mackerel_write_addr_32(_dev->base,(0xd8),u.raw);
    _dev->imc_shadow.val = u.val;
}

static inline void __DP(imc_srpd_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(imc_srpd_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd8));
    u.val.txdw = _dev->imc_shadow.val.txdw;
    u.val.txqe = _dev->imc_shadow.val.txqe;
    u.val.lsc = _dev->imc_shadow.val.lsc;
    u.val.rxseq = _dev->imc_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->imc_shadow.val.rxdmt0;
    u.val.rxo = _dev->imc_shadow.val.rxo;
    u.val.rxt0 = _dev->imc_shadow.val.rxt0;
    u.val.mdac = _dev->imc_shadow.val.mdac;
    u.val.rxcfg = _dev->imc_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->imc_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->imc_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->imc_shadow.val.txd_low;
    u.val.ack = _dev->imc_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->imc_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->imc_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->imc_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->imc_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->imc_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->imc_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->imc_shadow.val.int_asserted;
    u.val.srpd = val;
    mackerel_write_addr_32(_dev->base,(0xd8),u.raw);
    _dev->imc_shadow.val = u.val;
}

static inline void __DP(imc_ack_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(imc_ack_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd8));
    u.val.txdw = _dev->imc_shadow.val.txdw;
    u.val.txqe = _dev->imc_shadow.val.txqe;
    u.val.lsc = _dev->imc_shadow.val.lsc;
    u.val.rxseq = _dev->imc_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->imc_shadow.val.rxdmt0;
    u.val.rxo = _dev->imc_shadow.val.rxo;
    u.val.rxt0 = _dev->imc_shadow.val.rxt0;
    u.val.mdac = _dev->imc_shadow.val.mdac;
    u.val.rxcfg = _dev->imc_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->imc_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->imc_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->imc_shadow.val.txd_low;
    u.val.srpd = _dev->imc_shadow.val.srpd;
    u.val.rx_desc_fifo_par0 = _dev->imc_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->imc_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->imc_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->imc_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->imc_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->imc_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->imc_shadow.val.int_asserted;
    u.val.ack = val;
    mackerel_write_addr_32(_dev->base,(0xd8),u.raw);
    _dev->imc_shadow.val = u.val;
}

static inline void __DP(imc_rx_desc_fifo_par0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(imc_rx_desc_fifo_par0_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd8));
    u.val.txdw = _dev->imc_shadow.val.txdw;
    u.val.txqe = _dev->imc_shadow.val.txqe;
    u.val.lsc = _dev->imc_shadow.val.lsc;
    u.val.rxseq = _dev->imc_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->imc_shadow.val.rxdmt0;
    u.val.rxo = _dev->imc_shadow.val.rxo;
    u.val.rxt0 = _dev->imc_shadow.val.rxt0;
    u.val.mdac = _dev->imc_shadow.val.mdac;
    u.val.rxcfg = _dev->imc_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->imc_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->imc_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->imc_shadow.val.txd_low;
    u.val.srpd = _dev->imc_shadow.val.srpd;
    u.val.ack = _dev->imc_shadow.val.ack;
    u.val.tx_desc_fifo_par0 = _dev->imc_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->imc_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->imc_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->imc_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->imc_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->imc_shadow.val.int_asserted;
    u.val.rx_desc_fifo_par0 = val;
    mackerel_write_addr_32(_dev->base,(0xd8),u.raw);
    _dev->imc_shadow.val = u.val;
}

static inline void __DP(imc_tx_desc_fifo_par0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(imc_tx_desc_fifo_par0_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd8));
    u.val.txdw = _dev->imc_shadow.val.txdw;
    u.val.txqe = _dev->imc_shadow.val.txqe;
    u.val.lsc = _dev->imc_shadow.val.lsc;
    u.val.rxseq = _dev->imc_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->imc_shadow.val.rxdmt0;
    u.val.rxo = _dev->imc_shadow.val.rxo;
    u.val.rxt0 = _dev->imc_shadow.val.rxt0;
    u.val.mdac = _dev->imc_shadow.val.mdac;
    u.val.rxcfg = _dev->imc_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->imc_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->imc_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->imc_shadow.val.txd_low;
    u.val.srpd = _dev->imc_shadow.val.srpd;
    u.val.ack = _dev->imc_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->imc_shadow.val.rx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->imc_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->imc_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->imc_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->imc_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->imc_shadow.val.int_asserted;
    u.val.tx_desc_fifo_par0 = val;
    mackerel_write_addr_32(_dev->base,(0xd8),u.raw);
    _dev->imc_shadow.val = u.val;
}

static inline void __DP(imc_pcie_master_par_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(imc_pcie_master_par_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd8));
    u.val.txdw = _dev->imc_shadow.val.txdw;
    u.val.txqe = _dev->imc_shadow.val.txqe;
    u.val.lsc = _dev->imc_shadow.val.lsc;
    u.val.rxseq = _dev->imc_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->imc_shadow.val.rxdmt0;
    u.val.rxo = _dev->imc_shadow.val.rxo;
    u.val.rxt0 = _dev->imc_shadow.val.rxt0;
    u.val.mdac = _dev->imc_shadow.val.mdac;
    u.val.rxcfg = _dev->imc_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->imc_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->imc_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->imc_shadow.val.txd_low;
    u.val.srpd = _dev->imc_shadow.val.srpd;
    u.val.ack = _dev->imc_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->imc_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->imc_shadow.val.tx_desc_fifo_par0;
    u.val.pbpar = _dev->imc_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->imc_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->imc_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->imc_shadow.val.int_asserted;
    u.val.pcie_master_par = val;
    mackerel_write_addr_32(_dev->base,(0xd8),u.raw);
    _dev->imc_shadow.val = u.val;
}

static inline void __DP(imc_pbpar_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(imc_pbpar_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd8));
    u.val.txdw = _dev->imc_shadow.val.txdw;
    u.val.txqe = _dev->imc_shadow.val.txqe;
    u.val.lsc = _dev->imc_shadow.val.lsc;
    u.val.rxseq = _dev->imc_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->imc_shadow.val.rxdmt0;
    u.val.rxo = _dev->imc_shadow.val.rxo;
    u.val.rxt0 = _dev->imc_shadow.val.rxt0;
    u.val.mdac = _dev->imc_shadow.val.mdac;
    u.val.rxcfg = _dev->imc_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->imc_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->imc_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->imc_shadow.val.txd_low;
    u.val.srpd = _dev->imc_shadow.val.srpd;
    u.val.ack = _dev->imc_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->imc_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->imc_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->imc_shadow.val.pcie_master_par;
    u.val.rx_desc_fifo_par1 = _dev->imc_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->imc_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->imc_shadow.val.int_asserted;
    u.val.pbpar = val;
    mackerel_write_addr_32(_dev->base,(0xd8),u.raw);
    _dev->imc_shadow.val = u.val;
}

static inline void __DP(imc_rx_desc_fifo_par1_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(imc_rx_desc_fifo_par1_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd8));
    u.val.txdw = _dev->imc_shadow.val.txdw;
    u.val.txqe = _dev->imc_shadow.val.txqe;
    u.val.lsc = _dev->imc_shadow.val.lsc;
    u.val.rxseq = _dev->imc_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->imc_shadow.val.rxdmt0;
    u.val.rxo = _dev->imc_shadow.val.rxo;
    u.val.rxt0 = _dev->imc_shadow.val.rxt0;
    u.val.mdac = _dev->imc_shadow.val.mdac;
    u.val.rxcfg = _dev->imc_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->imc_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->imc_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->imc_shadow.val.txd_low;
    u.val.srpd = _dev->imc_shadow.val.srpd;
    u.val.ack = _dev->imc_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->imc_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->imc_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->imc_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->imc_shadow.val.pbpar;
    u.val.tx_desc_fifo_par1 = _dev->imc_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = _dev->imc_shadow.val.int_asserted;
    u.val.rx_desc_fifo_par1 = val;
    mackerel_write_addr_32(_dev->base,(0xd8),u.raw);
    _dev->imc_shadow.val = u.val;
}

static inline void __DP(imc_tx_desc_fifo_par1_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(imc_tx_desc_fifo_par1_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd8));
    u.val.txdw = _dev->imc_shadow.val.txdw;
    u.val.txqe = _dev->imc_shadow.val.txqe;
    u.val.lsc = _dev->imc_shadow.val.lsc;
    u.val.rxseq = _dev->imc_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->imc_shadow.val.rxdmt0;
    u.val.rxo = _dev->imc_shadow.val.rxo;
    u.val.rxt0 = _dev->imc_shadow.val.rxt0;
    u.val.mdac = _dev->imc_shadow.val.mdac;
    u.val.rxcfg = _dev->imc_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->imc_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->imc_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->imc_shadow.val.txd_low;
    u.val.srpd = _dev->imc_shadow.val.srpd;
    u.val.ack = _dev->imc_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->imc_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->imc_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->imc_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->imc_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->imc_shadow.val.rx_desc_fifo_par1;
    u.val.int_asserted = _dev->imc_shadow.val.int_asserted;
    u.val.tx_desc_fifo_par1 = val;
    mackerel_write_addr_32(_dev->base,(0xd8),u.raw);
    _dev->imc_shadow.val = u.val;
}

static inline void __DP(imc_int_asserted_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(imc_int_asserted_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xd8));
    u.val.txdw = _dev->imc_shadow.val.txdw;
    u.val.txqe = _dev->imc_shadow.val.txqe;
    u.val.lsc = _dev->imc_shadow.val.lsc;
    u.val.rxseq = _dev->imc_shadow.val.rxseq;
    u.val.rxdmt0 = _dev->imc_shadow.val.rxdmt0;
    u.val.rxo = _dev->imc_shadow.val.rxo;
    u.val.rxt0 = _dev->imc_shadow.val.rxt0;
    u.val.mdac = _dev->imc_shadow.val.mdac;
    u.val.rxcfg = _dev->imc_shadow.val.rxcfg;
    u.val.gpi_sdp2 = _dev->imc_shadow.val.gpi_sdp2;
    u.val.gpi_sdp3 = _dev->imc_shadow.val.gpi_sdp3;
    u.val.txd_low = _dev->imc_shadow.val.txd_low;
    u.val.srpd = _dev->imc_shadow.val.srpd;
    u.val.ack = _dev->imc_shadow.val.ack;
    u.val.rx_desc_fifo_par0 = _dev->imc_shadow.val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 = _dev->imc_shadow.val.tx_desc_fifo_par0;
    u.val.pcie_master_par = _dev->imc_shadow.val.pcie_master_par;
    u.val.pbpar = _dev->imc_shadow.val.pbpar;
    u.val.rx_desc_fifo_par1 = _dev->imc_shadow.val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 = _dev->imc_shadow.val.tx_desc_fifo_par1;
    u.val.int_asserted = val;
    mackerel_write_addr_32(_dev->base,(0xd8),u.raw);
    _dev->imc_shadow.val = u.val;
}


static inline int __DP(imc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(imc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is not readable
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register imc (Interrupt mask clear):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)_dev->imc_shadow.val.txdw;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txdw =\t0x%"PRIx8" (SHADOW of Transmit descriptor written back", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->imc_shadow.val.txqe;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txqe =\t0x%"PRIx8" (SHADOW of Transmit queue empty", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->imc_shadow.val.lsc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lsc =\t0x%"PRIx8" (SHADOW of Link status change", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->imc_shadow.val.rxseq;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxseq =\t0x%"PRIx8" (SHADOW of Receive sequence error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->imc_shadow.val.rxdmt0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxdmt0 =\t0x%"PRIx8" (SHADOW of Receive descriptor minimum threshold reached", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)_dev->imc_shadow.val.rxo;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxo =\t0x%"PRIx8" (SHADOW of Receiver overrun", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->imc_shadow.val.rxt0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxt0 =\t0x%"PRIx8" (SHADOW of Receiver timer interrupt", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)_dev->imc_shadow.val.mdac;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mdac =\t0x%"PRIx8" (SHADOW of MDI/O access complete", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->imc_shadow.val.rxcfg;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxcfg =\t0x%"PRIx8" (SHADOW of Received configuration symbols", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)_dev->imc_shadow.val.gpi_sdp2;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " gpi_sdp2 =\t0x%"PRIx8" (SHADOW of General-purpose interrupt on SPD2", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->imc_shadow.val.gpi_sdp3;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " gpi_sdp3 =\t0x%"PRIx8" (SHADOW of General-purpose interrupt on SPD3", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->imc_shadow.val.txd_low;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txd_low =\t0x%"PRIx8" (SHADOW of Transmit descriptor low threshold", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->imc_shadow.val.srpd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " srpd =\t0x%"PRIx8" (SHADOW of Small receive packet detected", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->imc_shadow.val.ack;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ack =\t0x%"PRIx8" (SHADOW of Receive ack frame detected", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)_dev->imc_shadow.val.rx_desc_fifo_par0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rx_desc_fifo_par0 =\t0x%"PRIx8" (SHADOW of Rx descriptor FIFO parity error 0", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->imc_shadow.val.tx_desc_fifo_par0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tx_desc_fifo_par0 =\t0x%"PRIx8" (SHADOW of Tx descriptor FIFO parity error 0", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->imc_shadow.val.pcie_master_par;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pcie_master_par =\t0x%"PRIx8" (SHADOW of PCIe master data FIFO parity error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->imc_shadow.val.pbpar;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pbpar =\t0x%"PRIx8" (SHADOW of Packet buffer parity error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->imc_shadow.val.rx_desc_fifo_par1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rx_desc_fifo_par1 =\t0x%"PRIx8" (SHADOW of Rx descriptor FIFO parity error 1", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->imc_shadow.val.tx_desc_fifo_par1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tx_desc_fifo_par1 =\t0x%"PRIx8" (SHADOW of Tx descriptor FIFO parity error 1", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)_dev->imc_shadow.val.int_asserted;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " int_asserted =\t0x%"PRIx8" (SHADOW of Interrupt asserted", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register iam (Interrupt ack auto mask); type e1000.intreg (Interrupt register format)
 */

/*
 * Dump of fields for register: iam
 *   txdw (size 1, offset 0):	 RW	  Transmit descriptor written back
 *   txqe (size 1, offset 1):	 RW	  Transmit queue empty
 *   lsc (size 1, offset 2):	 RW	  Link status change
 *   rxseq (size 1, offset 3):	 RW	  Receive sequence error
 *   rxdmt0 (size 1, offset 4):	 RW	  Receive descriptor minimum threshold reached
 *   _anon5 (size 1, offset 5):	 RSVD	  _
 *   rxo (size 1, offset 6):	 RW	  Receiver overrun
 *   rxt0 (size 1, offset 7):	 RW	  Receiver timer interrupt
 *   _anon8 (size 1, offset 8):	 RSVD	  _
 *   mdac (size 1, offset 9):	 RW	  MDI/O access complete
 *   rxcfg (size 1, offset 10):	 RW	  Received configuration symbols
 *   _anon11 (size 2, offset 11):	 RSVD	  _
 *   gpi_sdp2 (size 1, offset 13):	 RW	  General-purpose interrupt on SPD2
 *   gpi_sdp3 (size 1, offset 14):	 RW	  General-purpose interrupt on SPD3
 *   txd_low (size 1, offset 15):	 RW	  Transmit descriptor low threshold
 *   srpd (size 1, offset 16):	 RW	  Small receive packet detected
 *   ack (size 1, offset 17):	 RW	  Receive ack frame detected
 *   _anon18 (size 2, offset 18):	 RSVD	  _
 *   rx_desc_fifo_par0 (size 1, offset 20):	 RW	  Rx descriptor FIFO parity error 0
 *   tx_desc_fifo_par0 (size 1, offset 21):	 RW	  Tx descriptor FIFO parity error 0
 *   pcie_master_par (size 1, offset 22):	 RW	  PCIe master data FIFO parity error
 *   pbpar (size 1, offset 23):	 RW	  Packet buffer parity error
 *   rx_desc_fifo_par1 (size 1, offset 24):	 RW	  Rx descriptor FIFO parity error 1
 *   tx_desc_fifo_par1 (size 1, offset 25):	 RW	  Tx descriptor FIFO parity error 1
 *   _anon26 (size 5, offset 26):	 RSVD	  _
 *   int_asserted (size 1, offset 31):	 RW	  Interrupt asserted
 */

static inline uint32_t __DP(iam_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(iam_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0xe0));
}

static inline e1000_intreg_t __DP(iam_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_intreg_t __DP(iam_rd)( __DN(t) * _dev )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe0));
    return u.val;
}

static inline void __DP(iam_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(iam_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xe0),val);
}

static inline void __DP(iam_wr)( __DN(t) * _dev, e1000_intreg_t val ) __attribute__ ((always_inline));
static inline void __DP(iam_wr)( __DN(t) * _dev, e1000_intreg_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe0));
    u.val.txdw 	= val.txdw;
    u.val.txqe 	= val.txqe;
    u.val.lsc 	= val.lsc;
    u.val.rxseq 	= val.rxseq;
    u.val.rxdmt0 	= val.rxdmt0;
    u.val.rxo 	= val.rxo;
    u.val.rxt0 	= val.rxt0;
    u.val.mdac 	= val.mdac;
    u.val.rxcfg 	= val.rxcfg;
    u.val.gpi_sdp2 	= val.gpi_sdp2;
    u.val.gpi_sdp3 	= val.gpi_sdp3;
    u.val.txd_low 	= val.txd_low;
    u.val.srpd 	= val.srpd;
    u.val.ack 	= val.ack;
    u.val.rx_desc_fifo_par0 	= val.rx_desc_fifo_par0;
    u.val.tx_desc_fifo_par0 	= val.tx_desc_fifo_par0;
    u.val.pcie_master_par 	= val.pcie_master_par;
    u.val.pbpar 	= val.pbpar;
    u.val.rx_desc_fifo_par1 	= val.rx_desc_fifo_par1;
    u.val.tx_desc_fifo_par1 	= val.tx_desc_fifo_par1;
    u.val.int_asserted 	= val.int_asserted;
    mackerel_write_addr_32(_dev->base,(0xe0),u.raw);
}

static inline void __DP(iam_txdw_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(iam_txdw_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe0));
    u.val.txdw = val;
    mackerel_write_addr_32(_dev->base,(0xe0),u.raw);
}

static inline void __DP(iam_txqe_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(iam_txqe_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe0));
    u.val.txqe = val;
    mackerel_write_addr_32(_dev->base,(0xe0),u.raw);
}

static inline void __DP(iam_lsc_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(iam_lsc_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe0));
    u.val.lsc = val;
    mackerel_write_addr_32(_dev->base,(0xe0),u.raw);
}

static inline void __DP(iam_rxseq_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(iam_rxseq_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe0));
    u.val.rxseq = val;
    mackerel_write_addr_32(_dev->base,(0xe0),u.raw);
}

static inline void __DP(iam_rxdmt0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(iam_rxdmt0_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe0));
    u.val.rxdmt0 = val;
    mackerel_write_addr_32(_dev->base,(0xe0),u.raw);
}

static inline void __DP(iam_rxo_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(iam_rxo_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe0));
    u.val.rxo = val;
    mackerel_write_addr_32(_dev->base,(0xe0),u.raw);
}

static inline void __DP(iam_rxt0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(iam_rxt0_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe0));
    u.val.rxt0 = val;
    mackerel_write_addr_32(_dev->base,(0xe0),u.raw);
}

static inline void __DP(iam_mdac_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(iam_mdac_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe0));
    u.val.mdac = val;
    mackerel_write_addr_32(_dev->base,(0xe0),u.raw);
}

static inline void __DP(iam_rxcfg_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(iam_rxcfg_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe0));
    u.val.rxcfg = val;
    mackerel_write_addr_32(_dev->base,(0xe0),u.raw);
}

static inline void __DP(iam_gpi_sdp2_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(iam_gpi_sdp2_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe0));
    u.val.gpi_sdp2 = val;
    mackerel_write_addr_32(_dev->base,(0xe0),u.raw);
}

static inline void __DP(iam_gpi_sdp3_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(iam_gpi_sdp3_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe0));
    u.val.gpi_sdp3 = val;
    mackerel_write_addr_32(_dev->base,(0xe0),u.raw);
}

static inline void __DP(iam_txd_low_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(iam_txd_low_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe0));
    u.val.txd_low = val;
    mackerel_write_addr_32(_dev->base,(0xe0),u.raw);
}

static inline void __DP(iam_srpd_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(iam_srpd_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe0));
    u.val.srpd = val;
    mackerel_write_addr_32(_dev->base,(0xe0),u.raw);
}

static inline void __DP(iam_ack_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(iam_ack_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe0));
    u.val.ack = val;
    mackerel_write_addr_32(_dev->base,(0xe0),u.raw);
}

static inline void __DP(iam_rx_desc_fifo_par0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(iam_rx_desc_fifo_par0_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe0));
    u.val.rx_desc_fifo_par0 = val;
    mackerel_write_addr_32(_dev->base,(0xe0),u.raw);
}

static inline void __DP(iam_tx_desc_fifo_par0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(iam_tx_desc_fifo_par0_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe0));
    u.val.tx_desc_fifo_par0 = val;
    mackerel_write_addr_32(_dev->base,(0xe0),u.raw);
}

static inline void __DP(iam_pcie_master_par_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(iam_pcie_master_par_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe0));
    u.val.pcie_master_par = val;
    mackerel_write_addr_32(_dev->base,(0xe0),u.raw);
}

static inline void __DP(iam_pbpar_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(iam_pbpar_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe0));
    u.val.pbpar = val;
    mackerel_write_addr_32(_dev->base,(0xe0),u.raw);
}

static inline void __DP(iam_rx_desc_fifo_par1_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(iam_rx_desc_fifo_par1_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe0));
    u.val.rx_desc_fifo_par1 = val;
    mackerel_write_addr_32(_dev->base,(0xe0),u.raw);
}

static inline void __DP(iam_tx_desc_fifo_par1_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(iam_tx_desc_fifo_par1_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe0));
    u.val.tx_desc_fifo_par1 = val;
    mackerel_write_addr_32(_dev->base,(0xe0),u.raw);
}

static inline void __DP(iam_int_asserted_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(iam_int_asserted_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe0));
    u.val.int_asserted = val;
    mackerel_write_addr_32(_dev->base,(0xe0),u.raw);
}


static inline int __DP(iam_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(iam_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_intreg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xe0));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register iam (Interrupt ack auto mask):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.txdw;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txdw =\t0x%"PRIx8" (Transmit descriptor written back", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.txqe;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txqe =\t0x%"PRIx8" (Transmit queue empty", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.lsc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lsc =\t0x%"PRIx8" (Link status change", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rxseq;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxseq =\t0x%"PRIx8" (Receive sequence error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rxdmt0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxdmt0 =\t0x%"PRIx8" (Receive descriptor minimum threshold reached", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.rxo;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxo =\t0x%"PRIx8" (Receiver overrun", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rxt0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxt0 =\t0x%"PRIx8" (Receiver timer interrupt", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.mdac;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mdac =\t0x%"PRIx8" (MDI/O access complete", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rxcfg;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxcfg =\t0x%"PRIx8" (Received configuration symbols", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.gpi_sdp2;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " gpi_sdp2 =\t0x%"PRIx8" (General-purpose interrupt on SPD2", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.gpi_sdp3;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " gpi_sdp3 =\t0x%"PRIx8" (General-purpose interrupt on SPD3", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.txd_low;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txd_low =\t0x%"PRIx8" (Transmit descriptor low threshold", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.srpd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " srpd =\t0x%"PRIx8" (Small receive packet detected", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ack;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ack =\t0x%"PRIx8" (Receive ack frame detected", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.rx_desc_fifo_par0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rx_desc_fifo_par0 =\t0x%"PRIx8" (Rx descriptor FIFO parity error 0", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.tx_desc_fifo_par0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tx_desc_fifo_par0 =\t0x%"PRIx8" (Tx descriptor FIFO parity error 0", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pcie_master_par;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pcie_master_par =\t0x%"PRIx8" (PCIe master data FIFO parity error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pbpar;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pbpar =\t0x%"PRIx8" (Packet buffer parity error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rx_desc_fifo_par1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rx_desc_fifo_par1 =\t0x%"PRIx8" (Rx descriptor FIFO parity error 1", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.tx_desc_fifo_par1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tx_desc_fifo_par1 =\t0x%"PRIx8" (Tx descriptor FIFO parity error 1", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.int_asserted;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " int_asserted =\t0x%"PRIx8" (Interrupt asserted", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register rctl (Receive control); type e1000.rctl (Implicit type of Receive control register)
 */

/*
 * Dump of fields for register: rctl
 *   _anon0 (size 1, offset 0):	 MBZ	  _
 *   en (size 1, offset 1):	 RW	  Receiver enable
 *   sbp (size 1, offset 2):	 RW	  Store bad packets
 *   upe (size 1, offset 3):	 RW	  Unicast promiscuous enabled
 *   mpe (size 1, offset 4):	 RW	  Multicast promiscuous enabled
 *   lpe (size 1, offset 5):	 RW	  Long packet reception enable
 *   lbm (size 2, offset 6):	 RW	  Loopback mode
 *   rdmts (size 2, offset 8):	 RW	  Receive descriptor minimum threshold size
 *   dtyp (size 2, offset 10):	 RW	  Descriptor type
 *   mo (size 2, offset 12):	 RW	  Multicast offset (12 bits starting at 36-val)
 *   _anon14 (size 1, offset 14):	 MBZ	  _
 *   bam (size 1, offset 15):	 RW	  Broadcast accept mode
 *   bsize (size 2, offset 16):	 RW	  Receive buffer size (see BSEX)
 *   vfe (size 1, offset 18):	 RW	  VLAN filter enable
 *   cfien (size 1, offset 19):	 RW	  Canonical form indicator enable
 *   cfi (size 1, offset 20):	 RW	  Canonical form indicator value
 *   _anon21 (size 1, offset 21):	 MBZ	  _
 *   dpf (size 1, offset 22):	 RW	  Discard pause frames
 *   pmcf (size 1, offset 23):	 RW	  Pass MAC control frames
 *   _anon24 (size 1, offset 24):	 MBZ	  _
 *   bsex (size 1, offset 25):	 RW	  Buffer size extension
 *   secrc (size 1, offset 26):	 RW	  Strip Ethernet CRC from packet
 *   flxbuf (size 4, offset 27):	 RW	  Flexible buffer size (in KB)
 *   _anon31 (size 1, offset 31):	 MBZ	  _
 */

static inline uint32_t __DP(rctl_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rctl_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x100));
}

static inline e1000_rctl_t __DP(rctl_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_rctl_t __DP(rctl_rd)( __DN(t) * _dev )
{
    e1000_rctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x100));
    return u.val;
}

static inline void __DP(rctl_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(rctl_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x100),val);
}

static inline void __DP(rctl_wr)( __DN(t) * _dev, e1000_rctl_t val ) __attribute__ ((always_inline));
static inline void __DP(rctl_wr)( __DN(t) * _dev, e1000_rctl_t val )
{
    e1000_rctl_un  u;
    u.val = val;
    u.val._anon0 	= 0;
    u.val._anon14 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon31 	= 0;
    mackerel_write_addr_32(_dev->base,(0x100),u.raw);
}

static inline void __DP(rctl_en_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rctl_en_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x100));
    u.val._anon0 	= 0;
    u.val._anon14 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon31 	= 0;
    u.val.en = val;
    mackerel_write_addr_32(_dev->base,(0x100),u.raw);
}

static inline void __DP(rctl_sbp_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rctl_sbp_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x100));
    u.val._anon0 	= 0;
    u.val._anon14 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon31 	= 0;
    u.val.sbp = val;
    mackerel_write_addr_32(_dev->base,(0x100),u.raw);
}

static inline void __DP(rctl_upe_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rctl_upe_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x100));
    u.val._anon0 	= 0;
    u.val._anon14 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon31 	= 0;
    u.val.upe = val;
    mackerel_write_addr_32(_dev->base,(0x100),u.raw);
}

static inline void __DP(rctl_mpe_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rctl_mpe_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x100));
    u.val._anon0 	= 0;
    u.val._anon14 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon31 	= 0;
    u.val.mpe = val;
    mackerel_write_addr_32(_dev->base,(0x100),u.raw);
}

static inline void __DP(rctl_lpe_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rctl_lpe_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x100));
    u.val._anon0 	= 0;
    u.val._anon14 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon31 	= 0;
    u.val.lpe = val;
    mackerel_write_addr_32(_dev->base,(0x100),u.raw);
}

static inline void __DP(rctl_lbm_wrf)( __DN(t) * _dev, e1000_lbmode_t val ) __attribute__ ((always_inline));
static inline void __DP(rctl_lbm_wrf)( __DN(t) * _dev, e1000_lbmode_t val )
{
    e1000_rctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x100));
    u.val._anon0 	= 0;
    u.val._anon14 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon31 	= 0;
    u.val.lbm = val;
    mackerel_write_addr_32(_dev->base,(0x100),u.raw);
}

static inline void __DP(rctl_rdmts_wrf)( __DN(t) * _dev, e1000_rxthresh_t val ) __attribute__ ((always_inline));
static inline void __DP(rctl_rdmts_wrf)( __DN(t) * _dev, e1000_rxthresh_t val )
{
    e1000_rctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x100));
    u.val._anon0 	= 0;
    u.val._anon14 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon31 	= 0;
    u.val.rdmts = val;
    mackerel_write_addr_32(_dev->base,(0x100),u.raw);
}

static inline void __DP(rctl_dtyp_wrf)( __DN(t) * _dev, e1000_dtype_t val ) __attribute__ ((always_inline));
static inline void __DP(rctl_dtyp_wrf)( __DN(t) * _dev, e1000_dtype_t val )
{
    e1000_rctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x100));
    u.val._anon0 	= 0;
    u.val._anon14 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon31 	= 0;
    u.val.dtyp = val;
    mackerel_write_addr_32(_dev->base,(0x100),u.raw);
}

static inline void __DP(rctl_mo_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rctl_mo_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x100));
    u.val._anon0 	= 0;
    u.val._anon14 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon31 	= 0;
    u.val.mo = val;
    mackerel_write_addr_32(_dev->base,(0x100),u.raw);
}

static inline void __DP(rctl_bam_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rctl_bam_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x100));
    u.val._anon0 	= 0;
    u.val._anon14 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon31 	= 0;
    u.val.bam = val;
    mackerel_write_addr_32(_dev->base,(0x100),u.raw);
}

static inline void __DP(rctl_bsize_wrf)( __DN(t) * _dev, e1000_rxbsize_t val ) __attribute__ ((always_inline));
static inline void __DP(rctl_bsize_wrf)( __DN(t) * _dev, e1000_rxbsize_t val )
{
    e1000_rctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x100));
    u.val._anon0 	= 0;
    u.val._anon14 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon31 	= 0;
    u.val.bsize = val;
    mackerel_write_addr_32(_dev->base,(0x100),u.raw);
}

static inline void __DP(rctl_vfe_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rctl_vfe_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x100));
    u.val._anon0 	= 0;
    u.val._anon14 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon31 	= 0;
    u.val.vfe = val;
    mackerel_write_addr_32(_dev->base,(0x100),u.raw);
}

static inline void __DP(rctl_cfien_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rctl_cfien_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x100));
    u.val._anon0 	= 0;
    u.val._anon14 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon31 	= 0;
    u.val.cfien = val;
    mackerel_write_addr_32(_dev->base,(0x100),u.raw);
}

static inline void __DP(rctl_cfi_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rctl_cfi_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x100));
    u.val._anon0 	= 0;
    u.val._anon14 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon31 	= 0;
    u.val.cfi = val;
    mackerel_write_addr_32(_dev->base,(0x100),u.raw);
}

static inline void __DP(rctl_dpf_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rctl_dpf_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x100));
    u.val._anon0 	= 0;
    u.val._anon14 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon31 	= 0;
    u.val.dpf = val;
    mackerel_write_addr_32(_dev->base,(0x100),u.raw);
}

static inline void __DP(rctl_pmcf_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rctl_pmcf_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x100));
    u.val._anon0 	= 0;
    u.val._anon14 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon31 	= 0;
    u.val.pmcf = val;
    mackerel_write_addr_32(_dev->base,(0x100),u.raw);
}

static inline void __DP(rctl_bsex_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rctl_bsex_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x100));
    u.val._anon0 	= 0;
    u.val._anon14 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon31 	= 0;
    u.val.bsex = val;
    mackerel_write_addr_32(_dev->base,(0x100),u.raw);
}

static inline void __DP(rctl_secrc_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rctl_secrc_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x100));
    u.val._anon0 	= 0;
    u.val._anon14 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon31 	= 0;
    u.val.secrc = val;
    mackerel_write_addr_32(_dev->base,(0x100),u.raw);
}

static inline void __DP(rctl_flxbuf_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rctl_flxbuf_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x100));
    u.val._anon0 	= 0;
    u.val._anon14 	= 0;
    u.val._anon21 	= 0;
    u.val._anon24 	= 0;
    u.val._anon31 	= 0;
    u.val.flxbuf = val;
    mackerel_write_addr_32(_dev->base,(0x100),u.raw);
}


static inline int __DP(rctl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rctl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_rctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x100));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rctl (Receive control):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.en;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " en =\t0x%"PRIx8" (Receiver enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sbp;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sbp =\t0x%"PRIx8" (Store bad packets", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.upe;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " upe =\t0x%"PRIx8" (Unicast promiscuous enabled", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mpe;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mpe =\t0x%"PRIx8" (Multicast promiscuous enabled", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.lpe;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lpe =\t0x%"PRIx8" (Long packet reception enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.lbm;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lbm =\t0x%"PRIx8" (Loopback mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_lbmode_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rdmts;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rdmts =\t0x%"PRIx8" (Receive descriptor minimum threshold size", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_rxthresh_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dtyp;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dtyp =\t0x%"PRIx8" (Descriptor type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_dtype_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mo;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mo =\t0x%"PRIx8" (Multicast offset (12 bits starting at 36-val)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.bam;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " bam =\t0x%"PRIx8" (Broadcast accept mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.bsize;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " bsize =\t0x%"PRIx8" (Receive buffer size (see BSEX)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_rxbsize_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vfe;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vfe =\t0x%"PRIx8" (VLAN filter enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.cfien;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " cfien =\t0x%"PRIx8" (Canonical form indicator enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.cfi;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " cfi =\t0x%"PRIx8" (Canonical form indicator value", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.dpf;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dpf =\t0x%"PRIx8" (Discard pause frames", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pmcf;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pmcf =\t0x%"PRIx8" (Pass MAC control frames", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.bsex;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " bsex =\t0x%"PRIx8" (Buffer size extension", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.secrc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " secrc =\t0x%"PRIx8" (Strip Ethernet CRC from packet", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.flxbuf;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " flxbuf =\t0x%"PRIx8" (Flexible buffer size (in KB)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register ert (Early receive threshold); type e1000.ert (Implicit type of Early receive threshold register)
 */

/*
 * Dump of fields for register: ert
 *   rxthresh (size 13, offset 0):	 RW	  Receive threshold value (x 8 bytes)
 *   _anon13 (size 1, offset 13):	 RSVD	  _
 *   _anon14 (size 18, offset 14):	 MBZ	  _
 */

static inline uint32_t __DP(ert_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ert_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x2008));
}

static inline e1000_ert_t __DP(ert_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_ert_t __DP(ert_rd)( __DN(t) * _dev )
{
    e1000_ert_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2008));
    return u.val;
}

static inline void __DP(ert_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(ert_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x2008),val);
}

static inline void __DP(ert_wr)( __DN(t) * _dev, e1000_ert_t val ) __attribute__ ((always_inline));
static inline void __DP(ert_wr)( __DN(t) * _dev, e1000_ert_t val )
{
    e1000_ert_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2008));
    u.val.rxthresh 	= val.rxthresh;
    u.val._anon14 	= val._anon14;
    u.val._anon14 	= 0;
    mackerel_write_addr_32(_dev->base,(0x2008),u.raw);
}

static inline void __DP(ert_rxthresh_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(ert_rxthresh_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_ert_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2008));
    u.val._anon14 	= 0;
    u.val.rxthresh = val;
    mackerel_write_addr_32(_dev->base,(0x2008),u.raw);
}


static inline int __DP(ert_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ert_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_ert_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2008));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ert (Early receive threshold):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.rxthresh;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxthresh =\t0x%0"PRIx16" (Receive threshold value (x 8 bytes)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    // skipping anonymous field
    return r;
}


/*
 * Register fcrtl (Flow control rx threshold low); type e1000.fcrtl (Implicit type of Flow control rx threshold low register)
 */

/*
 * Dump of fields for register: fcrtl
 *   _anon0 (size 3, offset 0):	 MBZ	  _
 *   rtl (size 13, offset 3):	 RW	  Recieve threshold low
 *   _anon16 (size 15, offset 16):	 MBZ	  _
 *   xone (size 1, offset 31):	 RW	  XON enable
 */

static inline uint32_t __DP(fcrtl_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(fcrtl_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x2160));
}

static inline e1000_fcrtl_t __DP(fcrtl_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_fcrtl_t __DP(fcrtl_rd)( __DN(t) * _dev )
{
    e1000_fcrtl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2160));
    return u.val;
}

static inline void __DP(fcrtl_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(fcrtl_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x2160),val);
}

static inline void __DP(fcrtl_wr)( __DN(t) * _dev, e1000_fcrtl_t val ) __attribute__ ((always_inline));
static inline void __DP(fcrtl_wr)( __DN(t) * _dev, e1000_fcrtl_t val )
{
    e1000_fcrtl_un  u;
    u.val = val;
    u.val._anon0 	= 0;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0x2160),u.raw);
}

static inline void __DP(fcrtl_rtl_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(fcrtl_rtl_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_fcrtl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2160));
    u.val._anon0 	= 0;
    u.val._anon16 	= 0;
    u.val.rtl = val;
    mackerel_write_addr_32(_dev->base,(0x2160),u.raw);
}

static inline void __DP(fcrtl_xone_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fcrtl_xone_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_fcrtl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2160));
    u.val._anon0 	= 0;
    u.val._anon16 	= 0;
    u.val.xone = val;
    mackerel_write_addr_32(_dev->base,(0x2160),u.raw);
}


static inline int __DP(fcrtl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(fcrtl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_fcrtl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2160));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register fcrtl (Flow control rx threshold low):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint16_t pv = (uint16_t)u.val.rtl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rtl =\t0x%0"PRIx16" (Recieve threshold low", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.xone;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " xone =\t0x%"PRIx8" (XON enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register fcrth (Flow control rx threshold high); type e1000.fcrth (Implicit type of Flow control rx threshold high register)
 */

/*
 * Dump of fields for register: fcrth
 *   _anon0 (size 3, offset 0):	 MBZ	  _
 *   rth (size 13, offset 3):	 RW	  Recieve threshold high
 *   _anon16 (size 15, offset 16):	 MBZ	  _
 *   flowcntdis (size 1, offset 31):	 RW	  Flow control disable
 */

static inline uint32_t __DP(fcrth_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(fcrth_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x2168));
}

static inline e1000_fcrth_t __DP(fcrth_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_fcrth_t __DP(fcrth_rd)( __DN(t) * _dev )
{
    e1000_fcrth_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2168));
    return u.val;
}

static inline void __DP(fcrth_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(fcrth_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x2168),val);
}

static inline void __DP(fcrth_wr)( __DN(t) * _dev, e1000_fcrth_t val ) __attribute__ ((always_inline));
static inline void __DP(fcrth_wr)( __DN(t) * _dev, e1000_fcrth_t val )
{
    e1000_fcrth_un  u;
    u.val = val;
    u.val._anon0 	= 0;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0x2168),u.raw);
}

static inline void __DP(fcrth_rth_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(fcrth_rth_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_fcrth_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2168));
    u.val._anon0 	= 0;
    u.val._anon16 	= 0;
    u.val.rth = val;
    mackerel_write_addr_32(_dev->base,(0x2168),u.raw);
}

static inline void __DP(fcrth_flowcntdis_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fcrth_flowcntdis_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_fcrth_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2168));
    u.val._anon0 	= 0;
    u.val._anon16 	= 0;
    u.val.flowcntdis = val;
    mackerel_write_addr_32(_dev->base,(0x2168),u.raw);
}


static inline int __DP(fcrth_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(fcrth_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_fcrth_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2168));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register fcrth (Flow control rx threshold high):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint16_t pv = (uint16_t)u.val.rth;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rth =\t0x%0"PRIx16" (Recieve threshold high", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.flowcntdis;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " flowcntdis =\t0x%"PRIx8" (Flow control disable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register psrctl (Packet split rx control); type e1000.psrctl (Implicit type of Packet split rx control register)
 */

/*
 * Dump of fields for register: psrctl
 *   bsize0 (size 7, offset 0):	 RW	  Receive buffer 0 size (x 128 bytes)
 *   _anon7 (size 1, offset 7):	 MBZ	  _
 *   bsize1 (size 7, offset 8):	 RW	  Receive buffer 1 size (x 1 kbytes)
 *   _anon15 (size 1, offset 15):	 MBZ	  _
 *   bsize2 (size 7, offset 16):	 RW	  Receive buffer 2 size (x 1 kbytes)
 *   _anon23 (size 1, offset 23):	 MBZ	  _
 *   bsize3 (size 7, offset 24):	 RW	  Receive buffer 3 size (x 1 kbytes)
 *   _anon31 (size 1, offset 31):	 MBZ	  _
 */

static inline uint32_t __DP(psrctl_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(psrctl_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x2170));
}

static inline e1000_psrctl_t __DP(psrctl_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_psrctl_t __DP(psrctl_rd)( __DN(t) * _dev )
{
    e1000_psrctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2170));
    return u.val;
}

static inline void __DP(psrctl_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(psrctl_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x2170),val);
}

static inline void __DP(psrctl_wr)( __DN(t) * _dev, e1000_psrctl_t val ) __attribute__ ((always_inline));
static inline void __DP(psrctl_wr)( __DN(t) * _dev, e1000_psrctl_t val )
{
    e1000_psrctl_un  u;
    u.val = val;
    u.val._anon7 	= 0;
    u.val._anon15 	= 0;
    u.val._anon23 	= 0;
    u.val._anon31 	= 0;
    mackerel_write_addr_32(_dev->base,(0x2170),u.raw);
}

static inline void __DP(psrctl_bsize0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(psrctl_bsize0_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_psrctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2170));
    u.val._anon7 	= 0;
    u.val._anon15 	= 0;
    u.val._anon23 	= 0;
    u.val._anon31 	= 0;
    u.val.bsize0 = val;
    mackerel_write_addr_32(_dev->base,(0x2170),u.raw);
}

static inline void __DP(psrctl_bsize1_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(psrctl_bsize1_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_psrctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2170));
    u.val._anon7 	= 0;
    u.val._anon15 	= 0;
    u.val._anon23 	= 0;
    u.val._anon31 	= 0;
    u.val.bsize1 = val;
    mackerel_write_addr_32(_dev->base,(0x2170),u.raw);
}

static inline void __DP(psrctl_bsize2_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(psrctl_bsize2_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_psrctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2170));
    u.val._anon7 	= 0;
    u.val._anon15 	= 0;
    u.val._anon23 	= 0;
    u.val._anon31 	= 0;
    u.val.bsize2 = val;
    mackerel_write_addr_32(_dev->base,(0x2170),u.raw);
}

static inline void __DP(psrctl_bsize3_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(psrctl_bsize3_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_psrctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2170));
    u.val._anon7 	= 0;
    u.val._anon15 	= 0;
    u.val._anon23 	= 0;
    u.val._anon31 	= 0;
    u.val.bsize3 = val;
    mackerel_write_addr_32(_dev->base,(0x2170),u.raw);
}


static inline int __DP(psrctl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(psrctl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_psrctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2170));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register psrctl (Packet split rx control):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.bsize0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " bsize0 =\t0x%"PRIx8" (Receive buffer 0 size (x 128 bytes)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.bsize1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " bsize1 =\t0x%"PRIx8" (Receive buffer 1 size (x 1 kbytes)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.bsize2;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " bsize2 =\t0x%"PRIx8" (Receive buffer 2 size (x 1 kbytes)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.bsize3;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " bsize3 =\t0x%"PRIx8" (Receive buffer 3 size (x 1 kbytes)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register rdbal (Rx descr. base addr low); type e1000.uint32
 */
static const int __DP(rdbal_length) = 0x2;
static inline uint32_t __DP(rdbal_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(rdbal_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x2800) + (_i * 256));
}

static inline uint32_t __DP(rdbal_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(rdbal_rd)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x2800) + (_i * 256));
}

static inline void __DP(rdbal_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(rdbal_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x2800) + (_i * 256),val);
}

static inline void __DP(rdbal_wr)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(rdbal_wr)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x2800) + (_i * 256),val);
}


static inline int __DP(rdbal_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(rdbal_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register rdbal[%d] (Rx descr. base addr low):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x2800) + (_i * 256)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}
static inline int __DP(rdbal_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rdbal_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x2; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(rdbal_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register rdbah (Rx descr. base addr high); type e1000.uint32
 */
static const int __DP(rdbah_length) = 0x2;
static inline uint32_t __DP(rdbah_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(rdbah_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x2804) + (_i * 256));
}

static inline uint32_t __DP(rdbah_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(rdbah_rd)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x2804) + (_i * 256));
}

static inline void __DP(rdbah_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(rdbah_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x2804) + (_i * 256),val);
}

static inline void __DP(rdbah_wr)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(rdbah_wr)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x2804) + (_i * 256),val);
}


static inline int __DP(rdbah_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(rdbah_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register rdbah[%d] (Rx descr. base addr high):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x2804) + (_i * 256)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}
static inline int __DP(rdbah_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rdbah_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x2; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(rdbah_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register rdlen (Rx descriptor length); type e1000.dqlen (Descriptor length value)
 */

/*
 * Dump of fields for register: rdlen
 *   _anon0 (size 7, offset 0):	 MBZ	  _
 *   len (size 13, offset 7):	 RW	  Num. descriptors (x8)
 *   _anon20 (size 12, offset 20):	 MBZ	  _
 */
static const int __DP(rdlen_length) = 0x2;
static inline uint32_t __DP(rdlen_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(rdlen_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x2808) + (_i * 256));
}

static inline e1000_dqlen_t __DP(rdlen_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline e1000_dqlen_t __DP(rdlen_rd)( __DN(t) * _dev, int _i )
{
    e1000_dqlen_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2808) + (_i * 256));
    return u.val;
}

static inline void __DP(rdlen_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(rdlen_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x2808) + (_i * 256),val);
}

static inline void __DP(rdlen_wr)( __DN(t) * _dev, int _i, e1000_dqlen_t val ) __attribute__ ((always_inline));
static inline void __DP(rdlen_wr)( __DN(t) * _dev, int _i, e1000_dqlen_t val )
{
    e1000_dqlen_un  u;
    u.val = val;
    u.val._anon0 	= 0;
    u.val._anon20 	= 0;
    mackerel_write_addr_32(_dev->base,(0x2808) + (_i * 256),u.raw);
}

static inline void __DP(rdlen_len_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(rdlen_len_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    e1000_dqlen_un  u;
    u.val._anon0 	= 0;
    u.val._anon20 	= 0;
    u.val.len = val;
    mackerel_write_addr_32(_dev->base,(0x2808) + (_i * 256),u.raw);
}


static inline int __DP(rdlen_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(rdlen_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    e1000_dqlen_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2808) + (_i * 256));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register rdlen[%d] (Rx descriptor length):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint16_t pv = (uint16_t)u.val.len;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " len =\t0x%0"PRIx16" (Num. descriptors (x8)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(rdlen_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rdlen_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x2; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(rdlen_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register rdh (Rx descr. head); type e1000.dqval (Descriptor head/tail value)
 */

/*
 * Dump of fields for register: rdh
 *   val (size 16, offset 0):	 RW	  value
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(rdh_length) = 0x2;
static inline uint32_t __DP(rdh_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(rdh_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x2810) + (_i * 256));
}

static inline e1000_dqval_t __DP(rdh_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline e1000_dqval_t __DP(rdh_rd)( __DN(t) * _dev, int _i )
{
    e1000_dqval_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2810) + (_i * 256));
    return u.val;
}

static inline void __DP(rdh_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(rdh_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x2810) + (_i * 256),val);
}

static inline void __DP(rdh_wr)( __DN(t) * _dev, int _i, e1000_dqval_t val ) __attribute__ ((always_inline));
static inline void __DP(rdh_wr)( __DN(t) * _dev, int _i, e1000_dqval_t val )
{
    e1000_dqval_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0x2810) + (_i * 256),u.raw);
}

static inline void __DP(rdh_val_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(rdh_val_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    e1000_dqval_un  u;
    u.val._anon16 	= 0;
    u.val.val = val;
    mackerel_write_addr_32(_dev->base,(0x2810) + (_i * 256),u.raw);
}


static inline int __DP(rdh_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(rdh_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    e1000_dqval_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2810) + (_i * 256));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register rdh[%d] (Rx descr. head):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.val;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " val =\t0x%0"PRIx16" (value", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(rdh_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rdh_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x2; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(rdh_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register rdt (Rx descr. tail); type e1000.dqval (Descriptor head/tail value)
 */

/*
 * Dump of fields for register: rdt
 *   val (size 16, offset 0):	 RW	  value
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(rdt_length) = 0x2;
static inline uint32_t __DP(rdt_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(rdt_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x2818) + (_i * 256));
}

static inline e1000_dqval_t __DP(rdt_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline e1000_dqval_t __DP(rdt_rd)( __DN(t) * _dev, int _i )
{
    e1000_dqval_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2818) + (_i * 256));
    return u.val;
}

static inline void __DP(rdt_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(rdt_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x2818) + (_i * 256),val);
}

static inline void __DP(rdt_wr)( __DN(t) * _dev, int _i, e1000_dqval_t val ) __attribute__ ((always_inline));
static inline void __DP(rdt_wr)( __DN(t) * _dev, int _i, e1000_dqval_t val )
{
    e1000_dqval_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0x2818) + (_i * 256),u.raw);
}

static inline void __DP(rdt_val_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(rdt_val_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    e1000_dqval_un  u;
    u.val._anon16 	= 0;
    u.val.val = val;
    mackerel_write_addr_32(_dev->base,(0x2818) + (_i * 256),u.raw);
}


static inline int __DP(rdt_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(rdt_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    e1000_dqval_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2818) + (_i * 256));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register rdt[%d] (Rx descr. tail):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.val;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " val =\t0x%0"PRIx16" (value", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(rdt_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rdt_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x2; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(rdt_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register rdtr (Rx. interrupt delay timer); type e1000.rdtr (Implicit type of Rx. interrupt delay timer register)
 */

/*
 * Dump of fields for register: rdtr
 *   delay (size 16, offset 0):	 RW	  delay timer (x 1.024us)
 *   _anon16 (size 15, offset 16):	 MBZ	  _
 *   fpd (size 1, offset 31):	 RW	  Flush partial descriptor block
 */

static inline uint32_t __DP(rdtr_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rdtr_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x2820));
}

static inline e1000_rdtr_t __DP(rdtr_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_rdtr_t __DP(rdtr_rd)( __DN(t) * _dev )
{
    e1000_rdtr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2820));
    return u.val;
}

static inline void __DP(rdtr_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(rdtr_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x2820),val);
}

static inline void __DP(rdtr_wr)( __DN(t) * _dev, e1000_rdtr_t val ) __attribute__ ((always_inline));
static inline void __DP(rdtr_wr)( __DN(t) * _dev, e1000_rdtr_t val )
{
    e1000_rdtr_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0x2820),u.raw);
}

static inline void __DP(rdtr_delay_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(rdtr_delay_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_rdtr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2820));
    u.val._anon16 	= 0;
    u.val.delay = val;
    mackerel_write_addr_32(_dev->base,(0x2820),u.raw);
}

static inline void __DP(rdtr_fpd_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rdtr_fpd_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rdtr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2820));
    u.val._anon16 	= 0;
    u.val.fpd = val;
    mackerel_write_addr_32(_dev->base,(0x2820),u.raw);
}


static inline int __DP(rdtr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rdtr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_rdtr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2820));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rdtr (Rx. interrupt delay timer):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.delay;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " delay =\t0x%0"PRIx16" (delay timer (x 1.024us)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.fpd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fpd =\t0x%"PRIx8" (Flush partial descriptor block", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register rxdctl (Rx descriptor control); type e1000.rxdctl (Implicit type of Rx descriptor control register array)
 */

/*
 * Dump of fields for register: rxdctl
 *   pthresh (size 6, offset 0):	 RW	  Prefetch threshold
 *   _anon6 (size 2, offset 6):	 MBZ	  _
 *   hthresh (size 6, offset 8):	 RW	  Host threshold
 *   _anon14 (size 2, offset 14):	 MBZ	  _
 *   wthresh (size 6, offset 16):	 RW	  Write back threshold
 *   _anon22 (size 2, offset 22):	 MBZ	  _
 *   gran (size 1, offset 24):	 RW	  Granularity
 *   _anon25 (size 7, offset 25):	 MBZ	  _
 */
static const int __DP(rxdctl_length) = 0x2;
static inline uint32_t __DP(rxdctl_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(rxdctl_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x2828) + (_i * 256));
}

static inline e1000_rxdctl_t __DP(rxdctl_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline e1000_rxdctl_t __DP(rxdctl_rd)( __DN(t) * _dev, int _i )
{
    e1000_rxdctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2828) + (_i * 256));
    return u.val;
}

static inline void __DP(rxdctl_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(rxdctl_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x2828) + (_i * 256),val);
}

static inline void __DP(rxdctl_wr)( __DN(t) * _dev, int _i, e1000_rxdctl_t val ) __attribute__ ((always_inline));
static inline void __DP(rxdctl_wr)( __DN(t) * _dev, int _i, e1000_rxdctl_t val )
{
    e1000_rxdctl_un  u;
    u.val = val;
    u.val._anon6 	= 0;
    u.val._anon14 	= 0;
    u.val._anon22 	= 0;
    u.val._anon25 	= 0;
    mackerel_write_addr_32(_dev->base,(0x2828) + (_i * 256),u.raw);
}

static inline void __DP(rxdctl_pthresh_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rxdctl_pthresh_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    e1000_rxdctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2828) + (_i * 256));
    u.val._anon6 	= 0;
    u.val._anon14 	= 0;
    u.val._anon22 	= 0;
    u.val._anon25 	= 0;
    u.val.pthresh = val;
    mackerel_write_addr_32(_dev->base,(0x2828) + (_i * 256),u.raw);
}

static inline void __DP(rxdctl_hthresh_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rxdctl_hthresh_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    e1000_rxdctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2828) + (_i * 256));
    u.val._anon6 	= 0;
    u.val._anon14 	= 0;
    u.val._anon22 	= 0;
    u.val._anon25 	= 0;
    u.val.hthresh = val;
    mackerel_write_addr_32(_dev->base,(0x2828) + (_i * 256),u.raw);
}

static inline void __DP(rxdctl_wthresh_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rxdctl_wthresh_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    e1000_rxdctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2828) + (_i * 256));
    u.val._anon6 	= 0;
    u.val._anon14 	= 0;
    u.val._anon22 	= 0;
    u.val._anon25 	= 0;
    u.val.wthresh = val;
    mackerel_write_addr_32(_dev->base,(0x2828) + (_i * 256),u.raw);
}

static inline void __DP(rxdctl_gran_wrf)( __DN(t) * _dev, int _i, e1000_threshgran_t val ) __attribute__ ((always_inline));
static inline void __DP(rxdctl_gran_wrf)( __DN(t) * _dev, int _i, e1000_threshgran_t val )
{
    e1000_rxdctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2828) + (_i * 256));
    u.val._anon6 	= 0;
    u.val._anon14 	= 0;
    u.val._anon22 	= 0;
    u.val._anon25 	= 0;
    u.val.gran = val;
    mackerel_write_addr_32(_dev->base,(0x2828) + (_i * 256),u.raw);
}


static inline int __DP(rxdctl_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(rxdctl_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    e1000_rxdctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2828) + (_i * 256));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register rxdctl[%d] (Rx descriptor control):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.pthresh;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pthresh =\t0x%"PRIx8" (Prefetch threshold", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.hthresh;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " hthresh =\t0x%"PRIx8" (Host threshold", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.wthresh;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wthresh =\t0x%"PRIx8" (Write back threshold", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.gran;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " gran =\t0x%"PRIx8" (Granularity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_threshgran_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(rxdctl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rxdctl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x2; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(rxdctl_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register radv (Rx absolute intr. delay); type e1000.radv (Implicit type of Rx absolute intr. delay register)
 */

/*
 * Dump of fields for register: radv
 *   idv (size 16, offset 0):	 RW	  Interrupt delay value
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */

static inline uint32_t __DP(radv_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(radv_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x282c));
}

static inline e1000_radv_t __DP(radv_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_radv_t __DP(radv_rd)( __DN(t) * _dev )
{
    e1000_radv_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x282c));
    return u.val;
}

static inline void __DP(radv_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(radv_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x282c),val);
}

static inline void __DP(radv_wr)( __DN(t) * _dev, e1000_radv_t val ) __attribute__ ((always_inline));
static inline void __DP(radv_wr)( __DN(t) * _dev, e1000_radv_t val )
{
    e1000_radv_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0x282c),u.raw);
}

static inline void __DP(radv_idv_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(radv_idv_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_radv_un  u;
    u.val._anon16 	= 0;
    u.val.idv = val;
    mackerel_write_addr_32(_dev->base,(0x282c),u.raw);
}


static inline int __DP(radv_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(radv_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_radv_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x282c));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register radv (Rx absolute intr. delay):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.idv;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " idv =\t0x%0"PRIx16" (Interrupt delay value", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register rsrpd (Rx small packet detect interrupt); type e1000.rsrpd (Implicit type of Rx small packet detect interrupt register)
 */

/*
 * Dump of fields for register: rsrpd
 *   size (size 12, offset 0):	 RW	  Max size of small packet
 *   _anon12 (size 20, offset 12):	 MBZ	  _
 */

static inline uint32_t __DP(rsrpd_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rsrpd_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x2c00));
}

static inline e1000_rsrpd_t __DP(rsrpd_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_rsrpd_t __DP(rsrpd_rd)( __DN(t) * _dev )
{
    e1000_rsrpd_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2c00));
    return u.val;
}

static inline void __DP(rsrpd_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(rsrpd_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x2c00),val);
}

static inline void __DP(rsrpd_wr)( __DN(t) * _dev, e1000_rsrpd_t val ) __attribute__ ((always_inline));
static inline void __DP(rsrpd_wr)( __DN(t) * _dev, e1000_rsrpd_t val )
{
    e1000_rsrpd_un  u;
    u.val = val;
    u.val._anon12 	= 0;
    mackerel_write_addr_32(_dev->base,(0x2c00),u.raw);
}

static inline void __DP(rsrpd_size_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(rsrpd_size_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_rsrpd_un  u;
    u.val._anon12 	= 0;
    u.val.size = val;
    mackerel_write_addr_32(_dev->base,(0x2c00),u.raw);
}


static inline int __DP(rsrpd_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rsrpd_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_rsrpd_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2c00));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rsrpd (Rx small packet detect interrupt):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.size;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " size =\t0x%0"PRIx16" (Max size of small packet", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register raid (Rx ACK interrupt delay); type e1000.raid (Implicit type of Rx ACK interrupt delay register)
 */

/*
 * Dump of fields for register: raid
 *   idv (size 16, offset 0):	 RW	  Interrupt delay value (x 1.024us)
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */

static inline uint32_t __DP(raid_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(raid_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x2c08));
}

static inline e1000_raid_t __DP(raid_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_raid_t __DP(raid_rd)( __DN(t) * _dev )
{
    e1000_raid_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2c08));
    return u.val;
}

static inline void __DP(raid_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(raid_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x2c08),val);
}

static inline void __DP(raid_wr)( __DN(t) * _dev, e1000_raid_t val ) __attribute__ ((always_inline));
static inline void __DP(raid_wr)( __DN(t) * _dev, e1000_raid_t val )
{
    e1000_raid_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0x2c08),u.raw);
}

static inline void __DP(raid_idv_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(raid_idv_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_raid_un  u;
    u.val._anon16 	= 0;
    u.val.idv = val;
    mackerel_write_addr_32(_dev->base,(0x2c08),u.raw);
}


static inline int __DP(raid_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(raid_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_raid_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x2c08));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register raid (Rx ACK interrupt delay):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.idv;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " idv =\t0x%0"PRIx16" (Interrupt delay value (x 1.024us)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register cpuvec (CPU vector); type e1000.uint32
 */

static inline uint32_t __DP(cpuvec_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(cpuvec_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x2c10));
}

static inline uint32_t __DP(cpuvec_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(cpuvec_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x2c10));
}

static inline void __DP(cpuvec_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(cpuvec_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x2c10),val);
}

static inline void __DP(cpuvec_wr)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(cpuvec_wr)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x2c10),val);
}


static inline int __DP(cpuvec_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(cpuvec_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register cpuvec (CPU vector):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x2c10)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register rxcsum (Receive checksum control); type e1000.rxcsum (Implicit type of Receive checksum control register)
 */

/*
 * Dump of fields for register: rxcsum
 *   pcss (size 8, offset 0):	 RW	  Packet checksum start
 *   ipofld (size 1, offset 8):	 RW	  IP checksum offload enable
 *   tuofld (size 1, offset 9):	 RW	  TCP/UDP checksum offload enable
 *   _anon10 (size 22, offset 10):	 MBZ	  _
 */

static inline uint32_t __DP(rxcsum_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rxcsum_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5000));
}

static inline e1000_rxcsum_t __DP(rxcsum_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_rxcsum_t __DP(rxcsum_rd)( __DN(t) * _dev )
{
    e1000_rxcsum_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5000));
    return u.val;
}

static inline void __DP(rxcsum_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(rxcsum_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5000),val);
}

static inline void __DP(rxcsum_wr)( __DN(t) * _dev, e1000_rxcsum_t val ) __attribute__ ((always_inline));
static inline void __DP(rxcsum_wr)( __DN(t) * _dev, e1000_rxcsum_t val )
{
    e1000_rxcsum_un  u;
    u.val = val;
    u.val._anon10 	= 0;
    mackerel_write_addr_32(_dev->base,(0x5000),u.raw);
}

static inline void __DP(rxcsum_pcss_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rxcsum_pcss_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rxcsum_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5000));
    u.val._anon10 	= 0;
    u.val.pcss = val;
    mackerel_write_addr_32(_dev->base,(0x5000),u.raw);
}

static inline void __DP(rxcsum_ipofld_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rxcsum_ipofld_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rxcsum_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5000));
    u.val._anon10 	= 0;
    u.val.ipofld = val;
    mackerel_write_addr_32(_dev->base,(0x5000),u.raw);
}

static inline void __DP(rxcsum_tuofld_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rxcsum_tuofld_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rxcsum_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5000));
    u.val._anon10 	= 0;
    u.val.tuofld = val;
    mackerel_write_addr_32(_dev->base,(0x5000),u.raw);
}


static inline int __DP(rxcsum_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rxcsum_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_rxcsum_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5000));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rxcsum (Receive checksum control):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.pcss;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pcss =\t0x%"PRIx8" (Packet checksum start", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ipofld;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ipofld =\t0x%"PRIx8" (IP checksum offload enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.tuofld;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tuofld =\t0x%"PRIx8" (TCP/UDP checksum offload enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register rfctl (Receive filter control); type e1000.rfctl (Implicit type of Receive filter control register)
 */

/*
 * Dump of fields for register: rfctl
 *   iscsi_dis (size 1, offset 0):	 RW	  iSCSI filtering disable
 *   iscsi_dwc (size 5, offset 1):	 RW	  iSCSI dword count
 *   nfsw_dis (size 1, offset 6):	 RW	  NFS write filtering disable
 *   nfsr_dis (size 1, offset 7):	 RW	  NFS read filtering disable
 *   nfs_ver (size 2, offset 8):	 RW	  NFS version (+2)
 *   ipv6_dis (size 1, offset 10):	 RW	  IPv6 filtering disable
 *   ipv6xsum_dis (size 1, offset 11):	 RW	  IPv6 xsum disable
 *   ackdis (size 1, offset 12):	 RW	  ACK accelerator disable
 *   ackd_dis (size 1, offset 13):	 RW	  ACK data disable
 *   ipfrsp_dis (size 1, offset 14):	 RW	  IP fragment split disable
 *   exsten (size 1, offset 15):	 RW	  Extended status enable
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */

static inline uint32_t __DP(rfctl_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rfctl_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5008));
}

static inline e1000_rfctl_t __DP(rfctl_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_rfctl_t __DP(rfctl_rd)( __DN(t) * _dev )
{
    e1000_rfctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5008));
    return u.val;
}

static inline void __DP(rfctl_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(rfctl_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5008),val);
}

static inline void __DP(rfctl_wr)( __DN(t) * _dev, e1000_rfctl_t val ) __attribute__ ((always_inline));
static inline void __DP(rfctl_wr)( __DN(t) * _dev, e1000_rfctl_t val )
{
    e1000_rfctl_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0x5008),u.raw);
}

static inline void __DP(rfctl_iscsi_dis_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rfctl_iscsi_dis_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rfctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5008));
    u.val._anon16 	= 0;
    u.val.iscsi_dis = val;
    mackerel_write_addr_32(_dev->base,(0x5008),u.raw);
}

static inline void __DP(rfctl_iscsi_dwc_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rfctl_iscsi_dwc_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rfctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5008));
    u.val._anon16 	= 0;
    u.val.iscsi_dwc = val;
    mackerel_write_addr_32(_dev->base,(0x5008),u.raw);
}

static inline void __DP(rfctl_nfsw_dis_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rfctl_nfsw_dis_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rfctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5008));
    u.val._anon16 	= 0;
    u.val.nfsw_dis = val;
    mackerel_write_addr_32(_dev->base,(0x5008),u.raw);
}

static inline void __DP(rfctl_nfsr_dis_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rfctl_nfsr_dis_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rfctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5008));
    u.val._anon16 	= 0;
    u.val.nfsr_dis = val;
    mackerel_write_addr_32(_dev->base,(0x5008),u.raw);
}

static inline void __DP(rfctl_nfs_ver_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rfctl_nfs_ver_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rfctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5008));
    u.val._anon16 	= 0;
    u.val.nfs_ver = val;
    mackerel_write_addr_32(_dev->base,(0x5008),u.raw);
}

static inline void __DP(rfctl_ipv6_dis_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rfctl_ipv6_dis_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rfctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5008));
    u.val._anon16 	= 0;
    u.val.ipv6_dis = val;
    mackerel_write_addr_32(_dev->base,(0x5008),u.raw);
}

static inline void __DP(rfctl_ipv6xsum_dis_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rfctl_ipv6xsum_dis_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rfctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5008));
    u.val._anon16 	= 0;
    u.val.ipv6xsum_dis = val;
    mackerel_write_addr_32(_dev->base,(0x5008),u.raw);
}

static inline void __DP(rfctl_ackdis_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rfctl_ackdis_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rfctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5008));
    u.val._anon16 	= 0;
    u.val.ackdis = val;
    mackerel_write_addr_32(_dev->base,(0x5008),u.raw);
}

static inline void __DP(rfctl_ackd_dis_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rfctl_ackd_dis_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rfctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5008));
    u.val._anon16 	= 0;
    u.val.ackd_dis = val;
    mackerel_write_addr_32(_dev->base,(0x5008),u.raw);
}

static inline void __DP(rfctl_ipfrsp_dis_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rfctl_ipfrsp_dis_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rfctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5008));
    u.val._anon16 	= 0;
    u.val.ipfrsp_dis = val;
    mackerel_write_addr_32(_dev->base,(0x5008),u.raw);
}

static inline void __DP(rfctl_exsten_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rfctl_exsten_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_rfctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5008));
    u.val._anon16 	= 0;
    u.val.exsten = val;
    mackerel_write_addr_32(_dev->base,(0x5008),u.raw);
}


static inline int __DP(rfctl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rfctl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_rfctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5008));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rfctl (Receive filter control):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.iscsi_dis;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " iscsi_dis =\t0x%"PRIx8" (iSCSI filtering disable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.iscsi_dwc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " iscsi_dwc =\t0x%"PRIx8" (iSCSI dword count", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.nfsw_dis;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " nfsw_dis =\t0x%"PRIx8" (NFS write filtering disable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.nfsr_dis;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " nfsr_dis =\t0x%"PRIx8" (NFS read filtering disable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.nfs_ver;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " nfs_ver =\t0x%"PRIx8" (NFS version (+2)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ipv6_dis;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ipv6_dis =\t0x%"PRIx8" (IPv6 filtering disable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ipv6xsum_dis;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ipv6xsum_dis =\t0x%"PRIx8" (IPv6 xsum disable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ackdis;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ackdis =\t0x%"PRIx8" (ACK accelerator disable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ackd_dis;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ackd_dis =\t0x%"PRIx8" (ACK data disable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ipfrsp_dis;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ipfrsp_dis =\t0x%"PRIx8" (IP fragment split disable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.exsten;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " exsten =\t0x%"PRIx8" (Extended status enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register tctl (Transmit control); type e1000.tctl (Implicit type of Transmit control register)
 */

/*
 * Dump of fields for register: tctl
 *   _anon0 (size 1, offset 0):	 MBZ	  _
 *   en (size 1, offset 1):	 RW	  Transmit enable
 *   _anon2 (size 1, offset 2):	 MBZ	  _
 *   psp (size 1, offset 3):	 RW	  Pad short packets
 *   ct (size 8, offset 4):	 RW	  Collision threshold
 *   cold (size 10, offset 12):	 RW	  Collision distance
 *   swxoff (size 1, offset 22):	 RW	  Software XOFF transmission
 *   _anon23 (size 1, offset 23):	 MBZ	  _
 *   rtlc (size 1, offset 24):	 RW	  Retransmit on late collision
 *   unortx (size 1, offset 25):	 RW	  Underrun no re-transmit
 *   txcscmt (size 2, offset 26):	 RW	  Tx descriptor minimum threshold
 *   mulr (size 1, offset 28):	 RW	  Multiple request support
 *   _anon29 (size 3, offset 29):	 RSVD	  _
 */

static inline uint32_t __DP(tctl_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(tctl_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x400));
}

static inline e1000_tctl_t __DP(tctl_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_tctl_t __DP(tctl_rd)( __DN(t) * _dev )
{
    e1000_tctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x400));
    return u.val;
}

static inline void __DP(tctl_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(tctl_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x400),val);
}

static inline void __DP(tctl_wr)( __DN(t) * _dev, e1000_tctl_t val ) __attribute__ ((always_inline));
static inline void __DP(tctl_wr)( __DN(t) * _dev, e1000_tctl_t val )
{
    e1000_tctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x400));
    u.val._anon0 	= val._anon0;
    u.val.en 	= val.en;
    u.val._anon2 	= val._anon2;
    u.val.psp 	= val.psp;
    u.val.ct 	= val.ct;
    u.val.cold 	= val.cold;
    u.val.swxoff 	= val.swxoff;
    u.val._anon23 	= val._anon23;
    u.val.rtlc 	= val.rtlc;
    u.val.unortx 	= val.unortx;
    u.val.txcscmt 	= val.txcscmt;
    u.val.mulr 	= val.mulr;
    u.val._anon0 	= 0;
    u.val._anon2 	= 0;
    u.val._anon23 	= 0;
    mackerel_write_addr_32(_dev->base,(0x400),u.raw);
}

static inline void __DP(tctl_en_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(tctl_en_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_tctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x400));
    u.val._anon0 	= 0;
    u.val._anon2 	= 0;
    u.val._anon23 	= 0;
    u.val.en = val;
    mackerel_write_addr_32(_dev->base,(0x400),u.raw);
}

static inline void __DP(tctl_psp_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(tctl_psp_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_tctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x400));
    u.val._anon0 	= 0;
    u.val._anon2 	= 0;
    u.val._anon23 	= 0;
    u.val.psp = val;
    mackerel_write_addr_32(_dev->base,(0x400),u.raw);
}

static inline void __DP(tctl_ct_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(tctl_ct_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_tctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x400));
    u.val._anon0 	= 0;
    u.val._anon2 	= 0;
    u.val._anon23 	= 0;
    u.val.ct = val;
    mackerel_write_addr_32(_dev->base,(0x400),u.raw);
}

static inline void __DP(tctl_cold_wrf)( __DN(t) * _dev, e1000_coldist_t val ) __attribute__ ((always_inline));
static inline void __DP(tctl_cold_wrf)( __DN(t) * _dev, e1000_coldist_t val )
{
    e1000_tctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x400));
    u.val._anon0 	= 0;
    u.val._anon2 	= 0;
    u.val._anon23 	= 0;
    u.val.cold = val;
    mackerel_write_addr_32(_dev->base,(0x400),u.raw);
}

static inline void __DP(tctl_swxoff_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(tctl_swxoff_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_tctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x400));
    u.val._anon0 	= 0;
    u.val._anon2 	= 0;
    u.val._anon23 	= 0;
    u.val.swxoff = val;
    mackerel_write_addr_32(_dev->base,(0x400),u.raw);
}

static inline void __DP(tctl_rtlc_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(tctl_rtlc_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_tctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x400));
    u.val._anon0 	= 0;
    u.val._anon2 	= 0;
    u.val._anon23 	= 0;
    u.val.rtlc = val;
    mackerel_write_addr_32(_dev->base,(0x400),u.raw);
}

static inline void __DP(tctl_unortx_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(tctl_unortx_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_tctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x400));
    u.val._anon0 	= 0;
    u.val._anon2 	= 0;
    u.val._anon23 	= 0;
    u.val.unortx = val;
    mackerel_write_addr_32(_dev->base,(0x400),u.raw);
}

static inline void __DP(tctl_txcscmt_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(tctl_txcscmt_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_tctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x400));
    u.val._anon0 	= 0;
    u.val._anon2 	= 0;
    u.val._anon23 	= 0;
    u.val.txcscmt = val;
    mackerel_write_addr_32(_dev->base,(0x400),u.raw);
}

static inline void __DP(tctl_mulr_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(tctl_mulr_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_tctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x400));
    u.val._anon0 	= 0;
    u.val._anon2 	= 0;
    u.val._anon23 	= 0;
    u.val.mulr = val;
    mackerel_write_addr_32(_dev->base,(0x400),u.raw);
}


static inline int __DP(tctl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tctl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_tctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x400));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register tctl (Transmit control):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.en;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " en =\t0x%"PRIx8" (Transmit enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.psp;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " psp =\t0x%"PRIx8" (Pad short packets", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ct;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ct =\t0x%"PRIx8" (Collision threshold", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint16_t pv = (uint16_t)u.val.cold;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " cold =\t0x%0"PRIx16" (Collision distance", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_coldist_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.swxoff;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " swxoff =\t0x%"PRIx8" (Software XOFF transmission", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.rtlc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rtlc =\t0x%"PRIx8" (Retransmit on late collision", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.unortx;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " unortx =\t0x%"PRIx8" (Underrun no re-transmit", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.txcscmt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txcscmt =\t0x%"PRIx8" (Tx descriptor minimum threshold", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mulr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mulr =\t0x%"PRIx8" (Multiple request support", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register tctl_ext (Transmit control extended); type e1000.tctl_ext (Implicit type of Transmit control extended register)
 */

/*
 * Dump of fields for register: tctl_ext
 *   _anon0 (size 10, offset 0):	 MBZ	  _
 *   cold (size 10, offset 10):	 RW	  Collision distance
 *   _anon20 (size 12, offset 20):	 RSVD	  _
 */

static inline uint32_t __DP(tctl_ext_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(tctl_ext_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x404));
}

static inline e1000_tctl_ext_t __DP(tctl_ext_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_tctl_ext_t __DP(tctl_ext_rd)( __DN(t) * _dev )
{
    e1000_tctl_ext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x404));
    return u.val;
}

static inline void __DP(tctl_ext_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(tctl_ext_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x404),val);
}

static inline void __DP(tctl_ext_wr)( __DN(t) * _dev, e1000_tctl_ext_t val ) __attribute__ ((always_inline));
static inline void __DP(tctl_ext_wr)( __DN(t) * _dev, e1000_tctl_ext_t val )
{
    e1000_tctl_ext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x404));
    u.val._anon0 	= val._anon0;
    u.val.cold 	= val.cold;
    u.val._anon0 	= 0;
    mackerel_write_addr_32(_dev->base,(0x404),u.raw);
}

static inline void __DP(tctl_ext_cold_wrf)( __DN(t) * _dev, e1000_coldist_t val ) __attribute__ ((always_inline));
static inline void __DP(tctl_ext_cold_wrf)( __DN(t) * _dev, e1000_coldist_t val )
{
    e1000_tctl_ext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x404));
    u.val._anon0 	= 0;
    u.val.cold = val;
    mackerel_write_addr_32(_dev->base,(0x404),u.raw);
}


static inline int __DP(tctl_ext_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tctl_ext_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_tctl_ext_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x404));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register tctl_ext (Transmit control extended):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint16_t pv = (uint16_t)u.val.cold;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " cold =\t0x%0"PRIx16" (Collision distance", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_coldist_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register tipg (Transmit IPQ); type e1000.tipg (Implicit type of Transmit IPQ register)
 */

/*
 * Dump of fields for register: tipg
 *   ipgt (size 10, offset 0):	 RW	  IPG back to back (x MAC clock, +4)
 *   ipgr1 (size 10, offset 10):	 RW	  IPG Part 1
 *   ipgr (size 10, offset 20):	 RW	  IPG after deferral
 *   _anon30 (size 2, offset 30):	 MBZ	  _
 */

static inline uint32_t __DP(tipg_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(tipg_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x410));
}

static inline e1000_tipg_t __DP(tipg_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_tipg_t __DP(tipg_rd)( __DN(t) * _dev )
{
    e1000_tipg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x410));
    return u.val;
}

static inline void __DP(tipg_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(tipg_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x410),val);
}

static inline void __DP(tipg_wr)( __DN(t) * _dev, e1000_tipg_t val ) __attribute__ ((always_inline));
static inline void __DP(tipg_wr)( __DN(t) * _dev, e1000_tipg_t val )
{
    e1000_tipg_un  u;
    u.val = val;
    u.val._anon30 	= 0;
    mackerel_write_addr_32(_dev->base,(0x410),u.raw);
}

static inline void __DP(tipg_ipgt_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(tipg_ipgt_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_tipg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x410));
    u.val._anon30 	= 0;
    u.val.ipgt = val;
    mackerel_write_addr_32(_dev->base,(0x410),u.raw);
}

static inline void __DP(tipg_ipgr1_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(tipg_ipgr1_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_tipg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x410));
    u.val._anon30 	= 0;
    u.val.ipgr1 = val;
    mackerel_write_addr_32(_dev->base,(0x410),u.raw);
}

static inline void __DP(tipg_ipgr_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(tipg_ipgr_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_tipg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x410));
    u.val._anon30 	= 0;
    u.val.ipgr = val;
    mackerel_write_addr_32(_dev->base,(0x410),u.raw);
}


static inline int __DP(tipg_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tipg_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_tipg_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x410));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register tipg (Transmit IPQ):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.ipgt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ipgt =\t0x%0"PRIx16" (IPG back to back (x MAC clock, +4)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint16_t pv = (uint16_t)u.val.ipgr1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ipgr1 =\t0x%0"PRIx16" (IPG Part 1", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint16_t pv = (uint16_t)u.val.ipgr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ipgr =\t0x%0"PRIx16" (IPG after deferral", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register tdbal (Tx descr. base addr. low); type e1000.uint32
 */
static const int __DP(tdbal_length) = 0x2;
static inline uint32_t __DP(tdbal_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(tdbal_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x3800) + (_i * 256));
}

static inline uint32_t __DP(tdbal_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(tdbal_rd)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x3800) + (_i * 256));
}

static inline void __DP(tdbal_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(tdbal_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x3800) + (_i * 256),val);
}

static inline void __DP(tdbal_wr)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(tdbal_wr)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x3800) + (_i * 256),val);
}


static inline int __DP(tdbal_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(tdbal_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register tdbal[%d] (Tx descr. base addr. low):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x3800) + (_i * 256)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}
static inline int __DP(tdbal_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tdbal_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x2; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(tdbal_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register tdbah (Tx descr. base addr. hi); type e1000.uint32
 */
static const int __DP(tdbah_length) = 0x2;
static inline uint32_t __DP(tdbah_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(tdbah_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x3804) + (_i * 256));
}

static inline uint32_t __DP(tdbah_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(tdbah_rd)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x3804) + (_i * 256));
}

static inline void __DP(tdbah_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(tdbah_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x3804) + (_i * 256),val);
}

static inline void __DP(tdbah_wr)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(tdbah_wr)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x3804) + (_i * 256),val);
}


static inline int __DP(tdbah_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(tdbah_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register tdbah[%d] (Tx descr. base addr. hi):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x3804) + (_i * 256)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}
static inline int __DP(tdbah_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tdbah_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x2; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(tdbah_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register tdlen (Tx descr. length); type e1000.dqlen (Descriptor length value)
 */

/*
 * Dump of fields for register: tdlen
 *   _anon0 (size 7, offset 0):	 MBZ	  _
 *   len (size 13, offset 7):	 RW	  Num. descriptors (x8)
 *   _anon20 (size 12, offset 20):	 MBZ	  _
 */
static const int __DP(tdlen_length) = 0x2;
static inline uint32_t __DP(tdlen_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(tdlen_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x3808) + (_i * 256));
}

static inline e1000_dqlen_t __DP(tdlen_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline e1000_dqlen_t __DP(tdlen_rd)( __DN(t) * _dev, int _i )
{
    e1000_dqlen_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3808) + (_i * 256));
    return u.val;
}

static inline void __DP(tdlen_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(tdlen_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x3808) + (_i * 256),val);
}

static inline void __DP(tdlen_wr)( __DN(t) * _dev, int _i, e1000_dqlen_t val ) __attribute__ ((always_inline));
static inline void __DP(tdlen_wr)( __DN(t) * _dev, int _i, e1000_dqlen_t val )
{
    e1000_dqlen_un  u;
    u.val = val;
    u.val._anon0 	= 0;
    u.val._anon20 	= 0;
    mackerel_write_addr_32(_dev->base,(0x3808) + (_i * 256),u.raw);
}

static inline void __DP(tdlen_len_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(tdlen_len_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    e1000_dqlen_un  u;
    u.val._anon0 	= 0;
    u.val._anon20 	= 0;
    u.val.len = val;
    mackerel_write_addr_32(_dev->base,(0x3808) + (_i * 256),u.raw);
}


static inline int __DP(tdlen_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(tdlen_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    e1000_dqlen_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3808) + (_i * 256));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register tdlen[%d] (Tx descr. length):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint16_t pv = (uint16_t)u.val.len;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " len =\t0x%0"PRIx16" (Num. descriptors (x8)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(tdlen_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tdlen_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x2; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(tdlen_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register tdh (Tx descr. head); type e1000.dqval (Descriptor head/tail value)
 */

/*
 * Dump of fields for register: tdh
 *   val (size 16, offset 0):	 RW	  value
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(tdh_length) = 0x2;
static inline uint32_t __DP(tdh_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(tdh_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x3810) + (_i * 256));
}

static inline e1000_dqval_t __DP(tdh_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline e1000_dqval_t __DP(tdh_rd)( __DN(t) * _dev, int _i )
{
    e1000_dqval_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3810) + (_i * 256));
    return u.val;
}

static inline void __DP(tdh_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(tdh_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x3810) + (_i * 256),val);
}

static inline void __DP(tdh_wr)( __DN(t) * _dev, int _i, e1000_dqval_t val ) __attribute__ ((always_inline));
static inline void __DP(tdh_wr)( __DN(t) * _dev, int _i, e1000_dqval_t val )
{
    e1000_dqval_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0x3810) + (_i * 256),u.raw);
}

static inline void __DP(tdh_val_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(tdh_val_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    e1000_dqval_un  u;
    u.val._anon16 	= 0;
    u.val.val = val;
    mackerel_write_addr_32(_dev->base,(0x3810) + (_i * 256),u.raw);
}


static inline int __DP(tdh_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(tdh_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    e1000_dqval_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3810) + (_i * 256));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register tdh[%d] (Tx descr. head):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.val;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " val =\t0x%0"PRIx16" (value", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(tdh_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tdh_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x2; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(tdh_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register tdt (Tx descr. tail); type e1000.dqval (Descriptor head/tail value)
 */

/*
 * Dump of fields for register: tdt
 *   val (size 16, offset 0):	 RW	  value
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(tdt_length) = 0x2;
static inline uint32_t __DP(tdt_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(tdt_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x3818) + (_i * 256));
}

static inline e1000_dqval_t __DP(tdt_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline e1000_dqval_t __DP(tdt_rd)( __DN(t) * _dev, int _i )
{
    e1000_dqval_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3818) + (_i * 256));
    return u.val;
}

static inline void __DP(tdt_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(tdt_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x3818) + (_i * 256),val);
}

static inline void __DP(tdt_wr)( __DN(t) * _dev, int _i, e1000_dqval_t val ) __attribute__ ((always_inline));
static inline void __DP(tdt_wr)( __DN(t) * _dev, int _i, e1000_dqval_t val )
{
    e1000_dqval_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0x3818) + (_i * 256),u.raw);
}

static inline void __DP(tdt_val_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(tdt_val_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    e1000_dqval_un  u;
    u.val._anon16 	= 0;
    u.val.val = val;
    mackerel_write_addr_32(_dev->base,(0x3818) + (_i * 256),u.raw);
}


static inline int __DP(tdt_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(tdt_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    e1000_dqval_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3818) + (_i * 256));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register tdt[%d] (Tx descr. tail):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.val;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " val =\t0x%0"PRIx16" (value", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(tdt_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tdt_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x2; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(tdt_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register tidv (Transmit interrupt delay value); type e1000.tidv (Implicit type of Transmit interrupt delay value register)
 */

/*
 * Dump of fields for register: tidv
 *   idv (size 16, offset 0):	 RW	  Interupt delay value
 *   _anon16 (size 15, offset 16):	 MBZ	  _
 *   fdp (size 1, offset 31):	 WO	  Flush partial description block
 */

static inline uint32_t __DP(tidv_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(tidv_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x3820));
}

static inline e1000_tidv_t __DP(tidv_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_tidv_t __DP(tidv_rd)( __DN(t) * _dev )
{
    e1000_tidv_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3820));
    return u.val;
}

static inline void __DP(tidv_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(tidv_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x3820),val);
}

static inline void __DP(tidv_wr)( __DN(t) * _dev, e1000_tidv_t val ) __attribute__ ((always_inline));
static inline void __DP(tidv_wr)( __DN(t) * _dev, e1000_tidv_t val )
{
    e1000_tidv_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0x3820),u.raw);
    _dev->tidv_shadow.val = u.val;
}

static inline void __DP(tidv_idv_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(tidv_idv_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_tidv_un  u;
    u.val.fdp = _dev->tidv_shadow.val.fdp;
    u.val._anon16 	= 0;
    u.val.idv = val;
    mackerel_write_addr_32(_dev->base,(0x3820),u.raw);
    _dev->tidv_shadow.val = u.val;
}

static inline void __DP(tidv_fdp_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(tidv_fdp_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_tidv_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3820));
    u.val._anon16 	= 0;
    u.val.fdp = val;
    mackerel_write_addr_32(_dev->base,(0x3820),u.raw);
    _dev->tidv_shadow.val = u.val;
}


static inline int __DP(tidv_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tidv_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_tidv_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3820));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register tidv (Transmit interrupt delay value):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.idv;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " idv =\t0x%0"PRIx16" (Interupt delay value", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)_dev->tidv_shadow.val.fdp;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fdp =\t0x%"PRIx8" (SHADOW of Flush partial description block", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register txdctl (Transmit descr. control queue); type e1000.txdctl (Implicit type of Transmit descr. control queue register array)
 */

/*
 * Dump of fields for register: txdctl
 *   pthresh (size 6, offset 0):	 RW	  Prefetch threshold
 *   _anon6 (size 2, offset 6):	 MBZ	  _
 *   hthresh (size 8, offset 8):	 RW	  Host threshold
 *   wthresh (size 6, offset 16):	 RW	  Write back threshold
 *   _anon22 (size 1, offset 22):	 MB1	  _
 *   _anon23 (size 1, offset 23):	 RSVD	  _
 *   gran (size 1, offset 24):	 RW	  Granularity
 *   lwthresh (size 7, offset 25):	 RW	  Transmit descriptor low threshold
 */
static const int __DP(txdctl_length) = 0x2;
static inline uint32_t __DP(txdctl_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(txdctl_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x3828) + (_i * 256));
}

static inline e1000_txdctl_t __DP(txdctl_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline e1000_txdctl_t __DP(txdctl_rd)( __DN(t) * _dev, int _i )
{
    e1000_txdctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3828) + (_i * 256));
    return u.val;
}

static inline void __DP(txdctl_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(txdctl_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x3828) + (_i * 256),val);
}

static inline void __DP(txdctl_wr)( __DN(t) * _dev, int _i, e1000_txdctl_t val ) __attribute__ ((always_inline));
static inline void __DP(txdctl_wr)( __DN(t) * _dev, int _i, e1000_txdctl_t val )
{
    e1000_txdctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3828) + (_i * 256));
    u.val.pthresh 	= val.pthresh;
    u.val._anon6 	= val._anon6;
    u.val.hthresh 	= val.hthresh;
    u.val.wthresh 	= val.wthresh;
    u.val._anon22 	= val._anon22;
    u.val.gran 	= val.gran;
    u.val.lwthresh 	= val.lwthresh;
    u.val._anon6 	= 0;
    u.val._anon22 	= -1;
    mackerel_write_addr_32(_dev->base,(0x3828) + (_i * 256),u.raw);
}

static inline void __DP(txdctl_pthresh_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(txdctl_pthresh_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    e1000_txdctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3828) + (_i * 256));
    u.val._anon6 	= 0;
    u.val._anon22 	= -1;
    u.val.pthresh = val;
    mackerel_write_addr_32(_dev->base,(0x3828) + (_i * 256),u.raw);
}

static inline void __DP(txdctl_hthresh_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(txdctl_hthresh_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    e1000_txdctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3828) + (_i * 256));
    u.val._anon6 	= 0;
    u.val._anon22 	= -1;
    u.val.hthresh = val;
    mackerel_write_addr_32(_dev->base,(0x3828) + (_i * 256),u.raw);
}

static inline void __DP(txdctl_wthresh_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(txdctl_wthresh_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    e1000_txdctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3828) + (_i * 256));
    u.val._anon6 	= 0;
    u.val._anon22 	= -1;
    u.val.wthresh = val;
    mackerel_write_addr_32(_dev->base,(0x3828) + (_i * 256),u.raw);
}

static inline void __DP(txdctl_gran_wrf)( __DN(t) * _dev, int _i, e1000_threshgran_t val ) __attribute__ ((always_inline));
static inline void __DP(txdctl_gran_wrf)( __DN(t) * _dev, int _i, e1000_threshgran_t val )
{
    e1000_txdctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3828) + (_i * 256));
    u.val._anon6 	= 0;
    u.val._anon22 	= -1;
    u.val.gran = val;
    mackerel_write_addr_32(_dev->base,(0x3828) + (_i * 256),u.raw);
}

static inline void __DP(txdctl_lwthresh_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(txdctl_lwthresh_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    e1000_txdctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3828) + (_i * 256));
    u.val._anon6 	= 0;
    u.val._anon22 	= -1;
    u.val.lwthresh = val;
    mackerel_write_addr_32(_dev->base,(0x3828) + (_i * 256),u.raw);
}


static inline int __DP(txdctl_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(txdctl_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    e1000_txdctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3828) + (_i * 256));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register txdctl[%d] (Transmit descr. control queue):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.pthresh;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pthresh =\t0x%"PRIx8" (Prefetch threshold", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.hthresh;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " hthresh =\t0x%"PRIx8" (Host threshold", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wthresh;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wthresh =\t0x%"PRIx8" (Write back threshold", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.gran;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " gran =\t0x%"PRIx8" (Granularity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_threshgran_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.lwthresh;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lwthresh =\t0x%"PRIx8" (Transmit descriptor low threshold", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}
static inline int __DP(txdctl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(txdctl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x2; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(txdctl_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register tadv (Tx absolute intr. delay); type e1000.tadv (Implicit type of Tx absolute intr. delay register)
 */

/*
 * Dump of fields for register: tadv
 *   idv (size 16, offset 0):	 RW	  Interrupt delay value
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */

static inline uint32_t __DP(tadv_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(tadv_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x382c));
}

static inline e1000_tadv_t __DP(tadv_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_tadv_t __DP(tadv_rd)( __DN(t) * _dev )
{
    e1000_tadv_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x382c));
    return u.val;
}

static inline void __DP(tadv_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(tadv_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x382c),val);
}

static inline void __DP(tadv_wr)( __DN(t) * _dev, e1000_tadv_t val ) __attribute__ ((always_inline));
static inline void __DP(tadv_wr)( __DN(t) * _dev, e1000_tadv_t val )
{
    e1000_tadv_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0x382c),u.raw);
}

static inline void __DP(tadv_idv_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(tadv_idv_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_tadv_un  u;
    u.val._anon16 	= 0;
    u.val.idv = val;
    mackerel_write_addr_32(_dev->base,(0x382c),u.raw);
}


static inline int __DP(tadv_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tadv_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_tadv_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x382c));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register tadv (Tx absolute intr. delay):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.idv;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " idv =\t0x%0"PRIx16" (Interrupt delay value", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register tarc (Tx arbitration counter); type e1000.tarc (Implicit type of Tx arbitration counter register array)
 */

/*
 * Dump of fields for register: tarc
 *   count (size 7, offset 0):	 RW	  Transmit arbitration count
 *   _anon7 (size 1, offset 7):	 RSVD	  _
 *   ratio (size 2, offset 8):	 RW	  Compensation ratio (1 / 2^val)
 *   enable (size 1, offset 10):	 MB1	  enable
 *   _anon11 (size 10, offset 11):	 MBZ	  _
 *   _anon21 (size 1, offset 21):	 MB1	  _
 *   _anon22 (size 1, offset 22):	 MBZ	  _
 *   _anon23 (size 4, offset 23):	 MB1	  _
 *   _anon27 (size 5, offset 27):	 MBZ	  _
 */
static const int __DP(tarc_length) = 0x2;
static inline uint32_t __DP(tarc_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(tarc_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x3840) + (_i * 256));
}

static inline e1000_tarc_t __DP(tarc_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline e1000_tarc_t __DP(tarc_rd)( __DN(t) * _dev, int _i )
{
    e1000_tarc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3840) + (_i * 256));
    return u.val;
}

static inline void __DP(tarc_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(tarc_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x3840) + (_i * 256),val);
}

static inline void __DP(tarc_wr)( __DN(t) * _dev, int _i, e1000_tarc_t val ) __attribute__ ((always_inline));
static inline void __DP(tarc_wr)( __DN(t) * _dev, int _i, e1000_tarc_t val )
{
    e1000_tarc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3840) + (_i * 256));
    u.val.count 	= val.count;
    u.val.ratio 	= val.ratio;
    u.val.enable 	= val.enable;
    u.val._anon11 	= val._anon11;
    u.val._anon21 	= val._anon21;
    u.val._anon22 	= val._anon22;
    u.val._anon23 	= val._anon23;
    u.val._anon27 	= val._anon27;
    u.val._anon11 	= 0;
    u.val._anon22 	= 0;
    u.val._anon27 	= 0;
    u.val.enable 	= -1;
    u.val._anon21 	= -1;
    u.val._anon23 	= -1;
    mackerel_write_addr_32(_dev->base,(0x3840) + (_i * 256),u.raw);
}

static inline void __DP(tarc_count_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(tarc_count_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    e1000_tarc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3840) + (_i * 256));
    u.val._anon11 	= 0;
    u.val._anon22 	= 0;
    u.val._anon27 	= 0;
    u.val.enable 	= -1;
    u.val._anon21 	= -1;
    u.val._anon23 	= -1;
    u.val.count = val;
    mackerel_write_addr_32(_dev->base,(0x3840) + (_i * 256),u.raw);
}

static inline void __DP(tarc_ratio_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(tarc_ratio_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    e1000_tarc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3840) + (_i * 256));
    u.val._anon11 	= 0;
    u.val._anon22 	= 0;
    u.val._anon27 	= 0;
    u.val.enable 	= -1;
    u.val._anon21 	= -1;
    u.val._anon23 	= -1;
    u.val.ratio = val;
    mackerel_write_addr_32(_dev->base,(0x3840) + (_i * 256),u.raw);
}


static inline int __DP(tarc_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(tarc_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    e1000_tarc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3840) + (_i * 256));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register tarc[%d] (Tx arbitration counter):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.count;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " count =\t0x%"PRIx8" (Transmit arbitration count", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.ratio;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ratio =\t0x%"PRIx8" (Compensation ratio (1 / 2^val)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.enable;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " enable =\t0x%"PRIx8" (enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    // skipping anonymous field
    // skipping anonymous field
    // skipping anonymous field
    // skipping anonymous field
    return r;
}
static inline int __DP(tarc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tarc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x2; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(tarc_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register mta (Multicast table array); type e1000.uint32
 */
static const int __DP(mta_length) = 0x80;
static inline uint32_t __DP(mta_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(mta_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x5200) + (_i *(32/8)));
}

static inline uint32_t __DP(mta_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(mta_rd)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x5200) + (_i *(32/8)));
}

static inline void __DP(mta_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(mta_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5200) + (_i *(32/8)),val);
}

static inline void __DP(mta_wr)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(mta_wr)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5200) + (_i *(32/8)),val);
}


static inline int __DP(mta_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(mta_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register mta[%d] (Multicast table array):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x5200) + (_i *(32/8))));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}
static inline int __DP(mta_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(mta_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x80; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(mta_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register ral (Receive address low); type e1000.uint32
 */
static const int __DP(ral_length) = 0x10;
static inline uint32_t __DP(ral_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(ral_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x5400) + (_i * 8));
}

static inline uint32_t __DP(ral_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(ral_rd)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x5400) + (_i * 8));
}

static inline void __DP(ral_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(ral_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5400) + (_i * 8),val);
}

static inline void __DP(ral_wr)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(ral_wr)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5400) + (_i * 8),val);
}


static inline int __DP(ral_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(ral_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register ral[%d] (Receive address low):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x5400) + (_i * 8)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}
static inline int __DP(ral_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ral_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x10; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(ral_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register rah (Receive address high); type e1000.rah (Implicit type of Receive address high register array)
 */

/*
 * Dump of fields for register: rah
 *   rah (size 16, offset 0):	 RW	  Receive address high
 *   asel (size 2, offset 16):	 RW	  Address select
 *   _anon18 (size 13, offset 18):	 MBZ	  _
 *   av (size 1, offset 31):	 RW	  Address valid
 */
static const int __DP(rah_length) = 0x10;
static inline uint32_t __DP(rah_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(rah_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x5404) + (_i * 8));
}

static inline e1000_rah_t __DP(rah_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline e1000_rah_t __DP(rah_rd)( __DN(t) * _dev, int _i )
{
    e1000_rah_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5404) + (_i * 8));
    return u.val;
}

static inline void __DP(rah_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(rah_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5404) + (_i * 8),val);
}

static inline void __DP(rah_wr)( __DN(t) * _dev, int _i, e1000_rah_t val ) __attribute__ ((always_inline));
static inline void __DP(rah_wr)( __DN(t) * _dev, int _i, e1000_rah_t val )
{
    e1000_rah_un  u;
    u.val = val;
    u.val._anon18 	= 0;
    mackerel_write_addr_32(_dev->base,(0x5404) + (_i * 8),u.raw);
}

static inline void __DP(rah_rah_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(rah_rah_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    e1000_rah_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5404) + (_i * 8));
    u.val._anon18 	= 0;
    u.val.rah = val;
    mackerel_write_addr_32(_dev->base,(0x5404) + (_i * 8),u.raw);
}

static inline void __DP(rah_asel_wrf)( __DN(t) * _dev, int _i, e1000_addrsel_t val ) __attribute__ ((always_inline));
static inline void __DP(rah_asel_wrf)( __DN(t) * _dev, int _i, e1000_addrsel_t val )
{
    e1000_rah_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5404) + (_i * 8));
    u.val._anon18 	= 0;
    u.val.asel = val;
    mackerel_write_addr_32(_dev->base,(0x5404) + (_i * 8),u.raw);
}

static inline void __DP(rah_av_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rah_av_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    e1000_rah_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5404) + (_i * 8));
    u.val._anon18 	= 0;
    u.val.av = val;
    mackerel_write_addr_32(_dev->base,(0x5404) + (_i * 8),u.raw);
}


static inline int __DP(rah_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(rah_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    e1000_rah_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5404) + (_i * 8));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register rah[%d] (Receive address high):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.rah;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rah =\t0x%0"PRIx16" (Receive address high", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.asel;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " asel =\t0x%"PRIx8" (Address select", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_addrsel_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.av;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " av =\t0x%"PRIx8" (Address valid", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}
static inline int __DP(rah_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rah_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x10; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(rah_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register vfta (VLAN filter table array); type e1000.uint32
 */
static const int __DP(vfta_length) = 0x80;
static inline uint32_t __DP(vfta_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(vfta_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x5600) + (_i *(32/8)));
}

static inline uint32_t __DP(vfta_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(vfta_rd)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x5600) + (_i *(32/8)));
}

static inline void __DP(vfta_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(vfta_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5600) + (_i *(32/8)),val);
}

static inline void __DP(vfta_wr)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(vfta_wr)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5600) + (_i *(32/8)),val);
}


static inline int __DP(vfta_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(vfta_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register vfta[%d] (VLAN filter table array):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x5600) + (_i *(32/8))));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}
static inline int __DP(vfta_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(vfta_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x80; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(vfta_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register mrq (Multiple queues receive command); type e1000.mrq (Implicit type of Multiple queues receive command register)
 */

/*
 * Dump of fields for register: mrq
 *   mrqe (size 2, offset 0):	 RW	  Multiple rx queues enable
 *   rssie (size 1, offset 2):	 RW	  RSS interrupt enable
 *   _anon3 (size 13, offset 3):	 MBZ	  _
 *   tcp4 (size 1, offset 16):	 RW	  Enable TCP IPv4 hash
 *   ipv4 (size 1, offset 17):	 RW	  Enable IPv4 hash
 *   tcp6ex (size 1, offset 18):	 RW	  Enable TCP IPv6 Ex hash
 *   ipv6ex (size 1, offset 19):	 RW	  Enable IPv6 Ex hash
 *   ipv6 (size 1, offset 20):	 RW	  Enable IPv6 hash
 *   _anon21 (size 11, offset 21):	 RSVD	  _
 */

static inline uint32_t __DP(mrq_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(mrq_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5818));
}

static inline e1000_mrq_t __DP(mrq_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_mrq_t __DP(mrq_rd)( __DN(t) * _dev )
{
    e1000_mrq_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5818));
    return u.val;
}

static inline void __DP(mrq_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(mrq_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5818),val);
}

static inline void __DP(mrq_wr)( __DN(t) * _dev, e1000_mrq_t val ) __attribute__ ((always_inline));
static inline void __DP(mrq_wr)( __DN(t) * _dev, e1000_mrq_t val )
{
    e1000_mrq_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5818));
    u.val.mrqe 	= val.mrqe;
    u.val.rssie 	= val.rssie;
    u.val._anon3 	= val._anon3;
    u.val.tcp4 	= val.tcp4;
    u.val.ipv4 	= val.ipv4;
    u.val.tcp6ex 	= val.tcp6ex;
    u.val.ipv6ex 	= val.ipv6ex;
    u.val.ipv6 	= val.ipv6;
    u.val._anon3 	= 0;
    mackerel_write_addr_32(_dev->base,(0x5818),u.raw);
}

static inline void __DP(mrq_mrqe_wrf)( __DN(t) * _dev, e1000_mrqen_t val ) __attribute__ ((always_inline));
static inline void __DP(mrq_mrqe_wrf)( __DN(t) * _dev, e1000_mrqen_t val )
{
    e1000_mrq_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5818));
    u.val._anon3 	= 0;
    u.val.mrqe = val;
    mackerel_write_addr_32(_dev->base,(0x5818),u.raw);
}

static inline void __DP(mrq_rssie_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(mrq_rssie_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_mrq_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5818));
    u.val._anon3 	= 0;
    u.val.rssie = val;
    mackerel_write_addr_32(_dev->base,(0x5818),u.raw);
}

static inline void __DP(mrq_tcp4_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(mrq_tcp4_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_mrq_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5818));
    u.val._anon3 	= 0;
    u.val.tcp4 = val;
    mackerel_write_addr_32(_dev->base,(0x5818),u.raw);
}

static inline void __DP(mrq_ipv4_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(mrq_ipv4_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_mrq_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5818));
    u.val._anon3 	= 0;
    u.val.ipv4 = val;
    mackerel_write_addr_32(_dev->base,(0x5818),u.raw);
}

static inline void __DP(mrq_tcp6ex_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(mrq_tcp6ex_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_mrq_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5818));
    u.val._anon3 	= 0;
    u.val.tcp6ex = val;
    mackerel_write_addr_32(_dev->base,(0x5818),u.raw);
}

static inline void __DP(mrq_ipv6ex_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(mrq_ipv6ex_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_mrq_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5818));
    u.val._anon3 	= 0;
    u.val.ipv6ex = val;
    mackerel_write_addr_32(_dev->base,(0x5818),u.raw);
}

static inline void __DP(mrq_ipv6_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(mrq_ipv6_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_mrq_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5818));
    u.val._anon3 	= 0;
    u.val.ipv6 = val;
    mackerel_write_addr_32(_dev->base,(0x5818),u.raw);
}


static inline int __DP(mrq_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(mrq_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_mrq_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5818));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register mrq (Multiple queues receive command):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.mrqe;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mrqe =\t0x%"PRIx8" (Multiple rx queues enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_mrqen_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rssie;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rssie =\t0x%"PRIx8" (RSS interrupt enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.tcp4;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tcp4 =\t0x%"PRIx8" (Enable TCP IPv4 hash", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ipv4;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ipv4 =\t0x%"PRIx8" (Enable IPv4 hash", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.tcp6ex;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tcp6ex =\t0x%"PRIx8" (Enable TCP IPv6 Ex hash", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ipv6ex;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ipv6ex =\t0x%"PRIx8" (Enable IPv6 Ex hash", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ipv6;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ipv6 =\t0x%"PRIx8" (Enable IPv6 hash", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register rssim (RSS interrupt mask); type e1000.uint32
 */

static inline uint32_t __DP(rssim_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rssim_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5864));
}

static inline uint32_t __DP(rssim_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rssim_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5864));
}

static inline void __DP(rssim_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(rssim_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5864),val);
}

static inline void __DP(rssim_wr)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(rssim_wr)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5864),val);
}


static inline int __DP(rssim_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rssim_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rssim (RSS interrupt mask):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x5864)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register rssir (RSS interrupt request); type e1000.uint32
 */

static inline uint32_t __DP(rssir_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rssir_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5868));
}

static inline uint32_t __DP(rssir_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rssir_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5868));
}

static inline void __DP(rssir_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(rssir_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5868),val);
}

static inline void __DP(rssir_wr)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(rssir_wr)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5868),val);
}


static inline int __DP(rssir_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rssir_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rssir (RSS interrupt request):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x5868)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register reta (Redirection table); type e1000.uint8
 */
static const int __DP(reta_length) = 0x80;
static inline uint8_t __DP(reta_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint8_t __DP(reta_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_8(_dev->base,(0x5c00) + (_i *(8/8)));
}

static inline uint8_t __DP(reta_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint8_t __DP(reta_rd)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_8(_dev->base,(0x5c00) + (_i *(8/8)));
}

static inline void __DP(reta_wr_raw)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(reta_wr_raw)( __DN(t) * _dev, int _i, uint8_t val )
{
    mackerel_write_addr_8(_dev->base,(0x5c00) + (_i *(8/8)),val);
}

static inline void __DP(reta_wr)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(reta_wr)( __DN(t) * _dev, int _i, uint8_t val )
{
    mackerel_write_addr_8(_dev->base,(0x5c00) + (_i *(8/8)),val);
}


static inline int __DP(reta_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(reta_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register reta[%d] (Redirection table):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%"PRIx8"\n", mackerel_read_addr_8(_dev->base,(0x5c00) + (_i *(8/8))));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}
static inline int __DP(reta_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(reta_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x80; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(reta_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register rssrk (RSS Random key); type e1000.uint8
 */
static const int __DP(rssrk_length) = 0x28;
static inline uint8_t __DP(rssrk_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint8_t __DP(rssrk_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_8(_dev->base,(0x5c80) + (_i *(8/8)));
}

static inline uint8_t __DP(rssrk_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint8_t __DP(rssrk_rd)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_8(_dev->base,(0x5c80) + (_i *(8/8)));
}

static inline void __DP(rssrk_wr_raw)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rssrk_wr_raw)( __DN(t) * _dev, int _i, uint8_t val )
{
    mackerel_write_addr_8(_dev->base,(0x5c80) + (_i *(8/8)),val);
}

static inline void __DP(rssrk_wr)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rssrk_wr)( __DN(t) * _dev, int _i, uint8_t val )
{
    mackerel_write_addr_8(_dev->base,(0x5c80) + (_i *(8/8)),val);
}


static inline int __DP(rssrk_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(rssrk_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register rssrk[%d] (RSS Random key):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%"PRIx8"\n", mackerel_read_addr_8(_dev->base,(0x5c80) + (_i *(8/8))));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}
static inline int __DP(rssrk_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rssrk_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x28; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(rssrk_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register wuc (Wakeup control); type e1000.wuc (Implicit type of Wakeup control register)
 */

/*
 * Dump of fields for register: wuc
 *   apme (size 1, offset 0):	 RW	  Advanced power mgmt enable
 *   pme_en (size 1, offset 1):	 RW	  PME enable
 *   pme_stat (size 1, offset 2):	 RW	  PME status
 *   apmpme (size 1, offset 3):	 RW	  Assert PME on APM wakeup
 *   _anon4 (size 28, offset 4):	 RSVD	  _
 */

static inline uint32_t __DP(wuc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(wuc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5800));
}

static inline e1000_wuc_t __DP(wuc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_wuc_t __DP(wuc_rd)( __DN(t) * _dev )
{
    e1000_wuc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5800));
    return u.val;
}

static inline void __DP(wuc_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(wuc_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5800),val);
}

static inline void __DP(wuc_wr)( __DN(t) * _dev, e1000_wuc_t val ) __attribute__ ((always_inline));
static inline void __DP(wuc_wr)( __DN(t) * _dev, e1000_wuc_t val )
{
    e1000_wuc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5800));
    u.val.apme 	= val.apme;
    u.val.pme_en 	= val.pme_en;
    u.val.pme_stat 	= val.pme_stat;
    u.val.apmpme 	= val.apmpme;
    mackerel_write_addr_32(_dev->base,(0x5800),u.raw);
}

static inline void __DP(wuc_apme_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(wuc_apme_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_wuc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5800));
    u.val.apme = val;
    mackerel_write_addr_32(_dev->base,(0x5800),u.raw);
}

static inline void __DP(wuc_pme_en_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(wuc_pme_en_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_wuc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5800));
    u.val.pme_en = val;
    mackerel_write_addr_32(_dev->base,(0x5800),u.raw);
}

static inline void __DP(wuc_pme_stat_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(wuc_pme_stat_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_wuc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5800));
    u.val.pme_stat = val;
    mackerel_write_addr_32(_dev->base,(0x5800),u.raw);
}

static inline void __DP(wuc_apmpme_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(wuc_apmpme_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_wuc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5800));
    u.val.apmpme = val;
    mackerel_write_addr_32(_dev->base,(0x5800),u.raw);
}


static inline int __DP(wuc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(wuc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_wuc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5800));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register wuc (Wakeup control):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.apme;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " apme =\t0x%"PRIx8" (Advanced power mgmt enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pme_en;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pme_en =\t0x%"PRIx8" (PME enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pme_stat;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pme_stat =\t0x%"PRIx8" (PME status", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.apmpme;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " apmpme =\t0x%"PRIx8" (Assert PME on APM wakeup", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register wufc (Wakeup filter control); type e1000.wakeup (Wakeup register)
 */

/*
 * Dump of fields for register: wufc
 *   lnkc (size 1, offset 0):	 RW	  Link status change
 *   mag (size 1, offset 1):	 RW	  Magic packet
 *   ex (size 1, offset 2):	 RW	  Directed exact
 *   mc (size 1, offset 3):	 RW	  Directed multicast
 *   bc (size 1, offset 4):	 RW	  Broadcast
 *   arp (size 1, offset 5):	 RW	  ARP request packet
 *   ipv4 (size 1, offset 6):	 RW	  Directed IPv4
 *   ipv6 (size 1, offset 7):	 RW	  Directed IPv6
 *   _anon8 (size 7, offset 8):	 MBZ	  _
 *   notco (size 1, offset 15):	 RW	  Ignore TCO/management packets
 *   flx0 (size 1, offset 16):	 RW	  Flexible filter 0 enable
 *   flx1 (size 1, offset 17):	 RW	  Flexible filter 1 enable
 *   flx2 (size 1, offset 18):	 RW	  Flexible filter 2 enable
 *   flx3 (size 1, offset 19):	 RW	  Flexible filter 3 enable
 *   _anon20 (size 12, offset 20):	 MBZ	  _
 */

static inline uint32_t __DP(wufc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(wufc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5808));
}

static inline e1000_wakeup_t __DP(wufc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_wakeup_t __DP(wufc_rd)( __DN(t) * _dev )
{
    e1000_wakeup_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5808));
    return u.val;
}

static inline void __DP(wufc_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(wufc_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5808),val);
}

static inline void __DP(wufc_wr)( __DN(t) * _dev, e1000_wakeup_t val ) __attribute__ ((always_inline));
static inline void __DP(wufc_wr)( __DN(t) * _dev, e1000_wakeup_t val )
{
    e1000_wakeup_un  u;
    u.val = val;
    u.val._anon8 	= 0;
    u.val._anon20 	= 0;
    mackerel_write_addr_32(_dev->base,(0x5808),u.raw);
}

static inline void __DP(wufc_lnkc_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(wufc_lnkc_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_wakeup_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5808));
    u.val._anon8 	= 0;
    u.val._anon20 	= 0;
    u.val.lnkc = val;
    mackerel_write_addr_32(_dev->base,(0x5808),u.raw);
}

static inline void __DP(wufc_mag_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(wufc_mag_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_wakeup_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5808));
    u.val._anon8 	= 0;
    u.val._anon20 	= 0;
    u.val.mag = val;
    mackerel_write_addr_32(_dev->base,(0x5808),u.raw);
}

static inline void __DP(wufc_ex_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(wufc_ex_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_wakeup_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5808));
    u.val._anon8 	= 0;
    u.val._anon20 	= 0;
    u.val.ex = val;
    mackerel_write_addr_32(_dev->base,(0x5808),u.raw);
}

static inline void __DP(wufc_mc_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(wufc_mc_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_wakeup_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5808));
    u.val._anon8 	= 0;
    u.val._anon20 	= 0;
    u.val.mc = val;
    mackerel_write_addr_32(_dev->base,(0x5808),u.raw);
}

static inline void __DP(wufc_bc_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(wufc_bc_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_wakeup_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5808));
    u.val._anon8 	= 0;
    u.val._anon20 	= 0;
    u.val.bc = val;
    mackerel_write_addr_32(_dev->base,(0x5808),u.raw);
}

static inline void __DP(wufc_arp_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(wufc_arp_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_wakeup_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5808));
    u.val._anon8 	= 0;
    u.val._anon20 	= 0;
    u.val.arp = val;
    mackerel_write_addr_32(_dev->base,(0x5808),u.raw);
}

static inline void __DP(wufc_ipv4_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(wufc_ipv4_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_wakeup_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5808));
    u.val._anon8 	= 0;
    u.val._anon20 	= 0;
    u.val.ipv4 = val;
    mackerel_write_addr_32(_dev->base,(0x5808),u.raw);
}

static inline void __DP(wufc_ipv6_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(wufc_ipv6_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_wakeup_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5808));
    u.val._anon8 	= 0;
    u.val._anon20 	= 0;
    u.val.ipv6 = val;
    mackerel_write_addr_32(_dev->base,(0x5808),u.raw);
}

static inline void __DP(wufc_notco_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(wufc_notco_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_wakeup_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5808));
    u.val._anon8 	= 0;
    u.val._anon20 	= 0;
    u.val.notco = val;
    mackerel_write_addr_32(_dev->base,(0x5808),u.raw);
}

static inline void __DP(wufc_flx0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(wufc_flx0_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_wakeup_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5808));
    u.val._anon8 	= 0;
    u.val._anon20 	= 0;
    u.val.flx0 = val;
    mackerel_write_addr_32(_dev->base,(0x5808),u.raw);
}

static inline void __DP(wufc_flx1_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(wufc_flx1_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_wakeup_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5808));
    u.val._anon8 	= 0;
    u.val._anon20 	= 0;
    u.val.flx1 = val;
    mackerel_write_addr_32(_dev->base,(0x5808),u.raw);
}

static inline void __DP(wufc_flx2_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(wufc_flx2_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_wakeup_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5808));
    u.val._anon8 	= 0;
    u.val._anon20 	= 0;
    u.val.flx2 = val;
    mackerel_write_addr_32(_dev->base,(0x5808),u.raw);
}

static inline void __DP(wufc_flx3_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(wufc_flx3_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_wakeup_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5808));
    u.val._anon8 	= 0;
    u.val._anon20 	= 0;
    u.val.flx3 = val;
    mackerel_write_addr_32(_dev->base,(0x5808),u.raw);
}


static inline int __DP(wufc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(wufc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_wakeup_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5808));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register wufc (Wakeup filter control):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.lnkc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lnkc =\t0x%"PRIx8" (Link status change", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mag;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mag =\t0x%"PRIx8" (Magic packet", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ex;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ex =\t0x%"PRIx8" (Directed exact", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mc =\t0x%"PRIx8" (Directed multicast", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.bc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " bc =\t0x%"PRIx8" (Broadcast", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.arp;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " arp =\t0x%"PRIx8" (ARP request packet", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ipv4;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ipv4 =\t0x%"PRIx8" (Directed IPv4", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ipv6;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ipv6 =\t0x%"PRIx8" (Directed IPv6", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.notco;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " notco =\t0x%"PRIx8" (Ignore TCO/management packets", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.flx0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " flx0 =\t0x%"PRIx8" (Flexible filter 0 enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.flx1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " flx1 =\t0x%"PRIx8" (Flexible filter 1 enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.flx2;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " flx2 =\t0x%"PRIx8" (Flexible filter 2 enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.flx3;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " flx3 =\t0x%"PRIx8" (Flexible filter 3 enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register wus (Wakeup status); type e1000.wakeup (Wakeup register)
 */

/*
 * Dump of fields for register: wus
 *   lnkc (size 1, offset 0):	 RO	  Link status change
 *   mag (size 1, offset 1):	 RO	  Magic packet
 *   ex (size 1, offset 2):	 RO	  Directed exact
 *   mc (size 1, offset 3):	 RO	  Directed multicast
 *   bc (size 1, offset 4):	 RO	  Broadcast
 *   arp (size 1, offset 5):	 RO	  ARP request packet
 *   ipv4 (size 1, offset 6):	 RO	  Directed IPv4
 *   ipv6 (size 1, offset 7):	 RO	  Directed IPv6
 *   _anon8 (size 7, offset 8):	 MBZ	  _
 *   notco (size 1, offset 15):	 RO	  Ignore TCO/management packets
 *   flx0 (size 1, offset 16):	 RO	  Flexible filter 0 enable
 *   flx1 (size 1, offset 17):	 RO	  Flexible filter 1 enable
 *   flx2 (size 1, offset 18):	 RO	  Flexible filter 2 enable
 *   flx3 (size 1, offset 19):	 RO	  Flexible filter 3 enable
 *   _anon20 (size 12, offset 20):	 MBZ	  _
 */

static inline uint32_t __DP(wus_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(wus_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5810));
}

static inline e1000_wakeup_t __DP(wus_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_wakeup_t __DP(wus_rd)( __DN(t) * _dev )
{
    e1000_wakeup_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5810));
    return u.val;
}

// Register wus is not writeable


static inline int __DP(wus_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(wus_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_wakeup_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5810));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register wus (Wakeup status):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.lnkc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lnkc =\t0x%"PRIx8" (Link status change", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mag;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mag =\t0x%"PRIx8" (Magic packet", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ex;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ex =\t0x%"PRIx8" (Directed exact", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mc =\t0x%"PRIx8" (Directed multicast", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.bc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " bc =\t0x%"PRIx8" (Broadcast", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.arp;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " arp =\t0x%"PRIx8" (ARP request packet", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ipv4;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ipv4 =\t0x%"PRIx8" (Directed IPv4", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ipv6;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ipv6 =\t0x%"PRIx8" (Directed IPv6", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.notco;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " notco =\t0x%"PRIx8" (Ignore TCO/management packets", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.flx0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " flx0 =\t0x%"PRIx8" (Flexible filter 0 enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.flx1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " flx1 =\t0x%"PRIx8" (Flexible filter 1 enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.flx2;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " flx2 =\t0x%"PRIx8" (Flexible filter 2 enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.flx3;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " flx3 =\t0x%"PRIx8" (Flexible filter 3 enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register ipav (IP address valid); type e1000.ipav (Implicit type of IP address valid register)
 */

/*
 * Dump of fields for register: ipav
 *   v40 (size 1, offset 0):	 RW	  IPv4 address 0 valid
 *   v41 (size 1, offset 1):	 RW	  IPv4 address 1 valid
 *   v42 (size 1, offset 2):	 RW	  IPv4 address 2 valid
 *   v43 (size 1, offset 3):	 RW	  IPv4 address 3 valid
 *   _anon4 (size 12, offset 4):	 MBZ	  _
 *   v60 (size 1, offset 16):	 RW	  IPv6 address 0 valid
 *   _anon17 (size 15, offset 17):	 MBZ	  _
 */

static inline uint32_t __DP(ipav_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ipav_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5838));
}

static inline e1000_ipav_t __DP(ipav_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_ipav_t __DP(ipav_rd)( __DN(t) * _dev )
{
    e1000_ipav_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5838));
    return u.val;
}

static inline void __DP(ipav_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(ipav_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5838),val);
}

static inline void __DP(ipav_wr)( __DN(t) * _dev, e1000_ipav_t val ) __attribute__ ((always_inline));
static inline void __DP(ipav_wr)( __DN(t) * _dev, e1000_ipav_t val )
{
    e1000_ipav_un  u;
    u.val = val;
    u.val._anon4 	= 0;
    u.val._anon17 	= 0;
    mackerel_write_addr_32(_dev->base,(0x5838),u.raw);
}

static inline void __DP(ipav_v40_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ipav_v40_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ipav_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5838));
    u.val._anon4 	= 0;
    u.val._anon17 	= 0;
    u.val.v40 = val;
    mackerel_write_addr_32(_dev->base,(0x5838),u.raw);
}

static inline void __DP(ipav_v41_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ipav_v41_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ipav_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5838));
    u.val._anon4 	= 0;
    u.val._anon17 	= 0;
    u.val.v41 = val;
    mackerel_write_addr_32(_dev->base,(0x5838),u.raw);
}

static inline void __DP(ipav_v42_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ipav_v42_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ipav_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5838));
    u.val._anon4 	= 0;
    u.val._anon17 	= 0;
    u.val.v42 = val;
    mackerel_write_addr_32(_dev->base,(0x5838),u.raw);
}

static inline void __DP(ipav_v43_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ipav_v43_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ipav_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5838));
    u.val._anon4 	= 0;
    u.val._anon17 	= 0;
    u.val.v43 = val;
    mackerel_write_addr_32(_dev->base,(0x5838),u.raw);
}

static inline void __DP(ipav_v60_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ipav_v60_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_ipav_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5838));
    u.val._anon4 	= 0;
    u.val._anon17 	= 0;
    u.val.v60 = val;
    mackerel_write_addr_32(_dev->base,(0x5838),u.raw);
}


static inline int __DP(ipav_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ipav_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_ipav_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5838));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ipav (IP address valid):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.v40;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " v40 =\t0x%"PRIx8" (IPv4 address 0 valid", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.v41;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " v41 =\t0x%"PRIx8" (IPv4 address 1 valid", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.v42;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " v42 =\t0x%"PRIx8" (IPv4 address 2 valid", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.v43;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " v43 =\t0x%"PRIx8" (IPv4 address 3 valid", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.v60;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " v60 =\t0x%"PRIx8" (IPv6 address 0 valid", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register ip4at (IPv4 address table); type e1000.uint32
 */
static const int __DP(ip4at_length) = 0x4;
static inline uint32_t __DP(ip4at_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(ip4at_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x5840) + (_i * 8));
}

static inline uint32_t __DP(ip4at_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(ip4at_rd)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x5840) + (_i * 8));
}

static inline void __DP(ip4at_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(ip4at_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5840) + (_i * 8),val);
}

static inline void __DP(ip4at_wr)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(ip4at_wr)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5840) + (_i * 8),val);
}


static inline int __DP(ip4at_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(ip4at_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register ip4at[%d] (IPv4 address table):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x5840) + (_i * 8)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}
static inline int __DP(ip4at_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ip4at_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x4; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(ip4at_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register ip6at (IPv6 address table); type e1000.uint32
 */
static const int __DP(ip6at_length) = 0x4;
static inline uint32_t __DP(ip6at_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(ip6at_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x5880) + (_i *(32/8)));
}

static inline uint32_t __DP(ip6at_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(ip6at_rd)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x5880) + (_i *(32/8)));
}

static inline void __DP(ip6at_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(ip6at_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5880) + (_i *(32/8)),val);
}

static inline void __DP(ip6at_wr)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(ip6at_wr)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5880) + (_i *(32/8)),val);
}


static inline int __DP(ip6at_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(ip6at_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register ip6at[%d] (IPv6 address table):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x5880) + (_i *(32/8))));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}
static inline int __DP(ip6at_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ip6at_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x4; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(ip6at_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register wupl (Wakeup packet length); type e1000.wupl (Implicit type of Wakeup packet length register)
 */

/*
 * Dump of fields for register: wupl
 *   len (size 12, offset 0):	 RW	  Length
 *   _anon12 (size 20, offset 12):	 MBZ	  _
 */

static inline uint32_t __DP(wupl_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(wupl_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5900));
}

static inline e1000_wupl_t __DP(wupl_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_wupl_t __DP(wupl_rd)( __DN(t) * _dev )
{
    e1000_wupl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5900));
    return u.val;
}

static inline void __DP(wupl_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(wupl_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5900),val);
}

static inline void __DP(wupl_wr)( __DN(t) * _dev, e1000_wupl_t val ) __attribute__ ((always_inline));
static inline void __DP(wupl_wr)( __DN(t) * _dev, e1000_wupl_t val )
{
    e1000_wupl_un  u;
    u.val = val;
    u.val._anon12 	= 0;
    mackerel_write_addr_32(_dev->base,(0x5900),u.raw);
}

static inline void __DP(wupl_len_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(wupl_len_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_wupl_un  u;
    u.val._anon12 	= 0;
    u.val.len = val;
    mackerel_write_addr_32(_dev->base,(0x5900),u.raw);
}


static inline int __DP(wupl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(wupl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_wupl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5900));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register wupl (Wakeup packet length):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.len;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " len =\t0x%0"PRIx16" (Length", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register wupm (Wakeup packet memory); type e1000.uint32
 */
static const int __DP(wupm_length) = 0x20;
static inline uint32_t __DP(wupm_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(wupm_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x5a00) + (_i *(32/8)));
}

static inline uint32_t __DP(wupm_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(wupm_rd)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x5a00) + (_i *(32/8)));
}

static inline void __DP(wupm_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(wupm_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5a00) + (_i *(32/8)),val);
}

static inline void __DP(wupm_wr)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(wupm_wr)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5a00) + (_i *(32/8)),val);
}


static inline int __DP(wupm_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(wupm_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register wupm[%d] (Wakeup packet memory):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x5a00) + (_i *(32/8))));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}
static inline int __DP(wupm_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(wupm_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x20; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(wupm_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register fflt (Flexible filter length table); type e1000.fflt (Implicit type of Flexible filter length table register array)
 */

/*
 * Dump of fields for register: fflt
 *   len (size 11, offset 0):	 RW	  Length
 *   _anon11 (size 21, offset 11):	 MBZ	  _
 */
static const int __DP(fflt_length) = 0x4;
static inline uint32_t __DP(fflt_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(fflt_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x5f00) + (_i * 8));
}

static inline e1000_fflt_t __DP(fflt_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline e1000_fflt_t __DP(fflt_rd)( __DN(t) * _dev, int _i )
{
    e1000_fflt_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5f00) + (_i * 8));
    return u.val;
}

static inline void __DP(fflt_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(fflt_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5f00) + (_i * 8),val);
}

static inline void __DP(fflt_wr)( __DN(t) * _dev, int _i, e1000_fflt_t val ) __attribute__ ((always_inline));
static inline void __DP(fflt_wr)( __DN(t) * _dev, int _i, e1000_fflt_t val )
{
    e1000_fflt_un  u;
    u.val = val;
    u.val._anon11 	= 0;
    mackerel_write_addr_32(_dev->base,(0x5f00) + (_i * 8),u.raw);
}

static inline void __DP(fflt_len_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(fflt_len_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    e1000_fflt_un  u;
    u.val._anon11 	= 0;
    u.val.len = val;
    mackerel_write_addr_32(_dev->base,(0x5f00) + (_i * 8),u.raw);
}


static inline int __DP(fflt_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(fflt_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    e1000_fflt_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5f00) + (_i * 8));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register fflt[%d] (Flexible filter length table):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.len;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " len =\t0x%0"PRIx16" (Length", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(fflt_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(fflt_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x4; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(fflt_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register ffltco (Flexible filter length table); type e1000.ffltco (Implicit type of Flexible filter length table register array)
 */

/*
 * Dump of fields for register: ffltco
 *   tcolen (size 11, offset 0):	 RW	  Length
 *   _anon11 (size 21, offset 11):	 MBZ	  _
 */
static const int __DP(ffltco_length) = 0x2;
static inline uint32_t __DP(ffltco_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(ffltco_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x5f20) + (_i * 8));
}

static inline e1000_ffltco_t __DP(ffltco_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline e1000_ffltco_t __DP(ffltco_rd)( __DN(t) * _dev, int _i )
{
    e1000_ffltco_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5f20) + (_i * 8));
    return u.val;
}

static inline void __DP(ffltco_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(ffltco_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5f20) + (_i * 8),val);
}

static inline void __DP(ffltco_wr)( __DN(t) * _dev, int _i, e1000_ffltco_t val ) __attribute__ ((always_inline));
static inline void __DP(ffltco_wr)( __DN(t) * _dev, int _i, e1000_ffltco_t val )
{
    e1000_ffltco_un  u;
    u.val = val;
    u.val._anon11 	= 0;
    mackerel_write_addr_32(_dev->base,(0x5f20) + (_i * 8),u.raw);
}

static inline void __DP(ffltco_tcolen_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(ffltco_tcolen_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    e1000_ffltco_un  u;
    u.val._anon11 	= 0;
    u.val.tcolen = val;
    mackerel_write_addr_32(_dev->base,(0x5f20) + (_i * 8),u.raw);
}


static inline int __DP(ffltco_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(ffltco_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    e1000_ffltco_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5f20) + (_i * 8));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register ffltco[%d] (Flexible filter length table):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.tcolen;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tcolen =\t0x%0"PRIx16" (Length", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(ffltco_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ffltco_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x2; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(ffltco_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register ffmt (Flexible filter mask table); type e1000.ffmt (Implicit type of Flexible filter mask table register array)
 */

/*
 * Dump of fields for register: ffmt
 *   mask (size 4, offset 0):	 RW	  mask
 *   _anon4 (size 28, offset 4):	 MBZ	  _
 */
static const int __DP(ffmt_length) = 0x80;
static inline uint32_t __DP(ffmt_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(ffmt_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x9000) + (_i * 8));
}

static inline e1000_ffmt_t __DP(ffmt_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline e1000_ffmt_t __DP(ffmt_rd)( __DN(t) * _dev, int _i )
{
    e1000_ffmt_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9000) + (_i * 8));
    return u.val;
}

static inline void __DP(ffmt_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(ffmt_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x9000) + (_i * 8),val);
}

static inline void __DP(ffmt_wr)( __DN(t) * _dev, int _i, e1000_ffmt_t val ) __attribute__ ((always_inline));
static inline void __DP(ffmt_wr)( __DN(t) * _dev, int _i, e1000_ffmt_t val )
{
    e1000_ffmt_un  u;
    u.val = val;
    u.val._anon4 	= 0;
    mackerel_write_addr_32(_dev->base,(0x9000) + (_i * 8),u.raw);
}

static inline void __DP(ffmt_mask_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ffmt_mask_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    e1000_ffmt_un  u;
    u.val._anon4 	= 0;
    u.val.mask = val;
    mackerel_write_addr_32(_dev->base,(0x9000) + (_i * 8),u.raw);
}


static inline int __DP(ffmt_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(ffmt_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    e1000_ffmt_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9000) + (_i * 8));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register ffmt[%d] (Flexible filter mask table):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.mask;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mask =\t0x%"PRIx8" (mask", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(ffmt_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ffmt_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x80; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(ffmt_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register ffvt (Flexible filter value table); type e1000.ffvt (Implicit type of Flexible filter value table register array)
 */

/*
 * Dump of fields for register: ffvt
 *   val0 (size 8, offset 0):	 RW	  Value 0
 *   val1 (size 8, offset 8):	 RW	  Value 1
 *   val2 (size 8, offset 16):	 RW	  Value 2
 *   val3 (size 8, offset 24):	 RW	  Value 3
 */
static const int __DP(ffvt_length) = 0x80;
static inline uint32_t __DP(ffvt_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(ffvt_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x9800) + (_i * 8));
}

static inline e1000_ffvt_t __DP(ffvt_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline e1000_ffvt_t __DP(ffvt_rd)( __DN(t) * _dev, int _i )
{
    e1000_ffvt_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9800) + (_i * 8));
    return u.val;
}

static inline void __DP(ffvt_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(ffvt_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x9800) + (_i * 8),val);
}

static inline void __DP(ffvt_wr)( __DN(t) * _dev, int _i, e1000_ffvt_t val ) __attribute__ ((always_inline));
static inline void __DP(ffvt_wr)( __DN(t) * _dev, int _i, e1000_ffvt_t val )
{
    e1000_ffvt_un  u;
    u.val = val;
    mackerel_write_addr_32(_dev->base,(0x9800) + (_i * 8),u.raw);
}

static inline void __DP(ffvt_val0_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ffvt_val0_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    e1000_ffvt_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9800) + (_i * 8));
    u.val.val0 = val;
    mackerel_write_addr_32(_dev->base,(0x9800) + (_i * 8),u.raw);
}

static inline void __DP(ffvt_val1_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ffvt_val1_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    e1000_ffvt_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9800) + (_i * 8));
    u.val.val1 = val;
    mackerel_write_addr_32(_dev->base,(0x9800) + (_i * 8),u.raw);
}

static inline void __DP(ffvt_val2_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ffvt_val2_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    e1000_ffvt_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9800) + (_i * 8));
    u.val.val2 = val;
    mackerel_write_addr_32(_dev->base,(0x9800) + (_i * 8),u.raw);
}

static inline void __DP(ffvt_val3_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ffvt_val3_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    e1000_ffvt_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9800) + (_i * 8));
    u.val.val3 = val;
    mackerel_write_addr_32(_dev->base,(0x9800) + (_i * 8),u.raw);
}


static inline int __DP(ffvt_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(ffvt_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    e1000_ffvt_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9800) + (_i * 8));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register ffvt[%d] (Flexible filter value table):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.val0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " val0 =\t0x%"PRIx8" (Value 0", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.val1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " val1 =\t0x%"PRIx8" (Value 1", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.val2;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " val2 =\t0x%"PRIx8" (Value 2", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.val3;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " val3 =\t0x%"PRIx8" (Value 3", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}
static inline int __DP(ffvt_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ffvt_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x80; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(ffvt_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register manc (Management control); type e1000.manc (Implicit type of Management control register)
 */

/*
 * Dump of fields for register: manc
 *   _anon0 (size 3, offset 0):	 MBZ	  _
 *   en_flexport0 (size 1, offset 3):	 RW	  Enable flex UDP/TCP port 0 filtering
 *   en_flexport1 (size 1, offset 4):	 RW	  Enable flex UDP/TCP port 1 filtering
 *   en_flexport2 (size 1, offset 5):	 RW	  Enable flex UDP/TCP port 2 filtering
 *   flex_tco1_filter (size 1, offset 6):	 RW	  Enable TCO filter 1
 *   flex_tco0_filter (size 1, offset 7):	 RW	  Enable TCO filter 0
 *   rmcp_en (size 1, offset 8):	 RW	  Enable RMCP 0x026f filtering
 *   o298_en (size 1, offset 9):	 RW	  Enable RMCP 0x0298 filtering
 *   _anon10 (size 3, offset 10):	 MBZ	  _
 *   arp_req_en (size 1, offset 13):	 RW	  Enable ARP request filtering
 *   neighbor_en (size 1, offset 14):	 RW	  Enable neighbor discovery filtering
 *   arp_res_en (size 1, offset 15):	 RW	  Enable ARP response filtering
 *   tco_reset (size 1, offset 16):	 RW	  TCO reset occurred
 *   rcv_tco_en (size 1, offset 17):	 RW	  Receive TCO packets enable
 *   blk_phyrst_on_ide (size 1, offset 18):	 RW	  Block PHY reset and power on state changes
 *   rcv_all (size 1, offset 19):	 RW	  Receive all enable
 *   en_mac16_filter (size 1, offset 20):	 RW	  Enable MAC address 16 filtering
 *   en_mng2host (size 1, offset 21):	 RW	  Enable firmware packets to host memory
 *   en_ip_addrfilter (size 1, offset 22):	 RW	  Enable IP address filtering
 *   en_xsum_filter (size 1, offset 23):	 RW	  Enable Xsum filtering to firmware
 *   br_en (size 1, offset 24):	 RW	  Enable broadcast filtering
 *   _anon25 (size 7, offset 25):	 MBZ	  _
 */

static inline uint32_t __DP(manc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(manc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5820));
}

static inline e1000_manc_t __DP(manc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_manc_t __DP(manc_rd)( __DN(t) * _dev )
{
    e1000_manc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5820));
    return u.val;
}

static inline void __DP(manc_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(manc_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5820),val);
}

static inline void __DP(manc_wr)( __DN(t) * _dev, e1000_manc_t val ) __attribute__ ((always_inline));
static inline void __DP(manc_wr)( __DN(t) * _dev, e1000_manc_t val )
{
    e1000_manc_un  u;
    u.val = val;
    u.val._anon0 	= 0;
    u.val._anon10 	= 0;
    u.val._anon25 	= 0;
    mackerel_write_addr_32(_dev->base,(0x5820),u.raw);
}

static inline void __DP(manc_en_flexport0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(manc_en_flexport0_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_manc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5820));
    u.val._anon0 	= 0;
    u.val._anon10 	= 0;
    u.val._anon25 	= 0;
    u.val.en_flexport0 = val;
    mackerel_write_addr_32(_dev->base,(0x5820),u.raw);
}

static inline void __DP(manc_en_flexport1_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(manc_en_flexport1_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_manc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5820));
    u.val._anon0 	= 0;
    u.val._anon10 	= 0;
    u.val._anon25 	= 0;
    u.val.en_flexport1 = val;
    mackerel_write_addr_32(_dev->base,(0x5820),u.raw);
}

static inline void __DP(manc_en_flexport2_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(manc_en_flexport2_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_manc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5820));
    u.val._anon0 	= 0;
    u.val._anon10 	= 0;
    u.val._anon25 	= 0;
    u.val.en_flexport2 = val;
    mackerel_write_addr_32(_dev->base,(0x5820),u.raw);
}

static inline void __DP(manc_flex_tco1_filter_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(manc_flex_tco1_filter_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_manc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5820));
    u.val._anon0 	= 0;
    u.val._anon10 	= 0;
    u.val._anon25 	= 0;
    u.val.flex_tco1_filter = val;
    mackerel_write_addr_32(_dev->base,(0x5820),u.raw);
}

static inline void __DP(manc_flex_tco0_filter_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(manc_flex_tco0_filter_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_manc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5820));
    u.val._anon0 	= 0;
    u.val._anon10 	= 0;
    u.val._anon25 	= 0;
    u.val.flex_tco0_filter = val;
    mackerel_write_addr_32(_dev->base,(0x5820),u.raw);
}

static inline void __DP(manc_rmcp_en_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(manc_rmcp_en_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_manc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5820));
    u.val._anon0 	= 0;
    u.val._anon10 	= 0;
    u.val._anon25 	= 0;
    u.val.rmcp_en = val;
    mackerel_write_addr_32(_dev->base,(0x5820),u.raw);
}

static inline void __DP(manc_o298_en_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(manc_o298_en_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_manc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5820));
    u.val._anon0 	= 0;
    u.val._anon10 	= 0;
    u.val._anon25 	= 0;
    u.val.o298_en = val;
    mackerel_write_addr_32(_dev->base,(0x5820),u.raw);
}

static inline void __DP(manc_arp_req_en_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(manc_arp_req_en_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_manc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5820));
    u.val._anon0 	= 0;
    u.val._anon10 	= 0;
    u.val._anon25 	= 0;
    u.val.arp_req_en = val;
    mackerel_write_addr_32(_dev->base,(0x5820),u.raw);
}

static inline void __DP(manc_neighbor_en_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(manc_neighbor_en_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_manc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5820));
    u.val._anon0 	= 0;
    u.val._anon10 	= 0;
    u.val._anon25 	= 0;
    u.val.neighbor_en = val;
    mackerel_write_addr_32(_dev->base,(0x5820),u.raw);
}

static inline void __DP(manc_arp_res_en_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(manc_arp_res_en_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_manc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5820));
    u.val._anon0 	= 0;
    u.val._anon10 	= 0;
    u.val._anon25 	= 0;
    u.val.arp_res_en = val;
    mackerel_write_addr_32(_dev->base,(0x5820),u.raw);
}

static inline void __DP(manc_tco_reset_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(manc_tco_reset_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_manc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5820));
    u.val._anon0 	= 0;
    u.val._anon10 	= 0;
    u.val._anon25 	= 0;
    u.val.tco_reset = val;
    mackerel_write_addr_32(_dev->base,(0x5820),u.raw);
}

static inline void __DP(manc_rcv_tco_en_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(manc_rcv_tco_en_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_manc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5820));
    u.val._anon0 	= 0;
    u.val._anon10 	= 0;
    u.val._anon25 	= 0;
    u.val.rcv_tco_en = val;
    mackerel_write_addr_32(_dev->base,(0x5820),u.raw);
}

static inline void __DP(manc_blk_phyrst_on_ide_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(manc_blk_phyrst_on_ide_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_manc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5820));
    u.val._anon0 	= 0;
    u.val._anon10 	= 0;
    u.val._anon25 	= 0;
    u.val.blk_phyrst_on_ide = val;
    mackerel_write_addr_32(_dev->base,(0x5820),u.raw);
}

static inline void __DP(manc_rcv_all_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(manc_rcv_all_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_manc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5820));
    u.val._anon0 	= 0;
    u.val._anon10 	= 0;
    u.val._anon25 	= 0;
    u.val.rcv_all = val;
    mackerel_write_addr_32(_dev->base,(0x5820),u.raw);
}

static inline void __DP(manc_en_mac16_filter_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(manc_en_mac16_filter_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_manc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5820));
    u.val._anon0 	= 0;
    u.val._anon10 	= 0;
    u.val._anon25 	= 0;
    u.val.en_mac16_filter = val;
    mackerel_write_addr_32(_dev->base,(0x5820),u.raw);
}

static inline void __DP(manc_en_mng2host_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(manc_en_mng2host_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_manc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5820));
    u.val._anon0 	= 0;
    u.val._anon10 	= 0;
    u.val._anon25 	= 0;
    u.val.en_mng2host = val;
    mackerel_write_addr_32(_dev->base,(0x5820),u.raw);
}

static inline void __DP(manc_en_ip_addrfilter_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(manc_en_ip_addrfilter_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_manc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5820));
    u.val._anon0 	= 0;
    u.val._anon10 	= 0;
    u.val._anon25 	= 0;
    u.val.en_ip_addrfilter = val;
    mackerel_write_addr_32(_dev->base,(0x5820),u.raw);
}

static inline void __DP(manc_en_xsum_filter_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(manc_en_xsum_filter_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_manc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5820));
    u.val._anon0 	= 0;
    u.val._anon10 	= 0;
    u.val._anon25 	= 0;
    u.val.en_xsum_filter = val;
    mackerel_write_addr_32(_dev->base,(0x5820),u.raw);
}

static inline void __DP(manc_br_en_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(manc_br_en_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_manc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5820));
    u.val._anon0 	= 0;
    u.val._anon10 	= 0;
    u.val._anon25 	= 0;
    u.val.br_en = val;
    mackerel_write_addr_32(_dev->base,(0x5820),u.raw);
}


static inline int __DP(manc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(manc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_manc_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5820));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register manc (Management control):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.en_flexport0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " en_flexport0 =\t0x%"PRIx8" (Enable flex UDP/TCP port 0 filtering", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.en_flexport1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " en_flexport1 =\t0x%"PRIx8" (Enable flex UDP/TCP port 1 filtering", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.en_flexport2;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " en_flexport2 =\t0x%"PRIx8" (Enable flex UDP/TCP port 2 filtering", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.flex_tco1_filter;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " flex_tco1_filter =\t0x%"PRIx8" (Enable TCO filter 1", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.flex_tco0_filter;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " flex_tco0_filter =\t0x%"PRIx8" (Enable TCO filter 0", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rmcp_en;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rmcp_en =\t0x%"PRIx8" (Enable RMCP 0x026f filtering", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.o298_en;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " o298_en =\t0x%"PRIx8" (Enable RMCP 0x0298 filtering", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.arp_req_en;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " arp_req_en =\t0x%"PRIx8" (Enable ARP request filtering", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.neighbor_en;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " neighbor_en =\t0x%"PRIx8" (Enable neighbor discovery filtering", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.arp_res_en;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " arp_res_en =\t0x%"PRIx8" (Enable ARP response filtering", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.tco_reset;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tco_reset =\t0x%"PRIx8" (TCO reset occurred", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rcv_tco_en;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rcv_tco_en =\t0x%"PRIx8" (Receive TCO packets enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.blk_phyrst_on_ide;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " blk_phyrst_on_ide =\t0x%"PRIx8" (Block PHY reset and power on state changes", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rcv_all;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rcv_all =\t0x%"PRIx8" (Receive all enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.en_mac16_filter;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " en_mac16_filter =\t0x%"PRIx8" (Enable MAC address 16 filtering", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.en_mng2host;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " en_mng2host =\t0x%"PRIx8" (Enable firmware packets to host memory", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.en_ip_addrfilter;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " en_ip_addrfilter =\t0x%"PRIx8" (Enable IP address filtering", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.en_xsum_filter;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " en_xsum_filter =\t0x%"PRIx8" (Enable Xsum filtering to firmware", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.br_en;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " br_en =\t0x%"PRIx8" (Enable broadcast filtering", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register gcr (PCIe control); type e1000.gcr (Implicit type of PCIe control register)
 */

/*
 * Dump of fields for register: gcr
 *   rxd_nosnoop (size 1, offset 0):	 RW	  Receive data write
 *   rxdscw_nosnoop (size 1, offset 1):	 RW	  Receive descriptor write
 *   rxdscr_nosnoop (size 1, offset 2):	 RW	  Receive descriptor read
 *   txd_nosnoop (size 1, offset 3):	 RW	  Transmit data write
 *   txdscw_nosnoop (size 1, offset 4):	 RW	  Transmit descriptor write
 *   txdscr_nosnoop (size 1, offset 5):	 RW	  Transmit descriptor read
 *   elec_idle_in0 (size 1, offset 6):	 RO	  SerDes0 internal electrical idle indicator
 *   elec_idle_in1 (size 1, offset 7):	 RO	  SerDes1 internal electrical idle indicator
 *   self_test_enable (size 1, offset 8):	 RW	  Perform self test
 *   _anon9 (size 12, offset 9):	 MBZ	  _
 *   logheader (size 1, offset 21):	 RW	  Log header into PCI config space
 *   _anon22 (size 1, offset 22):	 MBZ	  _
 *   l1el_msb (size 1, offset 23):	 RO	  L1 Entry latency msb
 *   l0s_el (size 1, offset 24):	 RW	  L0s entry latency
 *   l1el_lsb (size 2, offset 25):	 RO	  L1 Entry latency lsbs
 *   l1_aw_l0s (size 1, offset 27):	 RW	  L1 act without L0s_rx correlation
 *   gio_dis_rderr (size 1, offset 28):	 RW	  Disable running disparity err
 *   gio_good_10s (size 1, offset 29):	 RW	  Force good PCIe l0s training
 *   self_test_result (size 1, offset 30):	 RW	  Result of self test
 *   dis_tmout (size 1, offset 31):	 RW	  Disable PCIe timeout mechanism
 */

static inline uint32_t __DP(gcr_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(gcr_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5b00));
}

static inline e1000_gcr_t __DP(gcr_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_gcr_t __DP(gcr_rd)( __DN(t) * _dev )
{
    e1000_gcr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b00));
    return u.val;
}

static inline void __DP(gcr_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(gcr_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5b00),val);
}

static inline void __DP(gcr_wr)( __DN(t) * _dev, e1000_gcr_t val ) __attribute__ ((always_inline));
static inline void __DP(gcr_wr)( __DN(t) * _dev, e1000_gcr_t val )
{
    e1000_gcr_un  u;
    u.val = val;
    u.val._anon9 	= 0;
    u.val._anon22 	= 0;
    mackerel_write_addr_32(_dev->base,(0x5b00),u.raw);
}

static inline void __DP(gcr_rxd_nosnoop_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gcr_rxd_nosnoop_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gcr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b00));
    u.val._anon9 	= 0;
    u.val._anon22 	= 0;
    u.val.rxd_nosnoop = val;
    mackerel_write_addr_32(_dev->base,(0x5b00),u.raw);
}

static inline void __DP(gcr_rxdscw_nosnoop_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gcr_rxdscw_nosnoop_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gcr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b00));
    u.val._anon9 	= 0;
    u.val._anon22 	= 0;
    u.val.rxdscw_nosnoop = val;
    mackerel_write_addr_32(_dev->base,(0x5b00),u.raw);
}

static inline void __DP(gcr_rxdscr_nosnoop_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gcr_rxdscr_nosnoop_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gcr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b00));
    u.val._anon9 	= 0;
    u.val._anon22 	= 0;
    u.val.rxdscr_nosnoop = val;
    mackerel_write_addr_32(_dev->base,(0x5b00),u.raw);
}

static inline void __DP(gcr_txd_nosnoop_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gcr_txd_nosnoop_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gcr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b00));
    u.val._anon9 	= 0;
    u.val._anon22 	= 0;
    u.val.txd_nosnoop = val;
    mackerel_write_addr_32(_dev->base,(0x5b00),u.raw);
}

static inline void __DP(gcr_txdscw_nosnoop_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gcr_txdscw_nosnoop_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gcr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b00));
    u.val._anon9 	= 0;
    u.val._anon22 	= 0;
    u.val.txdscw_nosnoop = val;
    mackerel_write_addr_32(_dev->base,(0x5b00),u.raw);
}

static inline void __DP(gcr_txdscr_nosnoop_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gcr_txdscr_nosnoop_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gcr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b00));
    u.val._anon9 	= 0;
    u.val._anon22 	= 0;
    u.val.txdscr_nosnoop = val;
    mackerel_write_addr_32(_dev->base,(0x5b00),u.raw);
}

static inline void __DP(gcr_self_test_enable_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gcr_self_test_enable_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gcr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b00));
    u.val._anon9 	= 0;
    u.val._anon22 	= 0;
    u.val.self_test_enable = val;
    mackerel_write_addr_32(_dev->base,(0x5b00),u.raw);
}

static inline void __DP(gcr_logheader_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gcr_logheader_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gcr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b00));
    u.val._anon9 	= 0;
    u.val._anon22 	= 0;
    u.val.logheader = val;
    mackerel_write_addr_32(_dev->base,(0x5b00),u.raw);
}

static inline void __DP(gcr_l0s_el_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gcr_l0s_el_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gcr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b00));
    u.val._anon9 	= 0;
    u.val._anon22 	= 0;
    u.val.l0s_el = val;
    mackerel_write_addr_32(_dev->base,(0x5b00),u.raw);
}

static inline void __DP(gcr_l1_aw_l0s_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gcr_l1_aw_l0s_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gcr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b00));
    u.val._anon9 	= 0;
    u.val._anon22 	= 0;
    u.val.l1_aw_l0s = val;
    mackerel_write_addr_32(_dev->base,(0x5b00),u.raw);
}

static inline void __DP(gcr_gio_dis_rderr_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gcr_gio_dis_rderr_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gcr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b00));
    u.val._anon9 	= 0;
    u.val._anon22 	= 0;
    u.val.gio_dis_rderr = val;
    mackerel_write_addr_32(_dev->base,(0x5b00),u.raw);
}

static inline void __DP(gcr_gio_good_10s_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gcr_gio_good_10s_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gcr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b00));
    u.val._anon9 	= 0;
    u.val._anon22 	= 0;
    u.val.gio_good_10s = val;
    mackerel_write_addr_32(_dev->base,(0x5b00),u.raw);
}

static inline void __DP(gcr_self_test_result_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gcr_self_test_result_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gcr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b00));
    u.val._anon9 	= 0;
    u.val._anon22 	= 0;
    u.val.self_test_result = val;
    mackerel_write_addr_32(_dev->base,(0x5b00),u.raw);
}

static inline void __DP(gcr_dis_tmout_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gcr_dis_tmout_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gcr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b00));
    u.val._anon9 	= 0;
    u.val._anon22 	= 0;
    u.val.dis_tmout = val;
    mackerel_write_addr_32(_dev->base,(0x5b00),u.raw);
}


static inline int __DP(gcr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(gcr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_gcr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b00));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register gcr (PCIe control):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.rxd_nosnoop;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxd_nosnoop =\t0x%"PRIx8" (Receive data write", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rxdscw_nosnoop;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxdscw_nosnoop =\t0x%"PRIx8" (Receive descriptor write", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rxdscr_nosnoop;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rxdscr_nosnoop =\t0x%"PRIx8" (Receive descriptor read", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.txd_nosnoop;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txd_nosnoop =\t0x%"PRIx8" (Transmit data write", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.txdscw_nosnoop;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txdscw_nosnoop =\t0x%"PRIx8" (Transmit descriptor write", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.txdscr_nosnoop;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " txdscr_nosnoop =\t0x%"PRIx8" (Transmit descriptor read", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.elec_idle_in0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " elec_idle_in0 =\t0x%"PRIx8" (SerDes0 internal electrical idle indicator", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.elec_idle_in1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " elec_idle_in1 =\t0x%"PRIx8" (SerDes1 internal electrical idle indicator", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.self_test_enable;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " self_test_enable =\t0x%"PRIx8" (Perform self test", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.logheader;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " logheader =\t0x%"PRIx8" (Log header into PCI config space", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.l1el_msb;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " l1el_msb =\t0x%"PRIx8" (L1 Entry latency msb", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.l0s_el;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " l0s_el =\t0x%"PRIx8" (L0s entry latency", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.l1el_lsb;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " l1el_lsb =\t0x%"PRIx8" (L1 Entry latency lsbs", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.l1_aw_l0s;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " l1_aw_l0s =\t0x%"PRIx8" (L1 act without L0s_rx correlation", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.gio_dis_rderr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " gio_dis_rderr =\t0x%"PRIx8" (Disable running disparity err", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.gio_good_10s;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " gio_good_10s =\t0x%"PRIx8" (Force good PCIe l0s training", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.self_test_result;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " self_test_result =\t0x%"PRIx8" (Result of self test", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dis_tmout;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dis_tmout =\t0x%"PRIx8" (Disable PCIe timeout mechanism", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register gscl1 (PCIe statistics control 1); type e1000.gscl1 (Implicit type of PCIe statistics control 1 register)
 */

/*
 * Dump of fields for register: gscl1
 *   count_en0 (size 1, offset 0):	 RW	  Enable PCIe stats counter 0
 *   count_en1 (size 1, offset 1):	 RW	  Enable PCIe stats counter 1
 *   count_en2 (size 1, offset 2):	 RW	  Enable PCIe stats counter 2
 *   count_en3 (size 1, offset 3):	 RW	  Enable PCIe stats counter 3
 *   _anon4 (size 23, offset 4):	 RSVD	  _
 *   count_test (size 1, offset 27):	 RW	  Test bit
 *   en_64bit (size 1, offset 28):	 RW	  Enable two 64-bit counters instead of 4 32-bit
 *   count_reset (size 1, offset 29):	 RW	  Reset indication of PCIe stats
 *   count_stop (size 1, offset 30):	 RW	  Stop indication
 *   count_start (size 1, offset 31):	 RW	  Start indication
 */

static inline uint32_t __DP(gscl1_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(gscl1_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5b10));
}

static inline e1000_gscl1_t __DP(gscl1_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_gscl1_t __DP(gscl1_rd)( __DN(t) * _dev )
{
    e1000_gscl1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b10));
    return u.val;
}

static inline void __DP(gscl1_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(gscl1_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5b10),val);
}

static inline void __DP(gscl1_wr)( __DN(t) * _dev, e1000_gscl1_t val ) __attribute__ ((always_inline));
static inline void __DP(gscl1_wr)( __DN(t) * _dev, e1000_gscl1_t val )
{
    e1000_gscl1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b10));
    u.val.count_en0 	= val.count_en0;
    u.val.count_en1 	= val.count_en1;
    u.val.count_en2 	= val.count_en2;
    u.val.count_en3 	= val.count_en3;
    u.val.count_test 	= val.count_test;
    u.val.en_64bit 	= val.en_64bit;
    u.val.count_reset 	= val.count_reset;
    u.val.count_stop 	= val.count_stop;
    u.val.count_start 	= val.count_start;
    mackerel_write_addr_32(_dev->base,(0x5b10),u.raw);
}

static inline void __DP(gscl1_count_en0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gscl1_count_en0_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gscl1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b10));
    u.val.count_en0 = val;
    mackerel_write_addr_32(_dev->base,(0x5b10),u.raw);
}

static inline void __DP(gscl1_count_en1_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gscl1_count_en1_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gscl1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b10));
    u.val.count_en1 = val;
    mackerel_write_addr_32(_dev->base,(0x5b10),u.raw);
}

static inline void __DP(gscl1_count_en2_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gscl1_count_en2_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gscl1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b10));
    u.val.count_en2 = val;
    mackerel_write_addr_32(_dev->base,(0x5b10),u.raw);
}

static inline void __DP(gscl1_count_en3_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gscl1_count_en3_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gscl1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b10));
    u.val.count_en3 = val;
    mackerel_write_addr_32(_dev->base,(0x5b10),u.raw);
}

static inline void __DP(gscl1_count_test_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gscl1_count_test_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gscl1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b10));
    u.val.count_test = val;
    mackerel_write_addr_32(_dev->base,(0x5b10),u.raw);
}

static inline void __DP(gscl1_en_64bit_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gscl1_en_64bit_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gscl1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b10));
    u.val.en_64bit = val;
    mackerel_write_addr_32(_dev->base,(0x5b10),u.raw);
}

static inline void __DP(gscl1_count_reset_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gscl1_count_reset_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gscl1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b10));
    u.val.count_reset = val;
    mackerel_write_addr_32(_dev->base,(0x5b10),u.raw);
}

static inline void __DP(gscl1_count_stop_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gscl1_count_stop_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gscl1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b10));
    u.val.count_stop = val;
    mackerel_write_addr_32(_dev->base,(0x5b10),u.raw);
}

static inline void __DP(gscl1_count_start_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gscl1_count_start_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gscl1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b10));
    u.val.count_start = val;
    mackerel_write_addr_32(_dev->base,(0x5b10),u.raw);
}


static inline int __DP(gscl1_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(gscl1_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_gscl1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b10));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register gscl1 (PCIe statistics control 1):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.count_en0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " count_en0 =\t0x%"PRIx8" (Enable PCIe stats counter 0", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.count_en1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " count_en1 =\t0x%"PRIx8" (Enable PCIe stats counter 1", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.count_en2;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " count_en2 =\t0x%"PRIx8" (Enable PCIe stats counter 2", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.count_en3;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " count_en3 =\t0x%"PRIx8" (Enable PCIe stats counter 3", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.count_test;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " count_test =\t0x%"PRIx8" (Test bit", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.en_64bit;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " en_64bit =\t0x%"PRIx8" (Enable two 64-bit counters instead of 4 32-bit", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.count_reset;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " count_reset =\t0x%"PRIx8" (Reset indication of PCIe stats", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.count_stop;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " count_stop =\t0x%"PRIx8" (Stop indication", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.count_start;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " count_start =\t0x%"PRIx8" (Start indication", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register gscl2 (PCIe statistics control 2); type e1000.gscl2 (Implicit type of PCIe statistics control 2 register)
 */

/*
 * Dump of fields for register: gscl2
 *   event0 (size 8, offset 0):	 RW	  Event number that counter 0 counts
 *   event1 (size 8, offset 8):	 RW	  Event number that counter 1 counts
 *   event2 (size 8, offset 16):	 RW	  Event number that counter 2 counts
 *   event3 (size 8, offset 24):	 RW	  Event number that counter 3 counts
 */

static inline uint32_t __DP(gscl2_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(gscl2_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5b14));
}

static inline e1000_gscl2_t __DP(gscl2_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_gscl2_t __DP(gscl2_rd)( __DN(t) * _dev )
{
    e1000_gscl2_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b14));
    return u.val;
}

static inline void __DP(gscl2_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(gscl2_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5b14),val);
}

static inline void __DP(gscl2_wr)( __DN(t) * _dev, e1000_gscl2_t val ) __attribute__ ((always_inline));
static inline void __DP(gscl2_wr)( __DN(t) * _dev, e1000_gscl2_t val )
{
    e1000_gscl2_un  u;
    u.val = val;
    mackerel_write_addr_32(_dev->base,(0x5b14),u.raw);
}

static inline void __DP(gscl2_event0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gscl2_event0_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gscl2_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b14));
    u.val.event0 = val;
    mackerel_write_addr_32(_dev->base,(0x5b14),u.raw);
}

static inline void __DP(gscl2_event1_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gscl2_event1_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gscl2_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b14));
    u.val.event1 = val;
    mackerel_write_addr_32(_dev->base,(0x5b14),u.raw);
}

static inline void __DP(gscl2_event2_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gscl2_event2_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gscl2_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b14));
    u.val.event2 = val;
    mackerel_write_addr_32(_dev->base,(0x5b14),u.raw);
}

static inline void __DP(gscl2_event3_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gscl2_event3_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gscl2_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b14));
    u.val.event3 = val;
    mackerel_write_addr_32(_dev->base,(0x5b14),u.raw);
}


static inline int __DP(gscl2_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(gscl2_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_gscl2_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b14));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register gscl2 (PCIe statistics control 2):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.event0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " event0 =\t0x%"PRIx8" (Event number that counter 0 counts", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.event1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " event1 =\t0x%"PRIx8" (Event number that counter 1 counts", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.event2;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " event2 =\t0x%"PRIx8" (Event number that counter 2 counts", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.event3;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " event3 =\t0x%"PRIx8" (Event number that counter 3 counts", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register gscl3 (PCIe statistics control 3); type e1000.gscl3 (Implicit type of PCIe statistics control 3 register)
 */

/*
 * Dump of fields for register: gscl3
 *   fc_th0 (size 12, offset 0):	 RW	  Threshold of flow control credits 0
 *   _anon12 (size 4, offset 12):	 RSVD	  _
 *   fc_th1 (size 12, offset 16):	 RW	  Threshold of flow control credits 1
 *   _anon28 (size 4, offset 28):	 RSVD	  _
 */

static inline uint32_t __DP(gscl3_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(gscl3_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5b18));
}

static inline e1000_gscl3_t __DP(gscl3_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_gscl3_t __DP(gscl3_rd)( __DN(t) * _dev )
{
    e1000_gscl3_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b18));
    return u.val;
}

static inline void __DP(gscl3_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(gscl3_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5b18),val);
}

static inline void __DP(gscl3_wr)( __DN(t) * _dev, e1000_gscl3_t val ) __attribute__ ((always_inline));
static inline void __DP(gscl3_wr)( __DN(t) * _dev, e1000_gscl3_t val )
{
    e1000_gscl3_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b18));
    u.val.fc_th0 	= val.fc_th0;
    u.val.fc_th1 	= val.fc_th1;
    mackerel_write_addr_32(_dev->base,(0x5b18),u.raw);
}

static inline void __DP(gscl3_fc_th0_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(gscl3_fc_th0_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_gscl3_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b18));
    u.val.fc_th0 = val;
    mackerel_write_addr_32(_dev->base,(0x5b18),u.raw);
}

static inline void __DP(gscl3_fc_th1_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(gscl3_fc_th1_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_gscl3_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b18));
    u.val.fc_th1 = val;
    mackerel_write_addr_32(_dev->base,(0x5b18),u.raw);
}


static inline int __DP(gscl3_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(gscl3_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_gscl3_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b18));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register gscl3 (PCIe statistics control 3):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.fc_th0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fc_th0 =\t0x%0"PRIx16" (Threshold of flow control credits 0", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint16_t pv = (uint16_t)u.val.fc_th1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fc_th1 =\t0x%0"PRIx16" (Threshold of flow control credits 1", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register gscl4 (PCIe statistics control 4); type e1000.gscl4 (Implicit type of PCIe statistics control 4 register)
 */

/*
 * Dump of fields for register: gscl4
 *   coml_th (size 10, offset 0):	 RW	  Completions latency threshold
 *   rb_th (size 6, offset 10):	 RW	  Retry buffer threshold
 *   _anon16 (size 16, offset 16):	 RSVD	  _
 */

static inline uint32_t __DP(gscl4_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(gscl4_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5b1c));
}

static inline e1000_gscl4_t __DP(gscl4_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_gscl4_t __DP(gscl4_rd)( __DN(t) * _dev )
{
    e1000_gscl4_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b1c));
    return u.val;
}

static inline void __DP(gscl4_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(gscl4_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5b1c),val);
}

static inline void __DP(gscl4_wr)( __DN(t) * _dev, e1000_gscl4_t val ) __attribute__ ((always_inline));
static inline void __DP(gscl4_wr)( __DN(t) * _dev, e1000_gscl4_t val )
{
    e1000_gscl4_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b1c));
    u.val.coml_th 	= val.coml_th;
    u.val.rb_th 	= val.rb_th;
    mackerel_write_addr_32(_dev->base,(0x5b1c),u.raw);
}

static inline void __DP(gscl4_coml_th_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(gscl4_coml_th_wrf)( __DN(t) * _dev, uint16_t val )
{
    e1000_gscl4_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b1c));
    u.val.coml_th = val;
    mackerel_write_addr_32(_dev->base,(0x5b1c),u.raw);
}

static inline void __DP(gscl4_rb_th_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gscl4_rb_th_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_gscl4_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b1c));
    u.val.rb_th = val;
    mackerel_write_addr_32(_dev->base,(0x5b1c),u.raw);
}


static inline int __DP(gscl4_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(gscl4_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_gscl4_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b1c));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register gscl4 (PCIe statistics control 4):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.coml_th;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " coml_th =\t0x%0"PRIx16" (Completions latency threshold", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rb_th;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rb_th =\t0x%"PRIx8" (Retry buffer threshold", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register gscn (PCIe counter); type e1000.uint32
 */
static const int __DP(gscn_length) = 0x4;
static inline uint32_t __DP(gscn_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(gscn_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x5b20) + (_i *(32/8)));
}

static inline uint32_t __DP(gscn_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(gscn_rd)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x5b20) + (_i *(32/8)));
}

static inline void __DP(gscn_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(gscn_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5b20) + (_i *(32/8)),val);
}

static inline void __DP(gscn_wr)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(gscn_wr)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5b20) + (_i *(32/8)),val);
}


static inline int __DP(gscn_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(gscn_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register gscn[%d] (PCIe counter):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x5b20) + (_i *(32/8))));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}
static inline int __DP(gscn_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(gscn_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x4; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(gscn_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register factps (Fn. active & power state to MNG); type e1000.factps (Implicit type of Fn. active & power state to MNG register)
 */

/*
 * Dump of fields for register: factps
 *   f0ps (size 2, offset 0):	 RO	  Power state of fn. 0
 *   lan0v (size 1, offset 2):	 RO	  LAN 0 valid enable
 *   f0aux (size 1, offset 3):	 RO	  Fn. 0 aux power enable shadow
 *   lan0en (size 1, offset 4):	 RO	  LAN 0 enabled
 *   _anon5 (size 1, offset 5):	 RSVD	  _
 *   f1ps (size 2, offset 6):	 RO	  Power state of fn. 1
 *   lan1v (size 1, offset 8):	 RO	  LAN 1 valid enable
 *   f1aux (size 1, offset 9):	 RO	  Fn. 1 aux power enable shadow
 *   lan1en (size 1, offset 10):	 RO	  LAN 1 enabled
 *   _anon11 (size 1, offset 11):	 RSVD	  _
 *   f2ps (size 2, offset 12):	 RO	  Power state of fn. 2
 *   ide_en (size 1, offset 14):	 RO	  IDE (function 2) enable
 *   f2aux (size 1, offset 15):	 RO	  Fn. 2 aux power enable shadow
 *   _anon16 (size 2, offset 16):	 RSVD	  _
 *   f3ps (size 2, offset 18):	 RO	  Power state of fn. 3
 *   sp_en (size 1, offset 20):	 RO	  SP (function 3) enable
 *   f3aux (size 1, offset 21):	 RO	  Fn. 3 aux power enable shadow
 *   _anon22 (size 2, offset 22):	 RSVD	  _
 *   f4ps (size 2, offset 24):	 RO	  Power state of fn. 4
 *   ipmi_en (size 1, offset 26):	 RO	  IPMI (function 4) enable
 *   f4aux (size 1, offset 27):	 RO	  Fn. 4 aux power enable shadow
 *   _anon28 (size 1, offset 28):	 RSVD	  _
 *   mngcg (size 1, offset 29):	 RO	  MNG clock gated
 *   lanfs (size 1, offset 30):	 RO	  LAN function select
 *   pmchg (size 1, offset 31):	 RO	  PM state changed
 */

static inline uint32_t __DP(factps_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(factps_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5b30));
}

static inline e1000_factps_t __DP(factps_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_factps_t __DP(factps_rd)( __DN(t) * _dev )
{
    e1000_factps_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b30));
    return u.val;
}

// Register factps is not writeable


static inline int __DP(factps_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(factps_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_factps_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b30));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register factps (Fn. active & power state to MNG):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.f0ps;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " f0ps =\t0x%"PRIx8" (Power state of fn. 0", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_fps_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.lan0v;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lan0v =\t0x%"PRIx8" (LAN 0 valid enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.f0aux;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " f0aux =\t0x%"PRIx8" (Fn. 0 aux power enable shadow", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.lan0en;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lan0en =\t0x%"PRIx8" (LAN 0 enabled", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.f1ps;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " f1ps =\t0x%"PRIx8" (Power state of fn. 1", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_fps_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.lan1v;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lan1v =\t0x%"PRIx8" (LAN 1 valid enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.f1aux;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " f1aux =\t0x%"PRIx8" (Fn. 1 aux power enable shadow", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.lan1en;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lan1en =\t0x%"PRIx8" (LAN 1 enabled", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.f2ps;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " f2ps =\t0x%"PRIx8" (Power state of fn. 2", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_fps_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ide_en;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ide_en =\t0x%"PRIx8" (IDE (function 2) enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.f2aux;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " f2aux =\t0x%"PRIx8" (Fn. 2 aux power enable shadow", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.f3ps;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " f3ps =\t0x%"PRIx8" (Power state of fn. 3", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_fps_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sp_en;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sp_en =\t0x%"PRIx8" (SP (function 3) enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.f3aux;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " f3aux =\t0x%"PRIx8" (Fn. 3 aux power enable shadow", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.f4ps;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " f4ps =\t0x%"PRIx8" (Power state of fn. 4", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_fps_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ipmi_en;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ipmi_en =\t0x%"PRIx8" (IPMI (function 4) enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.f4aux;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " f4aux =\t0x%"PRIx8" (Fn. 4 aux power enable shadow", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.mngcg;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mngcg =\t0x%"PRIx8" (MNG clock gated", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.lanfs;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lanfs =\t0x%"PRIx8" (LAN function select", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pmchg;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pmchg =\t0x%"PRIx8" (PM state changed", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register gioanactl (Analog control); type e1000.anal_ctl (Analog circuit configuration)
 */

/*
 * Dump of fields for register: gioanactl
 *   data (size 8, offset 0):	 RW	  Data to SerDes
 *   address (size 8, offset 8):	 RW	  Address to SerDes
 *   _anon16 (size 15, offset 16):	 RSVD	  _
 *   done (size 1, offset 31):	 RW	  Done indicator
 */
static const int __DP(gioanactl_length) = 0x4;
static inline uint32_t __DP(gioanactl_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(gioanactl_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x5b34) + (_i *(32/8)));
}

static inline e1000_anal_ctl_t __DP(gioanactl_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline e1000_anal_ctl_t __DP(gioanactl_rd)( __DN(t) * _dev, int _i )
{
    e1000_anal_ctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b34) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(gioanactl_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(gioanactl_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5b34) + (_i *(32/8)),val);
}

static inline void __DP(gioanactl_wr)( __DN(t) * _dev, int _i, e1000_anal_ctl_t val ) __attribute__ ((always_inline));
static inline void __DP(gioanactl_wr)( __DN(t) * _dev, int _i, e1000_anal_ctl_t val )
{
    e1000_anal_ctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b34) + (_i *(32/8)));
    u.val.data 	= val.data;
    u.val.address 	= val.address;
    u.val.done 	= val.done;
    mackerel_write_addr_32(_dev->base,(0x5b34) + (_i *(32/8)),u.raw);
}

static inline void __DP(gioanactl_data_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gioanactl_data_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    e1000_anal_ctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b34) + (_i *(32/8)));
    u.val.data = val;
    mackerel_write_addr_32(_dev->base,(0x5b34) + (_i *(32/8)),u.raw);
}

static inline void __DP(gioanactl_address_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gioanactl_address_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    e1000_anal_ctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b34) + (_i *(32/8)));
    u.val.address = val;
    mackerel_write_addr_32(_dev->base,(0x5b34) + (_i *(32/8)),u.raw);
}

static inline void __DP(gioanactl_done_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gioanactl_done_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    e1000_anal_ctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b34) + (_i *(32/8)));
    u.val.done = val;
    mackerel_write_addr_32(_dev->base,(0x5b34) + (_i *(32/8)),u.raw);
}


static inline int __DP(gioanactl_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(gioanactl_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    e1000_anal_ctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b34) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register gioanactl[%d] (Analog control):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.data;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " data =\t0x%"PRIx8" (Data to SerDes", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.address;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " address =\t0x%"PRIx8" (Address to SerDes", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.done;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " done =\t0x%"PRIx8" (Done indicator", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}
static inline int __DP(gioanactl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(gioanactl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x4; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(gioanactl_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register gioanactlall (Analog control); type e1000.anal_ctl (Analog circuit configuration)
 */

/*
 * Dump of fields for register: gioanactlall
 *   data (size 8, offset 0):	 RW	  Data to SerDes
 *   address (size 8, offset 8):	 RW	  Address to SerDes
 *   _anon16 (size 15, offset 16):	 RSVD	  _
 *   done (size 1, offset 31):	 RW	  Done indicator
 */

static inline uint32_t __DP(gioanactlall_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(gioanactlall_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5b44));
}

static inline e1000_anal_ctl_t __DP(gioanactlall_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_anal_ctl_t __DP(gioanactlall_rd)( __DN(t) * _dev )
{
    e1000_anal_ctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b44));
    return u.val;
}

static inline void __DP(gioanactlall_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(gioanactlall_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5b44),val);
}

static inline void __DP(gioanactlall_wr)( __DN(t) * _dev, e1000_anal_ctl_t val ) __attribute__ ((always_inline));
static inline void __DP(gioanactlall_wr)( __DN(t) * _dev, e1000_anal_ctl_t val )
{
    e1000_anal_ctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b44));
    u.val.data 	= val.data;
    u.val.address 	= val.address;
    u.val.done 	= val.done;
    mackerel_write_addr_32(_dev->base,(0x5b44),u.raw);
}

static inline void __DP(gioanactlall_data_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gioanactlall_data_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_anal_ctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b44));
    u.val.data = val;
    mackerel_write_addr_32(_dev->base,(0x5b44),u.raw);
}

static inline void __DP(gioanactlall_address_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gioanactlall_address_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_anal_ctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b44));
    u.val.address = val;
    mackerel_write_addr_32(_dev->base,(0x5b44),u.raw);
}

static inline void __DP(gioanactlall_done_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gioanactlall_done_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_anal_ctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b44));
    u.val.done = val;
    mackerel_write_addr_32(_dev->base,(0x5b44),u.raw);
}


static inline int __DP(gioanactlall_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(gioanactlall_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_anal_ctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b44));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register gioanactlall (Analog control):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.data;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " data =\t0x%"PRIx8" (Data to SerDes", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.address;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " address =\t0x%"PRIx8" (Address to SerDes", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.done;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " done =\t0x%"PRIx8" (Done indicator", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register ccmctl (CCM analog control); type e1000.anal_ctl (Analog circuit configuration)
 */

/*
 * Dump of fields for register: ccmctl
 *   data (size 8, offset 0):	 RW	  Data to SerDes
 *   address (size 8, offset 8):	 RW	  Address to SerDes
 *   _anon16 (size 15, offset 16):	 RSVD	  _
 *   done (size 1, offset 31):	 RW	  Done indicator
 */

static inline uint32_t __DP(ccmctl_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ccmctl_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5b48));
}

static inline e1000_anal_ctl_t __DP(ccmctl_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_anal_ctl_t __DP(ccmctl_rd)( __DN(t) * _dev )
{
    e1000_anal_ctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b48));
    return u.val;
}

static inline void __DP(ccmctl_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(ccmctl_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5b48),val);
}

static inline void __DP(ccmctl_wr)( __DN(t) * _dev, e1000_anal_ctl_t val ) __attribute__ ((always_inline));
static inline void __DP(ccmctl_wr)( __DN(t) * _dev, e1000_anal_ctl_t val )
{
    e1000_anal_ctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b48));
    u.val.data 	= val.data;
    u.val.address 	= val.address;
    u.val.done 	= val.done;
    mackerel_write_addr_32(_dev->base,(0x5b48),u.raw);
}

static inline void __DP(ccmctl_data_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ccmctl_data_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_anal_ctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b48));
    u.val.data = val;
    mackerel_write_addr_32(_dev->base,(0x5b48),u.raw);
}

static inline void __DP(ccmctl_address_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ccmctl_address_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_anal_ctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b48));
    u.val.address = val;
    mackerel_write_addr_32(_dev->base,(0x5b48),u.raw);
}

static inline void __DP(ccmctl_done_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ccmctl_done_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_anal_ctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b48));
    u.val.done = val;
    mackerel_write_addr_32(_dev->base,(0x5b48),u.raw);
}


static inline int __DP(ccmctl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ccmctl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_anal_ctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b48));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ccmctl (CCM analog control):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.data;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " data =\t0x%"PRIx8" (Data to SerDes", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.address;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " address =\t0x%"PRIx8" (Address to SerDes", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.done;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " done =\t0x%"PRIx8" (Done indicator", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register anactl (Analog control); type e1000.anactl (Implicit type of Analog control register)
 */

/*
 * Dump of fields for register: anactl
 *   data (size 8, offset 0):	 RW	  Data to/from analog register
 *   address (size 8, offset 8):	 RW	  Address of analog register
 *   _anon16 (size 14, offset 16):	 RSVD	  _
 *   write (size 1, offset 30):	 RW	  Read/write command
 *   done (size 1, offset 31):	 RW	  Done indication
 */

static inline uint32_t __DP(anactl_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(anactl_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5b48));
}

static inline e1000_anactl_t __DP(anactl_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_anactl_t __DP(anactl_rd)( __DN(t) * _dev )
{
    e1000_anactl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b48));
    return u.val;
}

static inline void __DP(anactl_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(anactl_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5b48),val);
}

static inline void __DP(anactl_wr)( __DN(t) * _dev, e1000_anactl_t val ) __attribute__ ((always_inline));
static inline void __DP(anactl_wr)( __DN(t) * _dev, e1000_anactl_t val )
{
    e1000_anactl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b48));
    u.val.data 	= val.data;
    u.val.address 	= val.address;
    u.val.write 	= val.write;
    u.val.done 	= val.done;
    mackerel_write_addr_32(_dev->base,(0x5b48),u.raw);
}

static inline void __DP(anactl_data_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(anactl_data_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_anactl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b48));
    u.val.data = val;
    mackerel_write_addr_32(_dev->base,(0x5b48),u.raw);
}

static inline void __DP(anactl_address_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(anactl_address_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_anactl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b48));
    u.val.address = val;
    mackerel_write_addr_32(_dev->base,(0x5b48),u.raw);
}

static inline void __DP(anactl_write_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(anactl_write_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_anactl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b48));
    u.val.write = val;
    mackerel_write_addr_32(_dev->base,(0x5b48),u.raw);
}

static inline void __DP(anactl_done_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(anactl_done_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_anactl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b48));
    u.val.done = val;
    mackerel_write_addr_32(_dev->base,(0x5b48),u.raw);
}


static inline int __DP(anactl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(anactl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_anactl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b48));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register anactl (Analog control):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.data;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " data =\t0x%"PRIx8" (Data to/from analog register", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.address;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " address =\t0x%"PRIx8" (Address of analog register", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.write;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " write =\t0x%"PRIx8" (Read/write command", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.done;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " done =\t0x%"PRIx8" (Done indication", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register scctl (SCC analog control); type e1000.anal_ctl (Analog circuit configuration)
 */

/*
 * Dump of fields for register: scctl
 *   data (size 8, offset 0):	 RW	  Data to SerDes
 *   address (size 8, offset 8):	 RW	  Address to SerDes
 *   _anon16 (size 15, offset 16):	 RSVD	  _
 *   done (size 1, offset 31):	 RW	  Done indicator
 */

static inline uint32_t __DP(scctl_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(scctl_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5b4c));
}

static inline e1000_anal_ctl_t __DP(scctl_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_anal_ctl_t __DP(scctl_rd)( __DN(t) * _dev )
{
    e1000_anal_ctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b4c));
    return u.val;
}

static inline void __DP(scctl_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(scctl_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5b4c),val);
}

static inline void __DP(scctl_wr)( __DN(t) * _dev, e1000_anal_ctl_t val ) __attribute__ ((always_inline));
static inline void __DP(scctl_wr)( __DN(t) * _dev, e1000_anal_ctl_t val )
{
    e1000_anal_ctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b4c));
    u.val.data 	= val.data;
    u.val.address 	= val.address;
    u.val.done 	= val.done;
    mackerel_write_addr_32(_dev->base,(0x5b4c),u.raw);
}

static inline void __DP(scctl_data_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(scctl_data_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_anal_ctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b4c));
    u.val.data = val;
    mackerel_write_addr_32(_dev->base,(0x5b4c),u.raw);
}

static inline void __DP(scctl_address_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(scctl_address_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_anal_ctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b4c));
    u.val.address = val;
    mackerel_write_addr_32(_dev->base,(0x5b4c),u.raw);
}

static inline void __DP(scctl_done_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(scctl_done_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_anal_ctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b4c));
    u.val.done = val;
    mackerel_write_addr_32(_dev->base,(0x5b4c),u.raw);
}


static inline int __DP(scctl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(scctl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_anal_ctl_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b4c));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register scctl (SCC analog control):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.data;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " data =\t0x%"PRIx8" (Data to SerDes", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.address;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " address =\t0x%"PRIx8" (Address to SerDes", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.done;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " done =\t0x%"PRIx8" (Done indicator", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register swsm (Software semaphore); type e1000.swsm (Implicit type of Software semaphore register)
 */

/*
 * Dump of fields for register: swsm
 *   smbi (size 1, offset 0):	 RW	  Semaphore bit
 *   swesmbi (size 1, offset 1):	 RW	  Software EEPROM semaphore bit
 *   wmng (size 1, offset 2):	 RW	  Wake MNG clock
 *   _anon3 (size 29, offset 3):	 RSVD	  _
 */

static inline uint32_t __DP(swsm_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(swsm_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5b50));
}

static inline e1000_swsm_t __DP(swsm_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_swsm_t __DP(swsm_rd)( __DN(t) * _dev )
{
    e1000_swsm_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b50));
    return u.val;
}

static inline void __DP(swsm_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(swsm_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5b50),val);
}

static inline void __DP(swsm_wr)( __DN(t) * _dev, e1000_swsm_t val ) __attribute__ ((always_inline));
static inline void __DP(swsm_wr)( __DN(t) * _dev, e1000_swsm_t val )
{
    e1000_swsm_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b50));
    u.val.smbi 	= val.smbi;
    u.val.swesmbi 	= val.swesmbi;
    u.val.wmng 	= val.wmng;
    mackerel_write_addr_32(_dev->base,(0x5b50),u.raw);
}

static inline void __DP(swsm_smbi_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(swsm_smbi_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_swsm_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b50));
    u.val.smbi = val;
    mackerel_write_addr_32(_dev->base,(0x5b50),u.raw);
}

static inline void __DP(swsm_swesmbi_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(swsm_swesmbi_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_swsm_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b50));
    u.val.swesmbi = val;
    mackerel_write_addr_32(_dev->base,(0x5b50),u.raw);
}

static inline void __DP(swsm_wmng_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(swsm_wmng_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_swsm_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b50));
    u.val.wmng = val;
    mackerel_write_addr_32(_dev->base,(0x5b50),u.raw);
}


static inline int __DP(swsm_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(swsm_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_swsm_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b50));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register swsm (Software semaphore):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.smbi;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " smbi =\t0x%"PRIx8" (Semaphore bit", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.swesmbi;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " swesmbi =\t0x%"PRIx8" (Software EEPROM semaphore bit", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wmng;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wmng =\t0x%"PRIx8" (Wake MNG clock", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register fwsm (Firmware semaphore); type e1000.fwsm (Implicit type of Firmware semaphore register)
 */

/*
 * Dump of fields for register: fwsm
 *   eep_fw (size 1, offset 0):	 RW	  EEPROM firmware semaphore
 *   fw_mode (size 3, offset 1):	 RW	  Firmware mode
 *   ide_on (size 1, offset 4):	 RW	  IDE redirection on
 *   sol_on (size 1, offset 5):	 RW	  SOL on
 *   eep_rl (size 1, offset 6):	 RW	  EEPROM reloaded indication
 *   _anon7 (size 8, offset 7):	 RSVD	  _
 *   fwval (size 1, offset 15):	 RW	  Firmware valid bit
 *   rstcnt (size 3, offset 16):	 RW	  Reset counter
 *   error (size 6, offset 19):	 RW	  External error indication
 *   _anon25 (size 7, offset 25):	 RSVD	  _
 */

static inline uint32_t __DP(fwsm_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(fwsm_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5b54));
}

static inline e1000_fwsm_t __DP(fwsm_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline e1000_fwsm_t __DP(fwsm_rd)( __DN(t) * _dev )
{
    e1000_fwsm_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b54));
    return u.val;
}

static inline void __DP(fwsm_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(fwsm_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5b54),val);
}

static inline void __DP(fwsm_wr)( __DN(t) * _dev, e1000_fwsm_t val ) __attribute__ ((always_inline));
static inline void __DP(fwsm_wr)( __DN(t) * _dev, e1000_fwsm_t val )
{
    e1000_fwsm_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b54));
    u.val.eep_fw 	= val.eep_fw;
    u.val.fw_mode 	= val.fw_mode;
    u.val.ide_on 	= val.ide_on;
    u.val.sol_on 	= val.sol_on;
    u.val.eep_rl 	= val.eep_rl;
    u.val.fwval 	= val.fwval;
    u.val.rstcnt 	= val.rstcnt;
    u.val.error 	= val.error;
    mackerel_write_addr_32(_dev->base,(0x5b54),u.raw);
}

static inline void __DP(fwsm_eep_fw_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fwsm_eep_fw_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_fwsm_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b54));
    u.val.eep_fw = val;
    mackerel_write_addr_32(_dev->base,(0x5b54),u.raw);
}

static inline void __DP(fwsm_fw_mode_wrf)( __DN(t) * _dev, e1000_fwmode_t val ) __attribute__ ((always_inline));
static inline void __DP(fwsm_fw_mode_wrf)( __DN(t) * _dev, e1000_fwmode_t val )
{
    e1000_fwsm_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b54));
    u.val.fw_mode = val;
    mackerel_write_addr_32(_dev->base,(0x5b54),u.raw);
}

static inline void __DP(fwsm_ide_on_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fwsm_ide_on_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_fwsm_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b54));
    u.val.ide_on = val;
    mackerel_write_addr_32(_dev->base,(0x5b54),u.raw);
}

static inline void __DP(fwsm_sol_on_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fwsm_sol_on_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_fwsm_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b54));
    u.val.sol_on = val;
    mackerel_write_addr_32(_dev->base,(0x5b54),u.raw);
}

static inline void __DP(fwsm_eep_rl_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fwsm_eep_rl_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_fwsm_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b54));
    u.val.eep_rl = val;
    mackerel_write_addr_32(_dev->base,(0x5b54),u.raw);
}

static inline void __DP(fwsm_fwval_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fwsm_fwval_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_fwsm_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b54));
    u.val.fwval = val;
    mackerel_write_addr_32(_dev->base,(0x5b54),u.raw);
}

static inline void __DP(fwsm_rstcnt_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fwsm_rstcnt_wrf)( __DN(t) * _dev, uint8_t val )
{
    e1000_fwsm_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b54));
    u.val.rstcnt = val;
    mackerel_write_addr_32(_dev->base,(0x5b54),u.raw);
}

static inline void __DP(fwsm_error_wrf)( __DN(t) * _dev, e1000_pcierr_t val ) __attribute__ ((always_inline));
static inline void __DP(fwsm_error_wrf)( __DN(t) * _dev, e1000_pcierr_t val )
{
    e1000_fwsm_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b54));
    u.val.error = val;
    mackerel_write_addr_32(_dev->base,(0x5b54),u.raw);
}


static inline int __DP(fwsm_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(fwsm_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    e1000_fwsm_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5b54));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register fwsm (Firmware semaphore):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.eep_fw;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " eep_fw =\t0x%"PRIx8" (EEPROM firmware semaphore", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.fw_mode;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fw_mode =\t0x%"PRIx8" (Firmware mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_fwmode_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ide_on;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ide_on =\t0x%"PRIx8" (IDE redirection on", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sol_on;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sol_on =\t0x%"PRIx8" (SOL on", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.eep_rl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " eep_rl =\t0x%"PRIx8" (EEPROM reloaded indication", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.fwval;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fwval =\t0x%"PRIx8" (Firmware valid bit", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rstcnt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rstcnt =\t0x%"PRIx8" (Reset counter", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.error;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " error =\t0x%"PRIx8" (External error indication", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = e1000_pcierr_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register crcerrs (CRC error count); type e1000.uint32
 */

static inline uint32_t __DP(crcerrs_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(crcerrs_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4000));
}

static inline uint32_t __DP(crcerrs_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(crcerrs_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4000));
}

// Register crcerrs is not writeable


static inline int __DP(crcerrs_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(crcerrs_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register crcerrs (CRC error count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4000)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register algnerrc (Alignment error count); type e1000.uint32
 */

static inline uint32_t __DP(algnerrc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(algnerrc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4004));
}

static inline uint32_t __DP(algnerrc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(algnerrc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4004));
}

// Register algnerrc is not writeable


static inline int __DP(algnerrc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(algnerrc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register algnerrc (Alignment error count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4004)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register symerrs (Symbol error count); type e1000.uint32
 */

static inline uint32_t __DP(symerrs_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(symerrs_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4008));
}

static inline uint32_t __DP(symerrs_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(symerrs_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4008));
}

// Register symerrs is not writeable


static inline int __DP(symerrs_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(symerrs_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register symerrs (Symbol error count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4008)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register rxerrc (Receive error count); type e1000.uint32
 */

static inline uint32_t __DP(rxerrc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rxerrc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x400c));
}

static inline uint32_t __DP(rxerrc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rxerrc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x400c));
}

// Register rxerrc is not writeable


static inline int __DP(rxerrc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rxerrc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rxerrc (Receive error count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x400c)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register mpc (Missed packets count); type e1000.uint32
 */

static inline uint32_t __DP(mpc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(mpc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4010));
}

static inline uint32_t __DP(mpc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(mpc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4010));
}

// Register mpc is not writeable


static inline int __DP(mpc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(mpc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register mpc (Missed packets count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4010)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register scc (Single collision count); type e1000.uint32
 */

static inline uint32_t __DP(scc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(scc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4014));
}

static inline uint32_t __DP(scc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(scc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4014));
}

// Register scc is not writeable


static inline int __DP(scc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(scc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register scc (Single collision count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4014)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register ecol (Excessive collisions count); type e1000.uint32
 */

static inline uint32_t __DP(ecol_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ecol_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4018));
}

static inline uint32_t __DP(ecol_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ecol_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4018));
}

// Register ecol is not writeable


static inline int __DP(ecol_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ecol_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ecol (Excessive collisions count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4018)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register mcc (Multiple collision count); type e1000.uint32
 */

static inline uint32_t __DP(mcc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(mcc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x401c));
}

static inline uint32_t __DP(mcc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(mcc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x401c));
}

// Register mcc is not writeable


static inline int __DP(mcc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(mcc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register mcc (Multiple collision count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x401c)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register latecol (Late collisions count); type e1000.uint32
 */

static inline uint32_t __DP(latecol_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(latecol_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4020));
}

static inline uint32_t __DP(latecol_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(latecol_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4020));
}

// Register latecol is not writeable


static inline int __DP(latecol_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(latecol_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register latecol (Late collisions count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4020)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register colc (Collision count); type e1000.uint32
 */

static inline uint32_t __DP(colc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(colc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4028));
}

static inline uint32_t __DP(colc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(colc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4028));
}

// Register colc is not writeable


static inline int __DP(colc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(colc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register colc (Collision count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4028)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register dc (Defer count); type e1000.uint32
 */

static inline uint32_t __DP(dc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(dc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4030));
}

static inline uint32_t __DP(dc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(dc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4030));
}

// Register dc is not writeable


static inline int __DP(dc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(dc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register dc (Defer count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4030)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register tncrs (Transmit with no CRS); type e1000.uint32
 */

static inline uint32_t __DP(tncrs_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(tncrs_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4034));
}

static inline uint32_t __DP(tncrs_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(tncrs_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4034));
}

// Register tncrs is not writeable


static inline int __DP(tncrs_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tncrs_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register tncrs (Transmit with no CRS):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4034)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register sec (Sequence error count); type e1000.uint32
 */

static inline uint32_t __DP(sec_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(sec_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4038));
}

static inline uint32_t __DP(sec_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(sec_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4038));
}

// Register sec is not writeable


static inline int __DP(sec_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(sec_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register sec (Sequence error count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4038)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register cexterr (Carrier extension error count); type e1000.uint32
 */

static inline uint32_t __DP(cexterr_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(cexterr_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x403c));
}

static inline uint32_t __DP(cexterr_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(cexterr_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x403c));
}

// Register cexterr is not writeable


static inline int __DP(cexterr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(cexterr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register cexterr (Carrier extension error count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x403c)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register rlec (Receive length error count); type e1000.uint32
 */

static inline uint32_t __DP(rlec_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rlec_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4040));
}

static inline uint32_t __DP(rlec_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rlec_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4040));
}

// Register rlec is not writeable


static inline int __DP(rlec_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rlec_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rlec (Receive length error count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4040)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register xonrxc (XON received count); type e1000.uint32
 */

static inline uint32_t __DP(xonrxc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(xonrxc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4048));
}

static inline uint32_t __DP(xonrxc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(xonrxc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4048));
}

// Register xonrxc is not writeable


static inline int __DP(xonrxc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(xonrxc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register xonrxc (XON received count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4048)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register xontxc (XON transmitted count); type e1000.uint32
 */

static inline uint32_t __DP(xontxc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(xontxc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x404c));
}

static inline uint32_t __DP(xontxc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(xontxc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x404c));
}

// Register xontxc is not writeable


static inline int __DP(xontxc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(xontxc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register xontxc (XON transmitted count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x404c)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register xoffrxc (XOFF received count); type e1000.uint32
 */

static inline uint32_t __DP(xoffrxc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(xoffrxc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4050));
}

static inline uint32_t __DP(xoffrxc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(xoffrxc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4050));
}

// Register xoffrxc is not writeable


static inline int __DP(xoffrxc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(xoffrxc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register xoffrxc (XOFF received count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4050)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register xofftxc (XOFF transmitted count); type e1000.uint32
 */

static inline uint32_t __DP(xofftxc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(xofftxc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4054));
}

static inline uint32_t __DP(xofftxc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(xofftxc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4054));
}

// Register xofftxc is not writeable


static inline int __DP(xofftxc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(xofftxc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register xofftxc (XOFF transmitted count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4054)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register fcurc (FC received unsupported count); type e1000.uint32
 */

static inline uint32_t __DP(fcurc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(fcurc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4058));
}

static inline uint32_t __DP(fcurc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(fcurc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4058));
}

// Register fcurc is not writeable


static inline int __DP(fcurc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(fcurc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register fcurc (FC received unsupported count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4058)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register prc64 (Packets received (64 bytes) count); type e1000.uint32
 */

static inline uint32_t __DP(prc64_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(prc64_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x405c));
}

static inline uint32_t __DP(prc64_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(prc64_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x405c));
}

// Register prc64 is not writeable


static inline int __DP(prc64_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(prc64_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register prc64 (Packets received (64 bytes) count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x405c)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register prc127 (Packets received (65-127 bytes) count); type e1000.uint32
 */

static inline uint32_t __DP(prc127_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(prc127_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4060));
}

static inline uint32_t __DP(prc127_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(prc127_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4060));
}

// Register prc127 is not writeable


static inline int __DP(prc127_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(prc127_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register prc127 (Packets received (65-127 bytes) count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4060)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register prc255 (Packets received (128-255 bytes) count); type e1000.uint32
 */

static inline uint32_t __DP(prc255_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(prc255_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4064));
}

static inline uint32_t __DP(prc255_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(prc255_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4064));
}

// Register prc255 is not writeable


static inline int __DP(prc255_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(prc255_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register prc255 (Packets received (128-255 bytes) count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4064)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register prc511 (Packets received (256-511 bytes) count); type e1000.uint32
 */

static inline uint32_t __DP(prc511_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(prc511_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4068));
}

static inline uint32_t __DP(prc511_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(prc511_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4068));
}

// Register prc511 is not writeable


static inline int __DP(prc511_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(prc511_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register prc511 (Packets received (256-511 bytes) count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4068)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register prc1023 (Packets received (512-1023 bytes) count); type e1000.uint32
 */

static inline uint32_t __DP(prc1023_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(prc1023_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x406c));
}

static inline uint32_t __DP(prc1023_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(prc1023_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x406c));
}

// Register prc1023 is not writeable


static inline int __DP(prc1023_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(prc1023_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register prc1023 (Packets received (512-1023 bytes) count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x406c)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register prc1522 (Packets received (1024-max bytes) count); type e1000.uint32
 */

static inline uint32_t __DP(prc1522_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(prc1522_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4070));
}

static inline uint32_t __DP(prc1522_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(prc1522_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4070));
}

// Register prc1522 is not writeable


static inline int __DP(prc1522_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(prc1522_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register prc1522 (Packets received (1024-max bytes) count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4070)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register gprc (Good packets received count); type e1000.uint32
 */

static inline uint32_t __DP(gprc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(gprc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4074));
}

static inline uint32_t __DP(gprc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(gprc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4074));
}

// Register gprc is not writeable


static inline int __DP(gprc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(gprc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register gprc (Good packets received count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4074)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register bprc (Broadcast packets received count); type e1000.uint32
 */

static inline uint32_t __DP(bprc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(bprc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4078));
}

static inline uint32_t __DP(bprc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(bprc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4078));
}

// Register bprc is not writeable


static inline int __DP(bprc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(bprc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register bprc (Broadcast packets received count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4078)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register mcprc (Multicast packets received count); type e1000.uint32
 */

static inline uint32_t __DP(mcprc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(mcprc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x407c));
}

static inline uint32_t __DP(mcprc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(mcprc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x407c));
}

// Register mcprc is not writeable


static inline int __DP(mcprc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(mcprc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register mcprc (Multicast packets received count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x407c)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register gptc (Good packets transmitted count); type e1000.uint32
 */

static inline uint32_t __DP(gptc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(gptc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4080));
}

static inline uint32_t __DP(gptc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(gptc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4080));
}

// Register gptc is not writeable


static inline int __DP(gptc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(gptc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register gptc (Good packets transmitted count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4080)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register gorcl (Good octets received count low); type e1000.uint32
 */

static inline uint32_t __DP(gorcl_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(gorcl_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4088));
}

static inline uint32_t __DP(gorcl_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(gorcl_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4088));
}

// Register gorcl is not writeable


static inline int __DP(gorcl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(gorcl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register gorcl (Good octets received count low):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4088)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register gorch (Good octets received count high); type e1000.uint32
 */

static inline uint32_t __DP(gorch_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(gorch_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x408c));
}

static inline uint32_t __DP(gorch_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(gorch_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x408c));
}

// Register gorch is not writeable


static inline int __DP(gorch_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(gorch_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register gorch (Good octets received count high):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x408c)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register gotcl (Good octets transmitted count low); type e1000.uint32
 */

static inline uint32_t __DP(gotcl_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(gotcl_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4090));
}

static inline uint32_t __DP(gotcl_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(gotcl_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4090));
}

// Register gotcl is not writeable


static inline int __DP(gotcl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(gotcl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register gotcl (Good octets transmitted count low):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4090)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register gotch (Good octets transmitted count high); type e1000.uint32
 */

static inline uint32_t __DP(gotch_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(gotch_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4094));
}

static inline uint32_t __DP(gotch_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(gotch_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4094));
}

// Register gotch is not writeable


static inline int __DP(gotch_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(gotch_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register gotch (Good octets transmitted count high):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4094)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register rnbc (Receive no buffers count); type e1000.uint32
 */

static inline uint32_t __DP(rnbc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rnbc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40a0));
}

static inline uint32_t __DP(rnbc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rnbc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40a0));
}

// Register rnbc is not writeable


static inline int __DP(rnbc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rnbc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rnbc (Receive no buffers count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x40a0)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register ruc (Receive undersize count); type e1000.uint32
 */

static inline uint32_t __DP(ruc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ruc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40a4));
}

static inline uint32_t __DP(ruc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ruc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40a4));
}

// Register ruc is not writeable


static inline int __DP(ruc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ruc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ruc (Receive undersize count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x40a4)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register rfc (Receive fragment count); type e1000.uint32
 */

static inline uint32_t __DP(rfc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rfc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40a8));
}

static inline uint32_t __DP(rfc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rfc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40a8));
}

// Register rfc is not writeable


static inline int __DP(rfc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rfc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rfc (Receive fragment count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x40a8)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register roc (Receive oversize count); type e1000.uint32
 */

static inline uint32_t __DP(roc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(roc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40ac));
}

static inline uint32_t __DP(roc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(roc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40ac));
}

// Register roc is not writeable


static inline int __DP(roc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(roc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register roc (Receive oversize count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x40ac)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register rjc (Receive jabber count); type e1000.uint32
 */

static inline uint32_t __DP(rjc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rjc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40b0));
}

static inline uint32_t __DP(rjc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rjc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40b0));
}

// Register rjc is not writeable


static inline int __DP(rjc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rjc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rjc (Receive jabber count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x40b0)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register mprc (Management packets receive count); type e1000.uint32
 */

static inline uint32_t __DP(mprc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(mprc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40b4));
}

static inline uint32_t __DP(mprc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(mprc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40b4));
}

// Register mprc is not writeable


static inline int __DP(mprc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(mprc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register mprc (Management packets receive count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x40b4)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register mpdc (Management packets dropped count); type e1000.uint32
 */

static inline uint32_t __DP(mpdc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(mpdc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40b8));
}

static inline uint32_t __DP(mpdc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(mpdc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40b8));
}

// Register mpdc is not writeable


static inline int __DP(mpdc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(mpdc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register mpdc (Management packets dropped count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x40b8)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register mptc (Management packets transmitted count); type e1000.uint32
 */

static inline uint32_t __DP(mptc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(mptc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40bc));
}

static inline uint32_t __DP(mptc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(mptc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40bc));
}

// Register mptc is not writeable


static inline int __DP(mptc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(mptc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register mptc (Management packets transmitted count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x40bc)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register torl (Total octets received low); type e1000.uint32
 */

static inline uint32_t __DP(torl_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(torl_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40c0));
}

static inline uint32_t __DP(torl_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(torl_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40c0));
}

// Register torl is not writeable


static inline int __DP(torl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(torl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register torl (Total octets received low):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x40c0)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register torh (Total octets received high); type e1000.uint32
 */

static inline uint32_t __DP(torh_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(torh_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40c4));
}

static inline uint32_t __DP(torh_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(torh_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40c4));
}

// Register torh is not writeable


static inline int __DP(torh_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(torh_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register torh (Total octets received high):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x40c4)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register totl (Total octets transmitted low); type e1000.uint32
 */

static inline uint32_t __DP(totl_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(totl_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40c8));
}

static inline uint32_t __DP(totl_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(totl_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40c8));
}

// Register totl is not writeable


static inline int __DP(totl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(totl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register totl (Total octets transmitted low):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x40c8)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register toth (Total octets transmitted high); type e1000.uint32
 */

static inline uint32_t __DP(toth_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(toth_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40cc));
}

static inline uint32_t __DP(toth_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(toth_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40cc));
}

// Register toth is not writeable


static inline int __DP(toth_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(toth_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register toth (Total octets transmitted high):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x40cc)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register tpr (Total packets received); type e1000.uint32
 */

static inline uint32_t __DP(tpr_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(tpr_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40d0));
}

static inline uint32_t __DP(tpr_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(tpr_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40d0));
}

// Register tpr is not writeable


static inline int __DP(tpr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tpr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register tpr (Total packets received):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x40d0)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register tpt (Total packets transmitted); type e1000.uint32
 */

static inline uint32_t __DP(tpt_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(tpt_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40d4));
}

static inline uint32_t __DP(tpt_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(tpt_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40d4));
}

// Register tpt is not writeable


static inline int __DP(tpt_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tpt_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register tpt (Total packets transmitted):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x40d4)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register ptc64 (Packets transmitted (64 bytes) count); type e1000.uint32
 */

static inline uint32_t __DP(ptc64_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ptc64_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40d8));
}

static inline uint32_t __DP(ptc64_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ptc64_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40d8));
}

// Register ptc64 is not writeable


static inline int __DP(ptc64_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ptc64_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ptc64 (Packets transmitted (64 bytes) count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x40d8)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register ptc127 (Packets transmitted (65-127 bytes) count); type e1000.uint32
 */

static inline uint32_t __DP(ptc127_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ptc127_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40dc));
}

static inline uint32_t __DP(ptc127_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ptc127_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40dc));
}

// Register ptc127 is not writeable


static inline int __DP(ptc127_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ptc127_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ptc127 (Packets transmitted (65-127 bytes) count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x40dc)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register ptc255 (Packets transmitted (128-255 bytes) count); type e1000.uint32
 */

static inline uint32_t __DP(ptc255_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ptc255_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40e0));
}

static inline uint32_t __DP(ptc255_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ptc255_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40e0));
}

// Register ptc255 is not writeable


static inline int __DP(ptc255_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ptc255_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ptc255 (Packets transmitted (128-255 bytes) count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x40e0)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register ptc511 (Packets transmitted (256-511 bytes) count); type e1000.uint32
 */

static inline uint32_t __DP(ptc511_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ptc511_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40e4));
}

static inline uint32_t __DP(ptc511_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ptc511_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40e4));
}

// Register ptc511 is not writeable


static inline int __DP(ptc511_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ptc511_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ptc511 (Packets transmitted (256-511 bytes) count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x40e4)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register ptc1023 (Packets transmitted (512-1023 bytes) count); type e1000.uint32
 */

static inline uint32_t __DP(ptc1023_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ptc1023_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40e8));
}

static inline uint32_t __DP(ptc1023_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ptc1023_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40e8));
}

// Register ptc1023 is not writeable


static inline int __DP(ptc1023_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ptc1023_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ptc1023 (Packets transmitted (512-1023 bytes) count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x40e8)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register ptc1522 (Packets transmitted (1024-max bytes) count); type e1000.uint32
 */

static inline uint32_t __DP(ptc1522_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ptc1522_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40ec));
}

static inline uint32_t __DP(ptc1522_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ptc1522_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40ec));
}

// Register ptc1522 is not writeable


static inline int __DP(ptc1522_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ptc1522_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ptc1522 (Packets transmitted (1024-max bytes) count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x40ec)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register mcptc (Multicast packets transmitted count); type e1000.uint32
 */

static inline uint32_t __DP(mcptc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(mcptc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40f0));
}

static inline uint32_t __DP(mcptc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(mcptc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40f0));
}

// Register mcptc is not writeable


static inline int __DP(mcptc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(mcptc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register mcptc (Multicast packets transmitted count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x40f0)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register bptc (Broadcast packets transmitted count); type e1000.uint32
 */

static inline uint32_t __DP(bptc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(bptc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40f4));
}

static inline uint32_t __DP(bptc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(bptc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40f4));
}

// Register bptc is not writeable


static inline int __DP(bptc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(bptc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register bptc (Broadcast packets transmitted count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x40f4)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register tsctc (TCP segmentation context transmitted count); type e1000.uint32
 */

static inline uint32_t __DP(tsctc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(tsctc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40f8));
}

static inline uint32_t __DP(tsctc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(tsctc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40f8));
}

// Register tsctc is not writeable


static inline int __DP(tsctc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tsctc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register tsctc (TCP segmentation context transmitted count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x40f8)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register tsctfc (TCP segmentation context tx fail count); type e1000.uint32
 */

static inline uint32_t __DP(tsctfc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(tsctfc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40fc));
}

static inline uint32_t __DP(tsctfc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(tsctfc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40fc));
}

// Register tsctfc is not writeable


static inline int __DP(tsctfc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tsctfc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register tsctfc (TCP segmentation context tx fail count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x40fc)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register iac (Interrupt assertion count); type e1000.uint32
 */

static inline uint32_t __DP(iac_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(iac_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4100));
}

static inline uint32_t __DP(iac_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(iac_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4100));
}

// Register iac is not writeable


static inline int __DP(iac_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(iac_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register iac (Interrupt assertion count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4100)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register icrxptc (Interrupt cause rx packet timer expire count); type e1000.uint32
 */

static inline uint32_t __DP(icrxptc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(icrxptc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4104));
}

static inline uint32_t __DP(icrxptc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(icrxptc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4104));
}

// Register icrxptc is not writeable


static inline int __DP(icrxptc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(icrxptc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register icrxptc (Interrupt cause rx packet timer expire count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4104)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register icrxatc (Interrupt cause rx absolute timer expire count); type e1000.uint32
 */

static inline uint32_t __DP(icrxatc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(icrxatc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4108));
}

static inline uint32_t __DP(icrxatc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(icrxatc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4108));
}

// Register icrxatc is not writeable


static inline int __DP(icrxatc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(icrxatc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register icrxatc (Interrupt cause rx absolute timer expire count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4108)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register ictxptc (Interrupt cause tx packet timer expire count); type e1000.uint32
 */

static inline uint32_t __DP(ictxptc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ictxptc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x410c));
}

static inline uint32_t __DP(ictxptc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ictxptc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x410c));
}

// Register ictxptc is not writeable


static inline int __DP(ictxptc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ictxptc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ictxptc (Interrupt cause tx packet timer expire count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x410c)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register ictxatc (Interrupt cause tx absolute timer expire count); type e1000.uint32
 */

static inline uint32_t __DP(ictxatc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ictxatc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4110));
}

static inline uint32_t __DP(ictxatc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ictxatc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4110));
}

// Register ictxatc is not writeable


static inline int __DP(ictxatc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ictxatc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ictxatc (Interrupt cause tx absolute timer expire count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4110)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register ictxqec (Interrupt cause transmit queue empty count); type e1000.uint32
 */

static inline uint32_t __DP(ictxqec_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ictxqec_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4118));
}

static inline uint32_t __DP(ictxqec_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ictxqec_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4118));
}

// Register ictxqec is not writeable


static inline int __DP(ictxqec_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ictxqec_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ictxqec (Interrupt cause transmit queue empty count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4118)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register ictxdltc (Interrupt cause transmit descriptor low threshold count); type e1000.uint32
 */

static inline uint32_t __DP(ictxdltc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ictxdltc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x411c));
}

static inline uint32_t __DP(ictxdltc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ictxdltc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x411c));
}

// Register ictxdltc is not writeable


static inline int __DP(ictxdltc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ictxdltc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ictxdltc (Interrupt cause transmit descriptor low threshold count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x411c)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register icrxdmtc (Interrupt cause receive descriptor minimum threshold count); type e1000.uint32
 */

static inline uint32_t __DP(icrxdmtc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(icrxdmtc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4120));
}

static inline uint32_t __DP(icrxdmtc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(icrxdmtc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4120));
}

// Register icrxdmtc is not writeable


static inline int __DP(icrxdmtc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(icrxdmtc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register icrxdmtc (Interrupt cause receive descriptor minimum threshold count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4120)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register icrxoc (Interrupt cause receive overrun count); type e1000.uint32
 */

static inline uint32_t __DP(icrxoc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(icrxoc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4124));
}

static inline uint32_t __DP(icrxoc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(icrxoc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4124));
}

// Register icrxoc is not writeable


static inline int __DP(icrxoc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(icrxoc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register icrxoc (Interrupt cause receive overrun count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4124)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register statsregs (All stats registers); type e1000.uint32
 */
static const int __DP(statsregs_length) = 0x4a;
static inline uint32_t __DP(statsregs_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(statsregs_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x4000) + (_i *(32/8)));
}

static inline uint32_t __DP(statsregs_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(statsregs_rd)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x4000) + (_i *(32/8)));
}

// Register statsregs is not writeable


static inline int __DP(statsregs_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(statsregs_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register statsregs[%d] (All stats registers):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4000) + (_i *(32/8))));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}
static inline int __DP(statsregs_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(statsregs_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x4a; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(statsregs_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}

static inline int __DP(pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "-------------------------\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Dump of device e1000 (Intel e1000 Gigabit Ethernet):\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ctrl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(status_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eec_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eerd_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ctrlext_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(fla_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(mdic_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(serdesctl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(fcal_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(fcah_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(fct_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(kumctrlsta_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(vet_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(mdphya_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ufuse3_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(fcttv_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(txcw_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rxcw_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ledctl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(extcnf_ctrl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(extcnf_size_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(pba_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eemngctl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(sw_fw_sync_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(icr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(itr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ics_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ims_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(imc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(iam_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rctl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ert_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(fcrtl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(fcrth_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(psrctl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rdbal_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rdbah_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rdlen_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rdh_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rdt_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rdtr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rxdctl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(radv_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rsrpd_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(raid_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(cpuvec_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rxcsum_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rfctl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tctl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tctl_ext_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tipg_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tdbal_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tdbah_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tdlen_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tdh_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tdt_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tidv_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(txdctl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tadv_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tarc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(mta_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ral_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rah_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(vfta_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(mrq_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rssim_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rssir_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(reta_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rssrk_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(wuc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(wufc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(wus_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ipav_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ip4at_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ip6at_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(wupl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(wupm_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(fflt_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ffltco_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ffmt_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ffvt_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(manc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(gcr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(gscl1_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(gscl2_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(gscl3_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(gscl4_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(gscn_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(factps_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(gioanactl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(gioanactlall_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ccmctl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(anactl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(scctl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(swsm_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(fwsm_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(crcerrs_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(algnerrc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(symerrs_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rxerrc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(mpc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(scc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ecol_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(mcc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(latecol_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(colc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(dc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tncrs_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(sec_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(cexterr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rlec_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(xonrxc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(xontxc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(xoffrxc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(xofftxc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(fcurc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(prc64_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(prc127_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(prc255_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(prc511_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(prc1023_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(prc1522_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(gprc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(bprc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(mcprc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(gptc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(gorcl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(gorch_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(gotcl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(gotch_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rnbc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ruc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rfc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(roc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rjc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(mprc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(mpdc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(mptc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(torl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(torh_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(totl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(toth_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tpr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tpt_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ptc64_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ptc127_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ptc255_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ptc511_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ptc1023_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ptc1522_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(mcptc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(bptc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tsctc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tsctfc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(iac_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(icrxptc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(icrxatc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ictxptc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ictxatc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ictxqec_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ictxdltc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(icrxdmtc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(icrxoc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(statsregs_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "End of dump of device e1000\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "-------------------------\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}

#undef __DN
#undef __DP
#undef __DP1
#undef __DP2
#undef __STR
#undef __XTR


#endif // __e1000_H
