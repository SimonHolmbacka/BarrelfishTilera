#ifndef __ehci_DEV_H
#define __ehci_DEV_H 1
/*
 * DEVICE DEFINITION: EHCI USB Controller
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) ehci ## _ ## x
/*
 * Constants defn: ehci.itc_val (Interrupt threshold control)
 *  - no width specified
 */
typedef uint8_t ehci_itc_val_t;
#define ehci_itc_val_rsvd ((ehci_itc_val_t)0x0)
#define ehci_uframe_1 ((ehci_itc_val_t)0x1)
#define ehci_uframes_2 ((ehci_itc_val_t)0x2)
#define ehci_uframes_4 ((ehci_itc_val_t)0x4)
#define ehci_uframes_8 ((ehci_itc_val_t)0x8)
#define ehci_uframes_16 ((ehci_itc_val_t)0x10)
#define ehci_uframes_32 ((ehci_itc_val_t)0x20)
#define ehci_uframes_64 ((ehci_itc_val_t)0x40)

static inline char *ehci_itc_val_describe(ehci_itc_val_t _e) __attribute__ ((always_inline));
static inline char *ehci_itc_val_describe(ehci_itc_val_t _e)
{
    switch (_e) {
    case ehci_itc_val_rsvd:
        return("itc_val_rsvd: Reserved");
    case ehci_uframe_1:
        return("uframe_1: 1 Micro frame");
    case ehci_uframes_2:
        return("uframes_2: 2 Micro frames");
    case ehci_uframes_4:
        return("uframes_4: 4 Micro frames");
    case ehci_uframes_8:
        return("uframes_8: 8 Micro frames (default, equates to 1 ms)");
    case ehci_uframes_16:
        return("uframes_16: 16 Micro frames (2 ms)");
    case ehci_uframes_32:
        return("uframes_32: 32 Micro frames (4 ms)");
    case ehci_uframes_64:
        return("uframes_64: 64 Micro frames (8 ms)");
    default:
        return(NULL);
    }
}

static inline int ehci_itc_val_prtval(char *_s, size_t _size, ehci_itc_val_t _e) __attribute__ ((always_inline));
static inline int ehci_itc_val_prtval(char *_s, size_t _size, ehci_itc_val_t _e)
{
    char *d = ehci_itc_val_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ehci_itc_val_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: ehci.frame_val (Frame list size)
 *  - no width specified
 */
typedef uint8_t ehci_frame_val_t;
#define ehci_elem_1024 ((ehci_frame_val_t)0x0)
#define ehci_elem_512 ((ehci_frame_val_t)0x1)
#define ehci_elem_256 ((ehci_frame_val_t)0x2)
#define ehci_frame_rsvd ((ehci_frame_val_t)0x3)

static inline char *ehci_frame_val_describe(ehci_frame_val_t _e) __attribute__ ((always_inline));
static inline char *ehci_frame_val_describe(ehci_frame_val_t _e)
{
    switch (_e) {
    case ehci_elem_1024:
        return("elem_1024: 1024 Elements (4096 bytes, default)");
    case ehci_elem_512:
        return("elem_512: 512 Elements (2048 bytes)");
    case ehci_elem_256:
        return("elem_256: 256 Elements (1024 bytes)");
    case ehci_frame_rsvd:
        return("frame_rsvd: Reserved");
    default:
        return(NULL);
    }
}

static inline int ehci_frame_val_prtval(char *_s, size_t _size, ehci_frame_val_t _e) __attribute__ ((always_inline));
static inline int ehci_frame_val_prtval(char *_s, size_t _size, ehci_frame_val_t _e)
{
    char *d = ehci_frame_val_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ehci_frame_val_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: ehci.test_mode_val (Test modes)
 *  - no width specified
 */
typedef uint8_t ehci_test_mode_val_t;
#define ehci_disabled ((ehci_test_mode_val_t)0x0)
#define ehci_test_j_st ((ehci_test_mode_val_t)0x1)
#define ehci_test_k_st ((ehci_test_mode_val_t)0x2)
#define ehci_se0_nak ((ehci_test_mode_val_t)0x3)
#define ehci_test_pack ((ehci_test_mode_val_t)0x4)
#define ehci_force_ena ((ehci_test_mode_val_t)0x5)

static inline char *ehci_test_mode_val_describe(ehci_test_mode_val_t _e) __attribute__ ((always_inline));
static inline char *ehci_test_mode_val_describe(ehci_test_mode_val_t _e)
{
    switch (_e) {
    case ehci_disabled:
        return("disabled: Test mode not enabled");
    case ehci_test_j_st:
        return("test_j_st: Test J_STATE");
    case ehci_test_k_st:
        return("test_k_st: Test K_STATE");
    case ehci_se0_nak:
        return("se0_nak: Test SE0_NAK");
    case ehci_test_pack:
        return("test_pack: Test packet");
    case ehci_force_ena:
        return("force_ena: Force enable");
    default:
        return(NULL);
    }
}

static inline int ehci_test_mode_val_prtval(char *_s, size_t _size, ehci_test_mode_val_t _e) __attribute__ ((always_inline));
static inline int ehci_test_mode_val_prtval(char *_s, size_t _size, ehci_test_mode_val_t _e)
{
    char *d = ehci_test_mode_val_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ehci_test_mode_val_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: ehci.indi_val (Port indicator values)
 *  - no width specified
 */
typedef uint8_t ehci_indi_val_t;
#define ehci_off ((ehci_indi_val_t)0x0)
#define ehci_amber ((ehci_indi_val_t)0x1)
#define ehci_green ((ehci_indi_val_t)0x2)
#define ehci_indi_val_undef ((ehci_indi_val_t)0x3)

static inline char *ehci_indi_val_describe(ehci_indi_val_t _e) __attribute__ ((always_inline));
static inline char *ehci_indi_val_describe(ehci_indi_val_t _e)
{
    switch (_e) {
    case ehci_off:
        return("off: Port indicators are off");
    case ehci_amber:
        return("amber: Amber");
    case ehci_green:
        return("green: Green");
    case ehci_indi_val_undef:
        return("indi_val_undef: Undefined");
    default:
        return(NULL);
    }
}

static inline int ehci_indi_val_prtval(char *_s, size_t _size, ehci_indi_val_t _e) __attribute__ ((always_inline));
static inline int ehci_indi_val_prtval(char *_s, size_t _size, ehci_indi_val_t _e)
{
    char *d = ehci_indi_val_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ehci_indi_val_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: ehci.lstatus_val (USB line status)
 *  - no width specified
 */
typedef uint8_t ehci_lstatus_val_t;
#define ehci_se0 ((ehci_lstatus_val_t)0x0)
#define ehci_j_state ((ehci_lstatus_val_t)0x2)
#define ehci_k_state ((ehci_lstatus_val_t)0x1)
#define ehci_lstatus_undef ((ehci_lstatus_val_t)0x3)

static inline char *ehci_lstatus_val_describe(ehci_lstatus_val_t _e) __attribute__ ((always_inline));
static inline char *ehci_lstatus_val_describe(ehci_lstatus_val_t _e)
{
    switch (_e) {
    case ehci_se0:
        return("se0: Not low speed device, perform EHCI reset");
    case ehci_j_state:
        return("j_state: Not low speed device, perform EHCI reset");
    case ehci_k_state:
        return("k_state: Low speed device, release ownership of port");
    case ehci_lstatus_undef:
        return("lstatus_undef: Not low speed device, perform EHCI reset");
    default:
        return(NULL);
    }
}

static inline int ehci_lstatus_val_prtval(char *_s, size_t _size, ehci_lstatus_val_t _e) __attribute__ ((always_inline));
static inline int ehci_lstatus_val_prtval(char *_s, size_t _size, ehci_lstatus_val_t _e)
{
    char *d = ehci_lstatus_val_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ehci_lstatus_val_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: ehci.lptype (Link pointer type)
 *  - width 2 bits
 */
typedef uint8_t ehci_lptype_t;
#define ehci_lp_itd ((ehci_lptype_t)0x0)
#define ehci_lp_qh ((ehci_lptype_t)0x1)
#define ehci_lp_sitd ((ehci_lptype_t)0x2)
#define ehci_lp_fstn ((ehci_lptype_t)0x3)

static inline char *ehci_lptype_describe(ehci_lptype_t _e) __attribute__ ((always_inline));
static inline char *ehci_lptype_describe(ehci_lptype_t _e)
{
    switch (_e) {
    case ehci_lp_itd:
        return("lp_itd: Isochronous transfer descriptor");
    case ehci_lp_qh:
        return("lp_qh: Queue head");
    case ehci_lp_sitd:
        return("lp_sitd: Split transaction isochronous trans. desc.");
    case ehci_lp_fstn:
        return("lp_fstn: Frame span traversal node");
    default:
        return(NULL);
    }
}

static inline int ehci_lptype_prtval(char *_s, size_t _size, ehci_lptype_t _e) __attribute__ ((always_inline));
static inline int ehci_lptype_prtval(char *_s, size_t _size, ehci_lptype_t _e)
{
    char *d = ehci_lptype_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ehci_lptype_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: ehci.xpos (Transaction position)
 *  - width 2 bits
 */
typedef uint8_t ehci_xpos_t;
#define ehci_tp_all ((ehci_xpos_t)0x0)
#define ehci_tp_begin ((ehci_xpos_t)0x1)
#define ehci_tp_mid ((ehci_xpos_t)0x2)
#define ehci_tp_end ((ehci_xpos_t)0x3)

static inline char *ehci_xpos_describe(ehci_xpos_t _e) __attribute__ ((always_inline));
static inline char *ehci_xpos_describe(ehci_xpos_t _e)
{
    switch (_e) {
    case ehci_tp_all:
        return("tp_all: Entire payload");
    case ehci_tp_begin:
        return("tp_begin: First data payload");
    case ehci_tp_mid:
        return("tp_mid: Middle payload");
    case ehci_tp_end:
        return("tp_end: Final payload");
    default:
        return(NULL);
    }
}

static inline int ehci_xpos_prtval(char *_s, size_t _size, ehci_xpos_t _e) __attribute__ ((always_inline));
static inline int ehci_xpos_prtval(char *_s, size_t _size, ehci_xpos_t _e)
{
    char *d = ehci_xpos_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ehci_xpos_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: ehci.pid (PID token encoding)
 *  - no width specified
 */
typedef uint8_t ehci_pid_t;
#define ehci_pid_out ((ehci_pid_t)0x0)
#define ehci_pid_in ((ehci_pid_t)0x1)
#define ehci_pid_setup ((ehci_pid_t)0x2)
#define ehci_pid_rsvd ((ehci_pid_t)0x3)

static inline char *ehci_pid_describe(ehci_pid_t _e) __attribute__ ((always_inline));
static inline char *ehci_pid_describe(ehci_pid_t _e)
{
    switch (_e) {
    case ehci_pid_out:
        return("pid_out: Generates OUT token (E1H)");
    case ehci_pid_in:
        return("pid_in: Generates IN token (69H)");
    case ehci_pid_setup:
        return("pid_setup: Generates SETUP token (2DH)");
    case ehci_pid_rsvd:
        return("pid_rsvd: Reserved");
    default:
        return(NULL);
    }
}

static inline int ehci_pid_prtval(char *_s, size_t _size, ehci_pid_t _e) __attribute__ ((always_inline));
static inline int ehci_pid_prtval(char *_s, size_t _size, ehci_pid_t _e)
{
    char *d = ehci_pid_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ehci_pid_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: ehci.speed (Endpoint speed)
 *  - width 2 bits
 */
typedef uint8_t ehci_speed_t;
#define ehci_fullspeed ((ehci_speed_t)0x0)
#define ehci_lowspeed ((ehci_speed_t)0x1)
#define ehci_highspeed ((ehci_speed_t)0x2)

static inline char *ehci_speed_describe(ehci_speed_t _e) __attribute__ ((always_inline));
static inline char *ehci_speed_describe(ehci_speed_t _e)
{
    switch (_e) {
    case ehci_fullspeed:
        return("fullspeed: Full-speed (12Mbs)");
    case ehci_lowspeed:
        return("lowspeed: Low-speed (1.5Mbs)");
    case ehci_highspeed:
        return("highspeed: High-speed (480 Mb/s)");
    default:
        return(NULL);
    }
}

static inline int ehci_speed_prtval(char *_s, size_t _size, ehci_speed_t _e) __attribute__ ((always_inline));
static inline int ehci_speed_prtval(char *_s, size_t _size, ehci_speed_t _e)
{
    char *d = ehci_speed_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ehci_speed_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: ehci_hcs_params_t
 * Description: Implicit type of Structural parameters register
 * Fields:
 *   n_ports	(size 4, offset 0, init 0):	RO	Num. physical downstream ports on this controller
 *   ppc	(size 1, offset 4, init 0):	RO	Port power control
 *   _anon5	(size 2, offset 5, init 0):	RSVD	_
 *   prr	(size 1, offset 7, init 0):	RO	Port routing rules
 *   n_pcc	(size 4, offset 8, init 0):	RO	Number of ports per companion controller
 *   n_cc	(size 4, offset 12, init 0):	RO	Number of campanion controller
 *   pi	(size 1, offset 16, init 0):	RO	Port indicator
 *   _anon17	(size 3, offset 17, init 0):	RSVD	_
 *   dpn	(size 4, offset 20, init 0):	RO	Debug port number
 *   _anon24	(size 8, offset 24, init 0):	RSVD	_
 */
typedef uint32_t ehci_hcs_params_t;
#define ehci_hcs_params_default 0x0
static inline uint8_t ehci_hcs_params_n_ports_extract(ehci_hcs_params_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_hcs_params_n_ports_extract(ehci_hcs_params_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline ehci_hcs_params_t ehci_hcs_params_n_ports_insert(ehci_hcs_params_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hcs_params_t ehci_hcs_params_n_ports_insert(ehci_hcs_params_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((ehci_hcs_params_t )(_fieldval)) << 0)));
}

static inline uint8_t ehci_hcs_params_ppc_extract(ehci_hcs_params_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_hcs_params_ppc_extract(ehci_hcs_params_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline ehci_hcs_params_t ehci_hcs_params_ppc_insert(ehci_hcs_params_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hcs_params_t ehci_hcs_params_ppc_insert(ehci_hcs_params_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((ehci_hcs_params_t )(_fieldval)) << 4)));
}

static inline uint8_t ehci_hcs_params_prr_extract(ehci_hcs_params_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_hcs_params_prr_extract(ehci_hcs_params_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline ehci_hcs_params_t ehci_hcs_params_prr_insert(ehci_hcs_params_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hcs_params_t ehci_hcs_params_prr_insert(ehci_hcs_params_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((ehci_hcs_params_t )(_fieldval)) << 7)));
}

static inline uint8_t ehci_hcs_params_n_pcc_extract(ehci_hcs_params_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_hcs_params_n_pcc_extract(ehci_hcs_params_t _regval)
{
    return((uint8_t )((_regval & 0xf00) >> 8));
}

static inline ehci_hcs_params_t ehci_hcs_params_n_pcc_insert(ehci_hcs_params_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hcs_params_t ehci_hcs_params_n_pcc_insert(ehci_hcs_params_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff0ff) | (0xf00 & (((ehci_hcs_params_t )(_fieldval)) << 8)));
}

static inline uint8_t ehci_hcs_params_n_cc_extract(ehci_hcs_params_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_hcs_params_n_cc_extract(ehci_hcs_params_t _regval)
{
    return((uint8_t )((_regval & 0xf000) >> 12));
}

static inline ehci_hcs_params_t ehci_hcs_params_n_cc_insert(ehci_hcs_params_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hcs_params_t ehci_hcs_params_n_cc_insert(ehci_hcs_params_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff0fff) | (0xf000 & (((ehci_hcs_params_t )(_fieldval)) << 12)));
}

static inline uint8_t ehci_hcs_params_pi_extract(ehci_hcs_params_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_hcs_params_pi_extract(ehci_hcs_params_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline ehci_hcs_params_t ehci_hcs_params_pi_insert(ehci_hcs_params_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hcs_params_t ehci_hcs_params_pi_insert(ehci_hcs_params_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((ehci_hcs_params_t )(_fieldval)) << 16)));
}

static inline uint8_t ehci_hcs_params_dpn_extract(ehci_hcs_params_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_hcs_params_dpn_extract(ehci_hcs_params_t _regval)
{
    return((uint8_t )((_regval & 0xf00000) >> 20));
}

static inline ehci_hcs_params_t ehci_hcs_params_dpn_insert(ehci_hcs_params_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hcs_params_t ehci_hcs_params_dpn_insert(ehci_hcs_params_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff0fffff) | (0xf00000 & (((ehci_hcs_params_t )(_fieldval)) << 20)));
}

static inline int ehci_hcs_params_prtval(char *_s, size_t _size, ehci_hcs_params_t _regval) __attribute__ ((always_inline));
static inline int ehci_hcs_params_prtval(char *_s, size_t _size, ehci_hcs_params_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " n_ports =\t%" PRIx8 "\t(Num. physical downstream ports on this controller)\n", ehci_hcs_params_n_ports_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ppc =\t%" PRIx8 "\t(Port power control)\n", ehci_hcs_params_ppc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prr =\t%" PRIx8 "\t(Port routing rules)\n", ehci_hcs_params_prr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " n_pcc =\t%" PRIx8 "\t(Number of ports per companion controller)\n", ehci_hcs_params_n_pcc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " n_cc =\t%" PRIx8 "\t(Number of campanion controller)\n", ehci_hcs_params_n_cc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pi =\t%" PRIx8 "\t(Port indicator)\n", ehci_hcs_params_pi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpn =\t%" PRIx8 "\t(Debug port number)\n", ehci_hcs_params_dpn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ehci_hccparams_t
 * Description: Implicit type of Capability parameters register
 * Fields:
 *   ex_ac	(size 1, offset 0, init 0):	RO	Extended 64 bit addressing capability
 *   pflf	(size 1, offset 1, init 0):	RO	Programmable frame list flag
 *   aspc	(size 1, offset 2, init 0):	RO	Asynchronous sechedule park capability
 *   _anon3	(size 1, offset 3, init 0):	RSVD	_
 *   ist	(size 4, offset 4, init 0):	RO	Isochronous scheduling threshold
 *   eecp	(size 8, offset 8, init 0):	RO	EHCI extended capabilities pointer
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t ehci_hccparams_t;
#define ehci_hccparams_default 0x0
static inline uint8_t ehci_hccparams_ex_ac_extract(ehci_hccparams_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_hccparams_ex_ac_extract(ehci_hccparams_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ehci_hccparams_t ehci_hccparams_ex_ac_insert(ehci_hccparams_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hccparams_t ehci_hccparams_ex_ac_insert(ehci_hccparams_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ehci_hccparams_t )(_fieldval)) << 0)));
}

static inline uint8_t ehci_hccparams_pflf_extract(ehci_hccparams_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_hccparams_pflf_extract(ehci_hccparams_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ehci_hccparams_t ehci_hccparams_pflf_insert(ehci_hccparams_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hccparams_t ehci_hccparams_pflf_insert(ehci_hccparams_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((ehci_hccparams_t )(_fieldval)) << 1)));
}

static inline uint8_t ehci_hccparams_aspc_extract(ehci_hccparams_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_hccparams_aspc_extract(ehci_hccparams_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ehci_hccparams_t ehci_hccparams_aspc_insert(ehci_hccparams_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hccparams_t ehci_hccparams_aspc_insert(ehci_hccparams_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((ehci_hccparams_t )(_fieldval)) << 2)));
}

static inline uint8_t ehci_hccparams_ist_extract(ehci_hccparams_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_hccparams_ist_extract(ehci_hccparams_t _regval)
{
    return((uint8_t )((_regval & 0xf0) >> 4));
}

static inline ehci_hccparams_t ehci_hccparams_ist_insert(ehci_hccparams_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hccparams_t ehci_hccparams_ist_insert(ehci_hccparams_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff0f) | (0xf0 & (((ehci_hccparams_t )(_fieldval)) << 4)));
}

static inline uint8_t ehci_hccparams_eecp_extract(ehci_hccparams_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_hccparams_eecp_extract(ehci_hccparams_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline ehci_hccparams_t ehci_hccparams_eecp_insert(ehci_hccparams_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hccparams_t ehci_hccparams_eecp_insert(ehci_hccparams_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((ehci_hccparams_t )(_fieldval)) << 8)));
}

static inline int ehci_hccparams_prtval(char *_s, size_t _size, ehci_hccparams_t _regval) __attribute__ ((always_inline));
static inline int ehci_hccparams_prtval(char *_s, size_t _size, ehci_hccparams_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ex_ac =\t%" PRIx8 "\t(Extended 64 bit addressing capability)\n", ehci_hccparams_ex_ac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pflf =\t%" PRIx8 "\t(Programmable frame list flag)\n", ehci_hccparams_pflf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aspc =\t%" PRIx8 "\t(Asynchronous sechedule park capability)\n", ehci_hccparams_aspc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ist =\t%" PRIx8 "\t(Isochronous scheduling threshold)\n", ehci_hccparams_ist_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eecp =\t%" PRIx8 "\t(EHCI extended capabilities pointer)\n", ehci_hccparams_eecp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ehci_hcspportroute_t
 * Description: Implicit type of Companion port route descr. register
 * Fields:
 *   _anon0	(size 4, offset 0, init 0):	RSVD	_
 *   attr	(size 60, offset 4, init 0):	RO	Port array
 */
typedef uint64_t ehci_hcspportroute_t;
#define ehci_hcspportroute_default 0x0
static inline uint64_t ehci_hcspportroute_attr_extract(ehci_hcspportroute_t _regval) __attribute__ ((always_inline));
static inline uint64_t ehci_hcspportroute_attr_extract(ehci_hcspportroute_t _regval)
{
    return((uint64_t )((_regval & 0xfffffffffffffff0) >> 4));
}

static inline ehci_hcspportroute_t ehci_hcspportroute_attr_insert(ehci_hcspportroute_t _regval, uint64_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hcspportroute_t ehci_hcspportroute_attr_insert(ehci_hcspportroute_t _regval, uint64_t _fieldval)
{
    return((_regval & 0xf) | (0xfffffffffffffff0 & (((ehci_hcspportroute_t )(_fieldval)) << 4)));
}

static inline int ehci_hcspportroute_prtval(char *_s, size_t _size, ehci_hcspportroute_t _regval) __attribute__ ((always_inline));
static inline int ehci_hcspportroute_prtval(char *_s, size_t _size, ehci_hcspportroute_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " attr =\t%" PRIx64 "\t(Port array)\n", ehci_hcspportroute_attr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ehci_usb_cmd_t
 * Description: Implicit type of USB command register
 * Fields:
 *   rs	(size 1, offset 0, init 0):	RW	Run stop for scheduling
 *   hcr	(size 1, offset 1, init 0):	RW	Host controller reset
 *   fl_sz	(size 2, offset 2, init 0):	RW	Frame list size
 *   ps_e	(size 1, offset 4, init 0):	RW	Periodic schedule enable
 *   as_e	(size 1, offset 5, init 0):	RW	Asynchronous schedule enable
 *   iaad	(size 1, offset 6, init 0):	RW	Interrupt on async advance doorbell
 *   lhcr	(size 1, offset 7, init 0):	RW	Light host controller reset
 *   aspm_c	(size 2, offset 8, init 0):	RW	Asynchronous schedule park mode count
 *   _anon10	(size 1, offset 10, init 0):	MBZ	_
 *   aspm_e	(size 1, offset 11, init 0):	RW	Asynchronous schedule park mode enable
 *   _anon12	(size 4, offset 12, init 0):	MBZ	_
 *   itc	(size 8, offset 16, init 0):	RW	Interrupt threshold control
 *   _anon24	(size 8, offset 24, init 0):	MBZ	_
 */
typedef uint32_t ehci_usb_cmd_t;
#define ehci_usb_cmd_default 0x0
static inline uint8_t ehci_usb_cmd_rs_extract(ehci_usb_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_cmd_rs_extract(ehci_usb_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ehci_usb_cmd_t ehci_usb_cmd_rs_insert(ehci_usb_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_cmd_t ehci_usb_cmd_rs_insert(ehci_usb_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ehci_usb_cmd_t )(_fieldval)) << 0)));
}

static inline uint8_t ehci_usb_cmd_hcr_extract(ehci_usb_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_cmd_hcr_extract(ehci_usb_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ehci_usb_cmd_t ehci_usb_cmd_hcr_insert(ehci_usb_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_cmd_t ehci_usb_cmd_hcr_insert(ehci_usb_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((ehci_usb_cmd_t )(_fieldval)) << 1)));
}

static inline ehci_frame_val_t ehci_usb_cmd_fl_sz_extract(ehci_usb_cmd_t _regval) __attribute__ ((always_inline));
static inline ehci_frame_val_t ehci_usb_cmd_fl_sz_extract(ehci_usb_cmd_t _regval)
{
    return((ehci_frame_val_t )((_regval & 0xc) >> 2));
}

static inline ehci_usb_cmd_t ehci_usb_cmd_fl_sz_insert(ehci_usb_cmd_t _regval, ehci_frame_val_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_cmd_t ehci_usb_cmd_fl_sz_insert(ehci_usb_cmd_t _regval, ehci_frame_val_t _fieldval)
{
    return((_regval & 0xfffffff3) | (0xc & (((ehci_usb_cmd_t )(_fieldval)) << 2)));
}

static inline uint8_t ehci_usb_cmd_ps_e_extract(ehci_usb_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_cmd_ps_e_extract(ehci_usb_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline ehci_usb_cmd_t ehci_usb_cmd_ps_e_insert(ehci_usb_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_cmd_t ehci_usb_cmd_ps_e_insert(ehci_usb_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((ehci_usb_cmd_t )(_fieldval)) << 4)));
}

static inline uint8_t ehci_usb_cmd_as_e_extract(ehci_usb_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_cmd_as_e_extract(ehci_usb_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline ehci_usb_cmd_t ehci_usb_cmd_as_e_insert(ehci_usb_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_cmd_t ehci_usb_cmd_as_e_insert(ehci_usb_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((ehci_usb_cmd_t )(_fieldval)) << 5)));
}

static inline uint8_t ehci_usb_cmd_iaad_extract(ehci_usb_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_cmd_iaad_extract(ehci_usb_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline ehci_usb_cmd_t ehci_usb_cmd_iaad_insert(ehci_usb_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_cmd_t ehci_usb_cmd_iaad_insert(ehci_usb_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((ehci_usb_cmd_t )(_fieldval)) << 6)));
}

static inline uint8_t ehci_usb_cmd_lhcr_extract(ehci_usb_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_cmd_lhcr_extract(ehci_usb_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline ehci_usb_cmd_t ehci_usb_cmd_lhcr_insert(ehci_usb_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_cmd_t ehci_usb_cmd_lhcr_insert(ehci_usb_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((ehci_usb_cmd_t )(_fieldval)) << 7)));
}

static inline uint8_t ehci_usb_cmd_aspm_c_extract(ehci_usb_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_cmd_aspm_c_extract(ehci_usb_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x300) >> 8));
}

static inline ehci_usb_cmd_t ehci_usb_cmd_aspm_c_insert(ehci_usb_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_cmd_t ehci_usb_cmd_aspm_c_insert(ehci_usb_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffcff) | (0x300 & (((ehci_usb_cmd_t )(_fieldval)) << 8)));
}

static inline uint8_t ehci_usb_cmd_aspm_e_extract(ehci_usb_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_cmd_aspm_e_extract(ehci_usb_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline ehci_usb_cmd_t ehci_usb_cmd_aspm_e_insert(ehci_usb_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_cmd_t ehci_usb_cmd_aspm_e_insert(ehci_usb_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((ehci_usb_cmd_t )(_fieldval)) << 11)));
}

static inline ehci_itc_val_t ehci_usb_cmd_itc_extract(ehci_usb_cmd_t _regval) __attribute__ ((always_inline));
static inline ehci_itc_val_t ehci_usb_cmd_itc_extract(ehci_usb_cmd_t _regval)
{
    return((ehci_itc_val_t )((_regval & 0xff0000) >> 16));
}

static inline ehci_usb_cmd_t ehci_usb_cmd_itc_insert(ehci_usb_cmd_t _regval, ehci_itc_val_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_cmd_t ehci_usb_cmd_itc_insert(ehci_usb_cmd_t _regval, ehci_itc_val_t _fieldval)
{
    return((_regval & 0xff00ffff) | (0xff0000 & (((ehci_usb_cmd_t )(_fieldval)) << 16)));
}

static inline int ehci_usb_cmd_prtval(char *_s, size_t _size, ehci_usb_cmd_t _regval) __attribute__ ((always_inline));
static inline int ehci_usb_cmd_prtval(char *_s, size_t _size, ehci_usb_cmd_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rs =\t%" PRIx8 "\t(Run stop for scheduling)\n", ehci_usb_cmd_rs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hcr =\t%" PRIx8 "\t(Host controller reset)\n", ehci_usb_cmd_hcr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_sz =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_frame_val_prtval(_s + _r, _avail, ehci_usb_cmd_fl_sz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Frame list size)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ps_e =\t%" PRIx8 "\t(Periodic schedule enable)\n", ehci_usb_cmd_ps_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " as_e =\t%" PRIx8 "\t(Asynchronous schedule enable)\n", ehci_usb_cmd_as_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iaad =\t%" PRIx8 "\t(Interrupt on async advance doorbell)\n", ehci_usb_cmd_iaad_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lhcr =\t%" PRIx8 "\t(Light host controller reset)\n", ehci_usb_cmd_lhcr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aspm_c =\t%" PRIx8 "\t(Asynchronous schedule park mode count)\n", ehci_usb_cmd_aspm_c_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aspm_e =\t%" PRIx8 "\t(Asynchronous schedule park mode enable)\n", ehci_usb_cmd_aspm_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " itc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_itc_val_prtval(_s + _r, _avail, ehci_usb_cmd_itc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Interrupt threshold control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ehci_usb_status_t
 * Description: Implicit type of USB status register
 * Fields:
 *   usb_i	(size 1, offset 0, init 0):	RWC	USB interrupt
 *   usb_ei	(size 1, offset 1, init 0):	RWC	USB error interrupt
 *   pcd	(size 1, offset 2, init 0):	RWC	Port change detect
 *   flr	(size 1, offset 3, init 0):	RWC	Frame list rollover
 *   hs_err	(size 1, offset 4, init 0):	RWC	Host system error
 *   i_aa	(size 1, offset 5, init 0):	RWC	Interrupt on Async advance
 *   _anon6	(size 6, offset 6, init 0):	MBZ	_
 *   hc_halt	(size 1, offset 12, init 0):	RO	Host controller halted see Run/Stop
 *   rec	(size 1, offset 13, init 0):	RO	Reclamation
 *   ps_s	(size 1, offset 14, init 0):	RO	Periodic schedule status
 *   as_s	(size 1, offset 15, init 0):	RO	Asynchronous schedule status
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
typedef uint32_t ehci_usb_status_t;
#define ehci_usb_status_default 0x0
static inline uint8_t ehci_usb_status_usb_i_extract(ehci_usb_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_status_usb_i_extract(ehci_usb_status_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ehci_usb_status_t ehci_usb_status_usb_i_insert(ehci_usb_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_status_t ehci_usb_status_usb_i_insert(ehci_usb_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ehci_usb_status_t )(_fieldval)) << 0)));
}

static inline uint8_t ehci_usb_status_usb_ei_extract(ehci_usb_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_status_usb_ei_extract(ehci_usb_status_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ehci_usb_status_t ehci_usb_status_usb_ei_insert(ehci_usb_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_status_t ehci_usb_status_usb_ei_insert(ehci_usb_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((ehci_usb_status_t )(_fieldval)) << 1)));
}

static inline uint8_t ehci_usb_status_pcd_extract(ehci_usb_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_status_pcd_extract(ehci_usb_status_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ehci_usb_status_t ehci_usb_status_pcd_insert(ehci_usb_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_status_t ehci_usb_status_pcd_insert(ehci_usb_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((ehci_usb_status_t )(_fieldval)) << 2)));
}

static inline uint8_t ehci_usb_status_flr_extract(ehci_usb_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_status_flr_extract(ehci_usb_status_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline ehci_usb_status_t ehci_usb_status_flr_insert(ehci_usb_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_status_t ehci_usb_status_flr_insert(ehci_usb_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((ehci_usb_status_t )(_fieldval)) << 3)));
}

static inline uint8_t ehci_usb_status_hs_err_extract(ehci_usb_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_status_hs_err_extract(ehci_usb_status_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline ehci_usb_status_t ehci_usb_status_hs_err_insert(ehci_usb_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_status_t ehci_usb_status_hs_err_insert(ehci_usb_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((ehci_usb_status_t )(_fieldval)) << 4)));
}

static inline uint8_t ehci_usb_status_i_aa_extract(ehci_usb_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_status_i_aa_extract(ehci_usb_status_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline ehci_usb_status_t ehci_usb_status_i_aa_insert(ehci_usb_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_status_t ehci_usb_status_i_aa_insert(ehci_usb_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((ehci_usb_status_t )(_fieldval)) << 5)));
}

static inline uint8_t ehci_usb_status_hc_halt_extract(ehci_usb_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_status_hc_halt_extract(ehci_usb_status_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline ehci_usb_status_t ehci_usb_status_hc_halt_insert(ehci_usb_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_status_t ehci_usb_status_hc_halt_insert(ehci_usb_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((ehci_usb_status_t )(_fieldval)) << 12)));
}

static inline uint8_t ehci_usb_status_rec_extract(ehci_usb_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_status_rec_extract(ehci_usb_status_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline ehci_usb_status_t ehci_usb_status_rec_insert(ehci_usb_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_status_t ehci_usb_status_rec_insert(ehci_usb_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((ehci_usb_status_t )(_fieldval)) << 13)));
}

static inline uint8_t ehci_usb_status_ps_s_extract(ehci_usb_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_status_ps_s_extract(ehci_usb_status_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline ehci_usb_status_t ehci_usb_status_ps_s_insert(ehci_usb_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_status_t ehci_usb_status_ps_s_insert(ehci_usb_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((ehci_usb_status_t )(_fieldval)) << 14)));
}

static inline uint8_t ehci_usb_status_as_s_extract(ehci_usb_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_status_as_s_extract(ehci_usb_status_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline ehci_usb_status_t ehci_usb_status_as_s_insert(ehci_usb_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_status_t ehci_usb_status_as_s_insert(ehci_usb_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((ehci_usb_status_t )(_fieldval)) << 15)));
}

static inline int ehci_usb_status_prtval(char *_s, size_t _size, ehci_usb_status_t _regval) __attribute__ ((always_inline));
static inline int ehci_usb_status_prtval(char *_s, size_t _size, ehci_usb_status_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usb_i =\t%" PRIx8 "\t(USB interrupt)\n", ehci_usb_status_usb_i_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usb_ei =\t%" PRIx8 "\t(USB error interrupt)\n", ehci_usb_status_usb_ei_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcd =\t%" PRIx8 "\t(Port change detect)\n", ehci_usb_status_pcd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flr =\t%" PRIx8 "\t(Frame list rollover)\n", ehci_usb_status_flr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hs_err =\t%" PRIx8 "\t(Host system error)\n", ehci_usb_status_hs_err_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_aa =\t%" PRIx8 "\t(Interrupt on Async advance)\n", ehci_usb_status_i_aa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hc_halt =\t%" PRIx8 "\t(Host controller halted see Run/Stop)\n", ehci_usb_status_hc_halt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rec =\t%" PRIx8 "\t(Reclamation)\n", ehci_usb_status_rec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ps_s =\t%" PRIx8 "\t(Periodic schedule status)\n", ehci_usb_status_ps_s_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " as_s =\t%" PRIx8 "\t(Asynchronous schedule status)\n", ehci_usb_status_as_s_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ehci_usb_int_t
 * Description: Implicit type of USB interrupt enable register
 * Fields:
 *   usbi_e	(size 1, offset 0, init 0):	RW	USB interrupt enable
 *   usbei_e	(size 1, offset 1, init 0):	RW	USB error interrupt enable
 *   pci_e	(size 1, offset 2, init 0):	RW	Port change interrupt enable
 *   flr_e	(size 1, offset 3, init 0):	RW	Frame list rollover enable
 *   hye_e	(size 1, offset 4, init 0):	RW	Host system error enable
 *   iaa_e	(size 1, offset 5, init 0):	RW	Interrupt on async advance enable
 *   _anon6	(size 26, offset 6, init 0):	MBZ	_
 */
typedef uint32_t ehci_usb_int_t;
#define ehci_usb_int_default 0x0
static inline uint8_t ehci_usb_int_usbi_e_extract(ehci_usb_int_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_int_usbi_e_extract(ehci_usb_int_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ehci_usb_int_t ehci_usb_int_usbi_e_insert(ehci_usb_int_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_int_t ehci_usb_int_usbi_e_insert(ehci_usb_int_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ehci_usb_int_t )(_fieldval)) << 0)));
}

static inline uint8_t ehci_usb_int_usbei_e_extract(ehci_usb_int_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_int_usbei_e_extract(ehci_usb_int_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ehci_usb_int_t ehci_usb_int_usbei_e_insert(ehci_usb_int_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_int_t ehci_usb_int_usbei_e_insert(ehci_usb_int_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((ehci_usb_int_t )(_fieldval)) << 1)));
}

static inline uint8_t ehci_usb_int_pci_e_extract(ehci_usb_int_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_int_pci_e_extract(ehci_usb_int_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ehci_usb_int_t ehci_usb_int_pci_e_insert(ehci_usb_int_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_int_t ehci_usb_int_pci_e_insert(ehci_usb_int_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((ehci_usb_int_t )(_fieldval)) << 2)));
}

static inline uint8_t ehci_usb_int_flr_e_extract(ehci_usb_int_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_int_flr_e_extract(ehci_usb_int_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline ehci_usb_int_t ehci_usb_int_flr_e_insert(ehci_usb_int_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_int_t ehci_usb_int_flr_e_insert(ehci_usb_int_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((ehci_usb_int_t )(_fieldval)) << 3)));
}

static inline uint8_t ehci_usb_int_hye_e_extract(ehci_usb_int_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_int_hye_e_extract(ehci_usb_int_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline ehci_usb_int_t ehci_usb_int_hye_e_insert(ehci_usb_int_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_int_t ehci_usb_int_hye_e_insert(ehci_usb_int_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((ehci_usb_int_t )(_fieldval)) << 4)));
}

static inline uint8_t ehci_usb_int_iaa_e_extract(ehci_usb_int_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_int_iaa_e_extract(ehci_usb_int_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline ehci_usb_int_t ehci_usb_int_iaa_e_insert(ehci_usb_int_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usb_int_t ehci_usb_int_iaa_e_insert(ehci_usb_int_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((ehci_usb_int_t )(_fieldval)) << 5)));
}

static inline int ehci_usb_int_prtval(char *_s, size_t _size, ehci_usb_int_t _regval) __attribute__ ((always_inline));
static inline int ehci_usb_int_prtval(char *_s, size_t _size, ehci_usb_int_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usbi_e =\t%" PRIx8 "\t(USB interrupt enable)\n", ehci_usb_int_usbi_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usbei_e =\t%" PRIx8 "\t(USB error interrupt enable)\n", ehci_usb_int_usbei_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pci_e =\t%" PRIx8 "\t(Port change interrupt enable)\n", ehci_usb_int_pci_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flr_e =\t%" PRIx8 "\t(Frame list rollover enable)\n", ehci_usb_int_flr_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hye_e =\t%" PRIx8 "\t(Host system error enable)\n", ehci_usb_int_hye_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iaa_e =\t%" PRIx8 "\t(Interrupt on async advance enable)\n", ehci_usb_int_iaa_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ehci_frame_index_t
 * Description: Implicit type of Frame index register
 * Fields:
 *   fi	(size 14, offset 0, init 0):	RW	Frame index
 *   _anon14	(size 18, offset 14, init 0):	MBZ	_
 */
typedef uint32_t ehci_frame_index_t;
#define ehci_frame_index_default 0x0
static inline uint16_t ehci_frame_index_fi_extract(ehci_frame_index_t _regval) __attribute__ ((always_inline));
static inline uint16_t ehci_frame_index_fi_extract(ehci_frame_index_t _regval)
{
    return((uint16_t )((_regval & 0x3fff) >> 0));
}

static inline ehci_frame_index_t ehci_frame_index_fi_insert(ehci_frame_index_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline ehci_frame_index_t ehci_frame_index_fi_insert(ehci_frame_index_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffffc000) | (0x3fff & (((ehci_frame_index_t )(_fieldval)) << 0)));
}

static inline int ehci_frame_index_prtval(char *_s, size_t _size, ehci_frame_index_t _regval) __attribute__ ((always_inline));
static inline int ehci_frame_index_prtval(char *_s, size_t _size, ehci_frame_index_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fi =\t%" PRIx16 "\t(Frame index)\n", ehci_frame_index_fi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ehci_ctrl_dss_reg_t
 * Description: Implicit type of Control data structure segment register
 * Fields:
 *   data	(size 32, offset 0, init 0):	RW	MSB [63:32] bits of EHCI data strctures
 */
typedef uint32_t ehci_ctrl_dss_reg_t;
#define ehci_ctrl_dss_reg_default 0x0
static inline uint32_t ehci_ctrl_dss_reg_data_extract(ehci_ctrl_dss_reg_t _regval) __attribute__ ((always_inline));
static inline uint32_t ehci_ctrl_dss_reg_data_extract(ehci_ctrl_dss_reg_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline ehci_ctrl_dss_reg_t ehci_ctrl_dss_reg_data_insert(ehci_ctrl_dss_reg_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline ehci_ctrl_dss_reg_t ehci_ctrl_dss_reg_data_insert(ehci_ctrl_dss_reg_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((ehci_ctrl_dss_reg_t )(_fieldval)) << 0)));
}

static inline int ehci_ctrl_dss_reg_prtval(char *_s, size_t _size, ehci_ctrl_dss_reg_t _regval) __attribute__ ((always_inline));
static inline int ehci_ctrl_dss_reg_prtval(char *_s, size_t _size, ehci_ctrl_dss_reg_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx32 "\t(MSB [63:32] bits of EHCI data strctures)\n", ehci_ctrl_dss_reg_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ehci_flba_reg_t
 * Description: Implicit type of Periodic frame list base addr register
 * Fields:
 *   _anon0	(size 12, offset 0, init 0):	MBZ	_
 *   addr	(size 20, offset 12, init 0):	RW	Base address (must be 4k aligned)
 */
typedef uint32_t ehci_flba_reg_t;
#define ehci_flba_reg_default 0x0
static inline uint32_t ehci_flba_reg_addr_extract(ehci_flba_reg_t _regval) __attribute__ ((always_inline));
static inline uint32_t ehci_flba_reg_addr_extract(ehci_flba_reg_t _regval)
{
    return((uint32_t )((_regval & 0xfffff000) >> 12));
}

static inline ehci_flba_reg_t ehci_flba_reg_addr_insert(ehci_flba_reg_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline ehci_flba_reg_t ehci_flba_reg_addr_insert(ehci_flba_reg_t _regval, uint32_t _fieldval)
{
    return((_regval & 0xfff) | (0xfffff000 & (((ehci_flba_reg_t )(_fieldval)) << 12)));
}

static inline int ehci_flba_reg_prtval(char *_s, size_t _size, ehci_flba_reg_t _regval) __attribute__ ((always_inline));
static inline int ehci_flba_reg_prtval(char *_s, size_t _size, ehci_flba_reg_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx32 "\t(Base address (must be 4k aligned))\n", ehci_flba_reg_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ehci_asyn_list_reg_t
 * Description: Implicit type of Current async. list addr. register
 * Fields:
 *   _anon0	(size 5, offset 0, init 0):	MBZ	_
 *   lpl	(size 27, offset 5, init 0):	RW	Link pointer low
 */
typedef uint32_t ehci_asyn_list_reg_t;
#define ehci_asyn_list_reg_default 0x0
static inline uint32_t ehci_asyn_list_reg_lpl_extract(ehci_asyn_list_reg_t _regval) __attribute__ ((always_inline));
static inline uint32_t ehci_asyn_list_reg_lpl_extract(ehci_asyn_list_reg_t _regval)
{
    return((uint32_t )((_regval & 0xffffffe0) >> 5));
}

static inline ehci_asyn_list_reg_t ehci_asyn_list_reg_lpl_insert(ehci_asyn_list_reg_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline ehci_asyn_list_reg_t ehci_asyn_list_reg_lpl_insert(ehci_asyn_list_reg_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x1f) | (0xffffffe0 & (((ehci_asyn_list_reg_t )(_fieldval)) << 5)));
}

static inline int ehci_asyn_list_reg_prtval(char *_s, size_t _size, ehci_asyn_list_reg_t _regval) __attribute__ ((always_inline));
static inline int ehci_asyn_list_reg_prtval(char *_s, size_t _size, ehci_asyn_list_reg_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpl =\t%" PRIx32 "\t(Link pointer low)\n", ehci_asyn_list_reg_lpl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ehci_config_flag_t
 * Description: Implicit type of Configure flag register
 * Fields:
 *   cf	(size 1, offset 0, init 0):	RW	Configure flag
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
typedef uint32_t ehci_config_flag_t;
#define ehci_config_flag_default 0x0
static inline uint8_t ehci_config_flag_cf_extract(ehci_config_flag_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_config_flag_cf_extract(ehci_config_flag_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ehci_config_flag_t ehci_config_flag_cf_insert(ehci_config_flag_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_config_flag_t ehci_config_flag_cf_insert(ehci_config_flag_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ehci_config_flag_t )(_fieldval)) << 0)));
}

static inline int ehci_config_flag_prtval(char *_s, size_t _size, ehci_config_flag_t _regval) __attribute__ ((always_inline));
static inline int ehci_config_flag_prtval(char *_s, size_t _size, ehci_config_flag_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cf =\t%" PRIx8 "\t(Configure flag)\n", ehci_config_flag_cf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ehci_portsc_t
 * Description: Implicit type of Port status and control register array
 * Fields:
 *   ccs	(size 1, offset 0, init 0):	RO	Current connect status
 *   csc	(size 1, offset 1, init 0):	RWC	Connect status change
 *   p_ed	(size 1, offset 2, init 0):	NOATTR	Port enabled/disabled
 *   p_edc	(size 1, offset 3, init 0):	RWC	Port enable/disbale change
 *   oca	(size 1, offset 4, init 0):	RO	Over current active
 *   occ	(size 1, offset 5, init 0):	RWC	Over current change
 *   p_resume	(size 1, offset 6, init 0):	NOATTR	Force port resume
 *   p_suspend	(size 1, offset 7, init 0):	NOATTR	Port suspend
 *   p_reset	(size 1, offset 8, init 0):	NOATTR	Port reset
 *   _anon9	(size 1, offset 9, init 0):	MBZ	_
 *   line_status	(size 2, offset 10, init 0):	NOATTR	Line status value
 *   p_power	(size 1, offset 12, init 0):	NOATTR	Port power
 *   p_owner	(size 1, offset 13, init 0):	NOATTR	Port owner
 *   p_ic	(size 2, offset 14, init 0):	NOATTR	Port indicator control
 *   p_tc	(size 4, offset 16, init 0):	NOATTR	Port test control
 *   wkcnnt_e	(size 1, offset 20, init 0):	NOATTR	Wake on connect enable
 *   wkdscnnt_e	(size 1, offset 21, init 0):	NOATTR	Wake on disconnect enable
 *   wkoc_e	(size 1, offset 22, init 0):	NOATTR	Wake on over-current enable
 *   _anon23	(size 9, offset 23, init 0):	MBZ	_
 */
typedef uint32_t ehci_portsc_t;
#define ehci_portsc_default 0x0
static inline uint8_t ehci_portsc_ccs_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_ccs_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ehci_portsc_t ehci_portsc_ccs_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_ccs_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ehci_portsc_t )(_fieldval)) << 0)));
}

static inline uint8_t ehci_portsc_csc_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_csc_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ehci_portsc_t ehci_portsc_csc_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_csc_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((ehci_portsc_t )(_fieldval)) << 1)));
}

static inline uint8_t ehci_portsc_p_ed_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_p_ed_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ehci_portsc_t ehci_portsc_p_ed_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_p_ed_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((ehci_portsc_t )(_fieldval)) << 2)));
}

static inline uint8_t ehci_portsc_p_edc_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_p_edc_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline ehci_portsc_t ehci_portsc_p_edc_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_p_edc_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((ehci_portsc_t )(_fieldval)) << 3)));
}

static inline uint8_t ehci_portsc_oca_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_oca_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline ehci_portsc_t ehci_portsc_oca_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_oca_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((ehci_portsc_t )(_fieldval)) << 4)));
}

static inline uint8_t ehci_portsc_occ_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_occ_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline ehci_portsc_t ehci_portsc_occ_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_occ_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((ehci_portsc_t )(_fieldval)) << 5)));
}

static inline uint8_t ehci_portsc_p_resume_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_p_resume_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline ehci_portsc_t ehci_portsc_p_resume_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_p_resume_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((ehci_portsc_t )(_fieldval)) << 6)));
}

static inline uint8_t ehci_portsc_p_suspend_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_p_suspend_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline ehci_portsc_t ehci_portsc_p_suspend_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_p_suspend_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((ehci_portsc_t )(_fieldval)) << 7)));
}

static inline uint8_t ehci_portsc_p_reset_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_p_reset_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline ehci_portsc_t ehci_portsc_p_reset_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_p_reset_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((ehci_portsc_t )(_fieldval)) << 8)));
}

static inline ehci_lstatus_val_t ehci_portsc_line_status_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline ehci_lstatus_val_t ehci_portsc_line_status_extract(ehci_portsc_t _regval)
{
    return((ehci_lstatus_val_t )((_regval & 0xc00) >> 10));
}

static inline ehci_portsc_t ehci_portsc_line_status_insert(ehci_portsc_t _regval, ehci_lstatus_val_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_line_status_insert(ehci_portsc_t _regval, ehci_lstatus_val_t _fieldval)
{
    return((_regval & 0xfffff3ff) | (0xc00 & (((ehci_portsc_t )(_fieldval)) << 10)));
}

static inline uint8_t ehci_portsc_p_power_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_p_power_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline ehci_portsc_t ehci_portsc_p_power_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_p_power_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((ehci_portsc_t )(_fieldval)) << 12)));
}

static inline uint8_t ehci_portsc_p_owner_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_p_owner_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline ehci_portsc_t ehci_portsc_p_owner_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_p_owner_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((ehci_portsc_t )(_fieldval)) << 13)));
}

static inline ehci_indi_val_t ehci_portsc_p_ic_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline ehci_indi_val_t ehci_portsc_p_ic_extract(ehci_portsc_t _regval)
{
    return((ehci_indi_val_t )((_regval & 0xc000) >> 14));
}

static inline ehci_portsc_t ehci_portsc_p_ic_insert(ehci_portsc_t _regval, ehci_indi_val_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_p_ic_insert(ehci_portsc_t _regval, ehci_indi_val_t _fieldval)
{
    return((_regval & 0xffff3fff) | (0xc000 & (((ehci_portsc_t )(_fieldval)) << 14)));
}

static inline ehci_test_mode_val_t ehci_portsc_p_tc_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline ehci_test_mode_val_t ehci_portsc_p_tc_extract(ehci_portsc_t _regval)
{
    return((ehci_test_mode_val_t )((_regval & 0xf0000) >> 16));
}

static inline ehci_portsc_t ehci_portsc_p_tc_insert(ehci_portsc_t _regval, ehci_test_mode_val_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_p_tc_insert(ehci_portsc_t _regval, ehci_test_mode_val_t _fieldval)
{
    return((_regval & 0xfff0ffff) | (0xf0000 & (((ehci_portsc_t )(_fieldval)) << 16)));
}

static inline uint8_t ehci_portsc_wkcnnt_e_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_wkcnnt_e_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline ehci_portsc_t ehci_portsc_wkcnnt_e_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_wkcnnt_e_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((ehci_portsc_t )(_fieldval)) << 20)));
}

static inline uint8_t ehci_portsc_wkdscnnt_e_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_wkdscnnt_e_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x200000) >> 21));
}

static inline ehci_portsc_t ehci_portsc_wkdscnnt_e_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_wkdscnnt_e_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((ehci_portsc_t )(_fieldval)) << 21)));
}

static inline uint8_t ehci_portsc_wkoc_e_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_wkoc_e_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x400000) >> 22));
}

static inline ehci_portsc_t ehci_portsc_wkoc_e_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_wkoc_e_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((ehci_portsc_t )(_fieldval)) << 22)));
}

static inline int ehci_portsc_prtval(char *_s, size_t _size, ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline int ehci_portsc_prtval(char *_s, size_t _size, ehci_portsc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ccs =\t%" PRIx8 "\t(Current connect status)\n", ehci_portsc_ccs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " csc =\t%" PRIx8 "\t(Connect status change)\n", ehci_portsc_csc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p_ed =\t%" PRIx8 "\t(Port enabled/disabled)\n", ehci_portsc_p_ed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p_edc =\t%" PRIx8 "\t(Port enable/disbale change)\n", ehci_portsc_p_edc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oca =\t%" PRIx8 "\t(Over current active)\n", ehci_portsc_oca_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " occ =\t%" PRIx8 "\t(Over current change)\n", ehci_portsc_occ_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p_resume =\t%" PRIx8 "\t(Force port resume)\n", ehci_portsc_p_resume_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p_suspend =\t%" PRIx8 "\t(Port suspend)\n", ehci_portsc_p_suspend_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p_reset =\t%" PRIx8 "\t(Port reset)\n", ehci_portsc_p_reset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " line_status =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_lstatus_val_prtval(_s + _r, _avail, ehci_portsc_line_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Line status value)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p_power =\t%" PRIx8 "\t(Port power)\n", ehci_portsc_p_power_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p_owner =\t%" PRIx8 "\t(Port owner)\n", ehci_portsc_p_owner_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p_ic =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_indi_val_prtval(_s + _r, _avail, ehci_portsc_p_ic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port indicator control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p_tc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_test_mode_val_prtval(_s + _r, _avail, ehci_portsc_p_tc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port test control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkcnnt_e =\t%" PRIx8 "\t(Wake on connect enable)\n", ehci_portsc_wkcnnt_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkdscnnt_e =\t%" PRIx8 "\t(Wake on disconnect enable)\n", ehci_portsc_wkdscnnt_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkoc_e =\t%" PRIx8 "\t(Wake on over-current enable)\n", ehci_portsc_wkoc_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ehci_lp_t
 * Description: Link pointer
 * Fields:
 *   t	(size 1, offset 0, init 0):	RW	Pointer value invalid
 *   typ	(size 2, offset 1, init 0):	RW	Pointer type
 *   _anon3	(size 2, offset 3, init 0):	MBZ	_
 *   p	(size 27, offset 5, init 0):	RW	Frame list link pointer
 */
typedef uint8_t *ehci_lp_t;
typedef uint8_t ehci_lp_array_t[4];
static const size_t ehci_lp_size = sizeof(ehci_lp_array_t );
static inline uint8_t ehci_lp_t_extract(ehci_lp_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_lp_t_extract(ehci_lp_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x1) >> 0);
}

static inline void ehci_lp_t_insert(ehci_lp_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_lp_t_insert(ehci_lp_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xfe) | (0x1 & (_fieldval << 0)));
}

static inline ehci_lptype_t ehci_lp_typ_extract(ehci_lp_t _dtptr) __attribute__ ((always_inline));
static inline ehci_lptype_t ehci_lp_typ_extract(ehci_lp_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x6) >> 1);
}

static inline void ehci_lp_typ_insert(ehci_lp_t _dtptr, ehci_lptype_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_lp_typ_insert(ehci_lp_t _dtptr, ehci_lptype_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xf9) | (0x6 & (_fieldval << 1)));
}

static inline uint32_t ehci_lp_p_extract(ehci_lp_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t ehci_lp_p_extract(ehci_lp_t _dtptr)
{
    return(((*((uint32_t *)(0 + _dtptr))) & 0xffffffe0) >> 5);
}

static inline void ehci_lp_p_insert(ehci_lp_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_lp_p_insert(ehci_lp_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(0 + _dtptr)) = (((*((uint32_t *)(0 + _dtptr))) & 0x1f) | (0xffffffe0 & (_fieldval << 5)));
}

static inline int ehci_lp_prtval(char *_s, size_t _size, ehci_lp_t _regval) __attribute__ ((always_inline));
static inline int ehci_lp_prtval(char *_s, size_t _size, ehci_lp_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " t =\t%" PRIx8 "\t(Pointer value invalid)\n", ehci_lp_t_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " typ =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_lptype_prtval(_s + _r, _avail, ehci_lp_typ_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pointer type)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p =\t%" PRIx32 "\t(Frame list link pointer)\n", ehci_lp_p_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ehci_itd_t
 * Description: Isochronous transfer descriptor
 * Fields:
 *   next	(size 32, offset 0, init 0):	RW	Next descriptor
 *   sc0	(size 32, offset 32, init 0):	RW	Transaction 0 Status/control
 *   sc1	(size 32, offset 64, init 0):	RW	Transaction 1 Status/control
 *   sc2	(size 32, offset 96, init 0):	RW	Transaction 2 Status/control
 *   sc3	(size 32, offset 128, init 0):	RW	Transaction 3 Status/control
 *   sc4	(size 32, offset 160, init 0):	RW	Transaction 4 Status/control
 *   sc5	(size 32, offset 192, init 0):	RW	Transaction 5 Status/control
 *   sc6	(size 32, offset 224, init 0):	RW	Transaction 6 Status/control
 *   sc7	(size 32, offset 256, init 0):	RW	Transaction 7 Status/control
 *   bp0	(size 32, offset 288, init 0):	RW	Buffer pointer 0
 *   bp1	(size 32, offset 320, init 0):	RW	Buffer pointer 1
 *   bp2	(size 32, offset 352, init 0):	RW	Buffer pointer 2
 *   bp3	(size 32, offset 384, init 0):	RW	Buffer pointer 3
 *   bp4	(size 32, offset 416, init 0):	RW	Buffer pointer 4
 *   bp5	(size 32, offset 448, init 0):	RW	Buffer pointer 5
 *   bp6	(size 32, offset 480, init 0):	RW	Buffer pointer 6
 */
typedef uint8_t *ehci_itd_t;
typedef uint8_t ehci_itd_array_t[64];
static const size_t ehci_itd_size = sizeof(ehci_itd_array_t );
static inline ehci_lp_t ehci_itd_next_extract(ehci_itd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_lp_t ehci_itd_next_extract(ehci_itd_t _dtptr)
{
    return(((*((uint32_t *)(0 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_itd_next_insert(ehci_itd_t _dtptr, ehci_lp_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itd_next_insert(ehci_itd_t _dtptr, ehci_lp_t _fieldval)
{
    *((uint32_t *)(0 + _dtptr)) = (((*((uint32_t *)(0 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_itsc_t ehci_itd_sc0_extract(ehci_itd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_itsc_t ehci_itd_sc0_extract(ehci_itd_t _dtptr)
{
    return(((*((uint32_t *)(4 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_itd_sc0_insert(ehci_itd_t _dtptr, ehci_itsc_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itd_sc0_insert(ehci_itd_t _dtptr, ehci_itsc_t _fieldval)
{
    *((uint32_t *)(4 + _dtptr)) = (((*((uint32_t *)(4 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_itsc_t ehci_itd_sc1_extract(ehci_itd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_itsc_t ehci_itd_sc1_extract(ehci_itd_t _dtptr)
{
    return(((*((uint32_t *)(8 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_itd_sc1_insert(ehci_itd_t _dtptr, ehci_itsc_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itd_sc1_insert(ehci_itd_t _dtptr, ehci_itsc_t _fieldval)
{
    *((uint32_t *)(8 + _dtptr)) = (((*((uint32_t *)(8 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_itsc_t ehci_itd_sc2_extract(ehci_itd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_itsc_t ehci_itd_sc2_extract(ehci_itd_t _dtptr)
{
    return(((*((uint32_t *)(12 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_itd_sc2_insert(ehci_itd_t _dtptr, ehci_itsc_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itd_sc2_insert(ehci_itd_t _dtptr, ehci_itsc_t _fieldval)
{
    *((uint32_t *)(12 + _dtptr)) = (((*((uint32_t *)(12 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_itsc_t ehci_itd_sc3_extract(ehci_itd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_itsc_t ehci_itd_sc3_extract(ehci_itd_t _dtptr)
{
    return(((*((uint32_t *)(16 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_itd_sc3_insert(ehci_itd_t _dtptr, ehci_itsc_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itd_sc3_insert(ehci_itd_t _dtptr, ehci_itsc_t _fieldval)
{
    *((uint32_t *)(16 + _dtptr)) = (((*((uint32_t *)(16 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_itsc_t ehci_itd_sc4_extract(ehci_itd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_itsc_t ehci_itd_sc4_extract(ehci_itd_t _dtptr)
{
    return(((*((uint32_t *)(20 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_itd_sc4_insert(ehci_itd_t _dtptr, ehci_itsc_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itd_sc4_insert(ehci_itd_t _dtptr, ehci_itsc_t _fieldval)
{
    *((uint32_t *)(20 + _dtptr)) = (((*((uint32_t *)(20 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_itsc_t ehci_itd_sc5_extract(ehci_itd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_itsc_t ehci_itd_sc5_extract(ehci_itd_t _dtptr)
{
    return(((*((uint32_t *)(24 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_itd_sc5_insert(ehci_itd_t _dtptr, ehci_itsc_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itd_sc5_insert(ehci_itd_t _dtptr, ehci_itsc_t _fieldval)
{
    *((uint32_t *)(24 + _dtptr)) = (((*((uint32_t *)(24 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_itsc_t ehci_itd_sc6_extract(ehci_itd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_itsc_t ehci_itd_sc6_extract(ehci_itd_t _dtptr)
{
    return(((*((uint32_t *)(28 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_itd_sc6_insert(ehci_itd_t _dtptr, ehci_itsc_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itd_sc6_insert(ehci_itd_t _dtptr, ehci_itsc_t _fieldval)
{
    *((uint32_t *)(28 + _dtptr)) = (((*((uint32_t *)(28 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_itsc_t ehci_itd_sc7_extract(ehci_itd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_itsc_t ehci_itd_sc7_extract(ehci_itd_t _dtptr)
{
    return(((*((uint32_t *)(32 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_itd_sc7_insert(ehci_itd_t _dtptr, ehci_itsc_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itd_sc7_insert(ehci_itd_t _dtptr, ehci_itsc_t _fieldval)
{
    *((uint32_t *)(32 + _dtptr)) = (((*((uint32_t *)(32 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_itbp0_t ehci_itd_bp0_extract(ehci_itd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_itbp0_t ehci_itd_bp0_extract(ehci_itd_t _dtptr)
{
    return(((*((uint32_t *)(36 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_itd_bp0_insert(ehci_itd_t _dtptr, ehci_itbp0_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itd_bp0_insert(ehci_itd_t _dtptr, ehci_itbp0_t _fieldval)
{
    *((uint32_t *)(36 + _dtptr)) = (((*((uint32_t *)(36 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_itbp1_t ehci_itd_bp1_extract(ehci_itd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_itbp1_t ehci_itd_bp1_extract(ehci_itd_t _dtptr)
{
    return(((*((uint32_t *)(40 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_itd_bp1_insert(ehci_itd_t _dtptr, ehci_itbp1_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itd_bp1_insert(ehci_itd_t _dtptr, ehci_itbp1_t _fieldval)
{
    *((uint32_t *)(40 + _dtptr)) = (((*((uint32_t *)(40 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_itbp2_t ehci_itd_bp2_extract(ehci_itd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_itbp2_t ehci_itd_bp2_extract(ehci_itd_t _dtptr)
{
    return(((*((uint32_t *)(44 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_itd_bp2_insert(ehci_itd_t _dtptr, ehci_itbp2_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itd_bp2_insert(ehci_itd_t _dtptr, ehci_itbp2_t _fieldval)
{
    *((uint32_t *)(44 + _dtptr)) = (((*((uint32_t *)(44 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_itbp3_t ehci_itd_bp3_extract(ehci_itd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_itbp3_t ehci_itd_bp3_extract(ehci_itd_t _dtptr)
{
    return(((*((uint32_t *)(48 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_itd_bp3_insert(ehci_itd_t _dtptr, ehci_itbp3_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itd_bp3_insert(ehci_itd_t _dtptr, ehci_itbp3_t _fieldval)
{
    *((uint32_t *)(48 + _dtptr)) = (((*((uint32_t *)(48 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_itbp3_t ehci_itd_bp4_extract(ehci_itd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_itbp3_t ehci_itd_bp4_extract(ehci_itd_t _dtptr)
{
    return(((*((uint32_t *)(52 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_itd_bp4_insert(ehci_itd_t _dtptr, ehci_itbp3_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itd_bp4_insert(ehci_itd_t _dtptr, ehci_itbp3_t _fieldval)
{
    *((uint32_t *)(52 + _dtptr)) = (((*((uint32_t *)(52 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_itbp3_t ehci_itd_bp5_extract(ehci_itd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_itbp3_t ehci_itd_bp5_extract(ehci_itd_t _dtptr)
{
    return(((*((uint32_t *)(56 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_itd_bp5_insert(ehci_itd_t _dtptr, ehci_itbp3_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itd_bp5_insert(ehci_itd_t _dtptr, ehci_itbp3_t _fieldval)
{
    *((uint32_t *)(56 + _dtptr)) = (((*((uint32_t *)(56 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_itbp3_t ehci_itd_bp6_extract(ehci_itd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_itbp3_t ehci_itd_bp6_extract(ehci_itd_t _dtptr)
{
    return(((*((uint32_t *)(60 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_itd_bp6_insert(ehci_itd_t _dtptr, ehci_itbp3_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itd_bp6_insert(ehci_itd_t _dtptr, ehci_itbp3_t _fieldval)
{
    *((uint32_t *)(60 + _dtptr)) = (((*((uint32_t *)(60 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline int ehci_itd_prtval(char *_s, size_t _size, ehci_itd_t _regval) __attribute__ ((always_inline));
static inline int ehci_itd_prtval(char *_s, size_t _size, ehci_itd_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " next =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_lp_prtval(_s + _r, _avail, ehci_itd_next_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Next descriptor)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sc0 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_itsc_prtval(_s + _r, _avail, ehci_itd_sc0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Transaction 0 Status/control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sc1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_itsc_prtval(_s + _r, _avail, ehci_itd_sc1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Transaction 1 Status/control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sc2 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_itsc_prtval(_s + _r, _avail, ehci_itd_sc2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Transaction 2 Status/control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sc3 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_itsc_prtval(_s + _r, _avail, ehci_itd_sc3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Transaction 3 Status/control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sc4 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_itsc_prtval(_s + _r, _avail, ehci_itd_sc4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Transaction 4 Status/control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sc5 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_itsc_prtval(_s + _r, _avail, ehci_itd_sc5_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Transaction 5 Status/control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sc6 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_itsc_prtval(_s + _r, _avail, ehci_itd_sc6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Transaction 6 Status/control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sc7 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_itsc_prtval(_s + _r, _avail, ehci_itd_sc7_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Transaction 7 Status/control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bp0 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_itbp0_prtval(_s + _r, _avail, ehci_itd_bp0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Buffer pointer 0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bp1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_itbp1_prtval(_s + _r, _avail, ehci_itd_bp1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Buffer pointer 1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bp2 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_itbp2_prtval(_s + _r, _avail, ehci_itd_bp2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Buffer pointer 2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bp3 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_itbp3_prtval(_s + _r, _avail, ehci_itd_bp3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Buffer pointer 3)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bp4 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_itbp3_prtval(_s + _r, _avail, ehci_itd_bp4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Buffer pointer 4)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bp5 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_itbp3_prtval(_s + _r, _avail, ehci_itd_bp5_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Buffer pointer 5)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bp6 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_itbp3_prtval(_s + _r, _avail, ehci_itd_bp6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Buffer pointer 6)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ehci_itsc_t
 * Description: Isochronous transaction status/control
 * Fields:
 *   offset	(size 12, offset 0, init 0):	RW	Offset from state of buffer
 *   pg	(size 3, offset 12, init 0):	RW	Page select (0-6)
 *   ioc	(size 1, offset 15, init 0):	RW	Interrupt on complete
 *   length	(size 12, offset 16, init 0):	RW	Transaction length
 *   xacterr	(size 1, offset 28, init 0):	RW	Transaction error
 *   bd	(size 1, offset 29, init 0):	RW	Babble detected
 *   dbe	(size 1, offset 30, init 0):	RW	Data buffer error
 *   active	(size 1, offset 31, init 0):	RW	Active
 */
typedef uint8_t *ehci_itsc_t;
typedef uint8_t ehci_itsc_array_t[4];
static const size_t ehci_itsc_size = sizeof(ehci_itsc_array_t );
static inline uint16_t ehci_itsc_offset_extract(ehci_itsc_t _dtptr) __attribute__ ((always_inline));
static inline uint16_t ehci_itsc_offset_extract(ehci_itsc_t _dtptr)
{
    return(((*((uint16_t *)(0 + _dtptr))) & 0xfff) >> 0);
}

static inline void ehci_itsc_offset_insert(ehci_itsc_t _dtptr, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itsc_offset_insert(ehci_itsc_t _dtptr, uint16_t _fieldval)
{
    *((uint16_t *)(0 + _dtptr)) = (((*((uint16_t *)(0 + _dtptr))) & 0xf000) | (0xfff & (_fieldval << 0)));
}

static inline uint8_t ehci_itsc_pg_extract(ehci_itsc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_itsc_pg_extract(ehci_itsc_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x70) >> 4);
}

static inline void ehci_itsc_pg_insert(ehci_itsc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itsc_pg_insert(ehci_itsc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0x8f) | (0x70 & (_fieldval << 4)));
}

static inline uint8_t ehci_itsc_ioc_extract(ehci_itsc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_itsc_ioc_extract(ehci_itsc_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x80) >> 7);
}

static inline void ehci_itsc_ioc_insert(ehci_itsc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itsc_ioc_insert(ehci_itsc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline uint16_t ehci_itsc_length_extract(ehci_itsc_t _dtptr) __attribute__ ((always_inline));
static inline uint16_t ehci_itsc_length_extract(ehci_itsc_t _dtptr)
{
    return(((*((uint16_t *)(2 + _dtptr))) & 0xfff) >> 0);
}

static inline void ehci_itsc_length_insert(ehci_itsc_t _dtptr, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itsc_length_insert(ehci_itsc_t _dtptr, uint16_t _fieldval)
{
    *((uint16_t *)(2 + _dtptr)) = (((*((uint16_t *)(2 + _dtptr))) & 0xf000) | (0xfff & (_fieldval << 0)));
}

static inline uint8_t ehci_itsc_xacterr_extract(ehci_itsc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_itsc_xacterr_extract(ehci_itsc_t _dtptr)
{
    return(((*((uint8_t *)(3 + _dtptr))) & 0x10) >> 4);
}

static inline void ehci_itsc_xacterr_insert(ehci_itsc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itsc_xacterr_insert(ehci_itsc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(3 + _dtptr)) = (((*((uint8_t *)(3 + _dtptr))) & 0xef) | (0x10 & (_fieldval << 4)));
}

static inline uint8_t ehci_itsc_bd_extract(ehci_itsc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_itsc_bd_extract(ehci_itsc_t _dtptr)
{
    return(((*((uint8_t *)(3 + _dtptr))) & 0x20) >> 5);
}

static inline void ehci_itsc_bd_insert(ehci_itsc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itsc_bd_insert(ehci_itsc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(3 + _dtptr)) = (((*((uint8_t *)(3 + _dtptr))) & 0xdf) | (0x20 & (_fieldval << 5)));
}

static inline uint8_t ehci_itsc_dbe_extract(ehci_itsc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_itsc_dbe_extract(ehci_itsc_t _dtptr)
{
    return(((*((uint8_t *)(3 + _dtptr))) & 0x40) >> 6);
}

static inline void ehci_itsc_dbe_insert(ehci_itsc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itsc_dbe_insert(ehci_itsc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(3 + _dtptr)) = (((*((uint8_t *)(3 + _dtptr))) & 0xbf) | (0x40 & (_fieldval << 6)));
}

static inline uint8_t ehci_itsc_active_extract(ehci_itsc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_itsc_active_extract(ehci_itsc_t _dtptr)
{
    return(((*((uint8_t *)(3 + _dtptr))) & 0x80) >> 7);
}

static inline void ehci_itsc_active_insert(ehci_itsc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itsc_active_insert(ehci_itsc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(3 + _dtptr)) = (((*((uint8_t *)(3 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline int ehci_itsc_prtval(char *_s, size_t _size, ehci_itsc_t _regval) __attribute__ ((always_inline));
static inline int ehci_itsc_prtval(char *_s, size_t _size, ehci_itsc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " offset =\t%" PRIx16 "\t(Offset from state of buffer)\n", ehci_itsc_offset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pg =\t%" PRIx8 "\t(Page select (0-6))\n", ehci_itsc_pg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ioc =\t%" PRIx8 "\t(Interrupt on complete)\n", ehci_itsc_ioc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " length =\t%" PRIx16 "\t(Transaction length)\n", ehci_itsc_length_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xacterr =\t%" PRIx8 "\t(Transaction error)\n", ehci_itsc_xacterr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bd =\t%" PRIx8 "\t(Babble detected)\n", ehci_itsc_bd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dbe =\t%" PRIx8 "\t(Data buffer error)\n", ehci_itsc_dbe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " active =\t%" PRIx8 "\t(Active)\n", ehci_itsc_active_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ehci_itbp0_t
 * Description: iTD buffer pointer page 0
 * Fields:
 *   da	(size 7, offset 0, init 0):	RW	Device address
 *   _anon7	(size 1, offset 7, init 0):	MBZ	_
 *   epn	(size 4, offset 8, init 0):	RW	Endpoint number
 *   p	(size 20, offset 12, init 0):	RW	Buffer pointer (4k aligned)
 */
typedef uint8_t *ehci_itbp0_t;
typedef uint8_t ehci_itbp0_array_t[4];
static const size_t ehci_itbp0_size = sizeof(ehci_itbp0_array_t );
static inline uint8_t ehci_itbp0_da_extract(ehci_itbp0_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_itbp0_da_extract(ehci_itbp0_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x7f) >> 0);
}

static inline void ehci_itbp0_da_insert(ehci_itbp0_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itbp0_da_insert(ehci_itbp0_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0x80) | (0x7f & (_fieldval << 0)));
}

static inline uint8_t ehci_itbp0_epn_extract(ehci_itbp0_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_itbp0_epn_extract(ehci_itbp0_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0xf) >> 0);
}

static inline void ehci_itbp0_epn_insert(ehci_itbp0_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itbp0_epn_insert(ehci_itbp0_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xf0) | (0xf & (_fieldval << 0)));
}

static inline uint32_t ehci_itbp0_p_extract(ehci_itbp0_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t ehci_itbp0_p_extract(ehci_itbp0_t _dtptr)
{
    return(((*((uint32_t *)(0 + _dtptr))) & 0xfffff000) >> 12);
}

static inline void ehci_itbp0_p_insert(ehci_itbp0_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itbp0_p_insert(ehci_itbp0_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(0 + _dtptr)) = (((*((uint32_t *)(0 + _dtptr))) & 0xfff) | (0xfffff000 & (_fieldval << 12)));
}

static inline int ehci_itbp0_prtval(char *_s, size_t _size, ehci_itbp0_t _regval) __attribute__ ((always_inline));
static inline int ehci_itbp0_prtval(char *_s, size_t _size, ehci_itbp0_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " da =\t%" PRIx8 "\t(Device address)\n", ehci_itbp0_da_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " epn =\t%" PRIx8 "\t(Endpoint number)\n", ehci_itbp0_epn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p =\t%" PRIx32 "\t(Buffer pointer (4k aligned))\n", ehci_itbp0_p_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ehci_itdp1_t
 * Description: iTD buffer pointer page 1
 * Fields:
 *   mps	(size 11, offset 0, init 0):	RW	Maximum packet size
 *   dir	(size 1, offset 11, init 0):	RW	In (1) or out (0) PID
 *   p	(size 20, offset 12, init 0):	RW	Buffer pointer (4k aligned)
 */
typedef uint8_t *ehci_itdp1_t;
typedef uint8_t ehci_itdp1_array_t[4];
static const size_t ehci_itdp1_size = sizeof(ehci_itdp1_array_t );
static inline uint16_t ehci_itdp1_mps_extract(ehci_itdp1_t _dtptr) __attribute__ ((always_inline));
static inline uint16_t ehci_itdp1_mps_extract(ehci_itdp1_t _dtptr)
{
    return(((*((uint16_t *)(0 + _dtptr))) & 0x7ff) >> 0);
}

static inline void ehci_itdp1_mps_insert(ehci_itdp1_t _dtptr, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itdp1_mps_insert(ehci_itdp1_t _dtptr, uint16_t _fieldval)
{
    *((uint16_t *)(0 + _dtptr)) = (((*((uint16_t *)(0 + _dtptr))) & 0xf800) | (0x7ff & (_fieldval << 0)));
}

static inline uint8_t ehci_itdp1_dir_extract(ehci_itdp1_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_itdp1_dir_extract(ehci_itdp1_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x8) >> 3);
}

static inline void ehci_itdp1_dir_insert(ehci_itdp1_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itdp1_dir_insert(ehci_itdp1_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xf7) | (0x8 & (_fieldval << 3)));
}

static inline uint32_t ehci_itdp1_p_extract(ehci_itdp1_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t ehci_itdp1_p_extract(ehci_itdp1_t _dtptr)
{
    return(((*((uint32_t *)(0 + _dtptr))) & 0xfffff000) >> 12);
}

static inline void ehci_itdp1_p_insert(ehci_itdp1_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itdp1_p_insert(ehci_itdp1_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(0 + _dtptr)) = (((*((uint32_t *)(0 + _dtptr))) & 0xfff) | (0xfffff000 & (_fieldval << 12)));
}

static inline int ehci_itdp1_prtval(char *_s, size_t _size, ehci_itdp1_t _regval) __attribute__ ((always_inline));
static inline int ehci_itdp1_prtval(char *_s, size_t _size, ehci_itdp1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mps =\t%" PRIx16 "\t(Maximum packet size)\n", ehci_itdp1_mps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dir =\t%" PRIx8 "\t(In (1) or out (0) PID)\n", ehci_itdp1_dir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p =\t%" PRIx32 "\t(Buffer pointer (4k aligned))\n", ehci_itdp1_p_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ehci_itdp2_t
 * Description: iTD buffer pointer page 2
 * Fields:
 *   multi	(size 2, offset 0, init 0):	RW	Num. transactions/micro-frame + 1 (0=rsvd)
 *   _anon2	(size 10, offset 2, init 0):	MBZ	_
 *   p	(size 20, offset 12, init 0):	RW	Buffer pointer (4k aligned)
 */
typedef uint8_t *ehci_itdp2_t;
typedef uint8_t ehci_itdp2_array_t[4];
static const size_t ehci_itdp2_size = sizeof(ehci_itdp2_array_t );
static inline uint8_t ehci_itdp2_multi_extract(ehci_itdp2_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_itdp2_multi_extract(ehci_itdp2_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x3) >> 0);
}

static inline void ehci_itdp2_multi_insert(ehci_itdp2_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itdp2_multi_insert(ehci_itdp2_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xfc) | (0x3 & (_fieldval << 0)));
}

static inline uint32_t ehci_itdp2_p_extract(ehci_itdp2_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t ehci_itdp2_p_extract(ehci_itdp2_t _dtptr)
{
    return(((*((uint32_t *)(0 + _dtptr))) & 0xfffff000) >> 12);
}

static inline void ehci_itdp2_p_insert(ehci_itdp2_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itdp2_p_insert(ehci_itdp2_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(0 + _dtptr)) = (((*((uint32_t *)(0 + _dtptr))) & 0xfff) | (0xfffff000 & (_fieldval << 12)));
}

static inline int ehci_itdp2_prtval(char *_s, size_t _size, ehci_itdp2_t _regval) __attribute__ ((always_inline));
static inline int ehci_itdp2_prtval(char *_s, size_t _size, ehci_itdp2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " multi =\t%" PRIx8 "\t(Num. transactions/micro-frame + 1 (0=rsvd))\n", ehci_itdp2_multi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p =\t%" PRIx32 "\t(Buffer pointer (4k aligned))\n", ehci_itdp2_p_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ehci_itdp3_t
 * Description: iTD buffer pointer page 3
 * Fields:
 *   _anon0	(size 12, offset 0, init 0):	MBZ	_
 *   p	(size 20, offset 12, init 0):	RW	Buffer pointer (4k aligned)
 */
typedef uint8_t *ehci_itdp3_t;
typedef uint8_t ehci_itdp3_array_t[4];
static const size_t ehci_itdp3_size = sizeof(ehci_itdp3_array_t );
static inline uint32_t ehci_itdp3_p_extract(ehci_itdp3_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t ehci_itdp3_p_extract(ehci_itdp3_t _dtptr)
{
    return(((*((uint32_t *)(0 + _dtptr))) & 0xfffff000) >> 12);
}

static inline void ehci_itdp3_p_insert(ehci_itdp3_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_itdp3_p_insert(ehci_itdp3_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(0 + _dtptr)) = (((*((uint32_t *)(0 + _dtptr))) & 0xfff) | (0xfffff000 & (_fieldval << 12)));
}

static inline int ehci_itdp3_prtval(char *_s, size_t _size, ehci_itdp3_t _regval) __attribute__ ((always_inline));
static inline int ehci_itdp3_prtval(char *_s, size_t _size, ehci_itdp3_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p =\t%" PRIx32 "\t(Buffer pointer (4k aligned))\n", ehci_itdp3_p_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ehci_sitd_t
 * Description: Split isochronous transfer descriptor
 * Fields:
 *   next	(size 32, offset 0, init 0):	RW	Next descriptor
 *   cap	(size 32, offset 32, init 0):	RW	Endpoint capabilities/characteristics
 *   msc	(size 32, offset 64, init 0):	RW	Micro-frame schedule control
 *   tsc	(size 32, offset 96, init 0):	RW	Transfer status and control
 *   bpl0	(size 32, offset 128, init 0):	RW	Buffer page pointer 0
 *   bpl1	(size 32, offset 160, init 0):	RW	Buffer page pointer 1
 *   bp	(size 32, offset 192, init 0):	RW	Back link
 */
typedef uint8_t *ehci_sitd_t;
typedef uint8_t ehci_sitd_array_t[28];
static const size_t ehci_sitd_size = sizeof(ehci_sitd_array_t );
static inline ehci_lp_t ehci_sitd_next_extract(ehci_sitd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_lp_t ehci_sitd_next_extract(ehci_sitd_t _dtptr)
{
    return(((*((uint32_t *)(0 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_sitd_next_insert(ehci_sitd_t _dtptr, ehci_lp_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sitd_next_insert(ehci_sitd_t _dtptr, ehci_lp_t _fieldval)
{
    *((uint32_t *)(0 + _dtptr)) = (((*((uint32_t *)(0 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_sitcap_t ehci_sitd_cap_extract(ehci_sitd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_sitcap_t ehci_sitd_cap_extract(ehci_sitd_t _dtptr)
{
    return(((*((uint32_t *)(4 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_sitd_cap_insert(ehci_sitd_t _dtptr, ehci_sitcap_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sitd_cap_insert(ehci_sitd_t _dtptr, ehci_sitcap_t _fieldval)
{
    *((uint32_t *)(4 + _dtptr)) = (((*((uint32_t *)(4 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_sitmsc_t ehci_sitd_msc_extract(ehci_sitd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_sitmsc_t ehci_sitd_msc_extract(ehci_sitd_t _dtptr)
{
    return(((*((uint32_t *)(8 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_sitd_msc_insert(ehci_sitd_t _dtptr, ehci_sitmsc_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sitd_msc_insert(ehci_sitd_t _dtptr, ehci_sitmsc_t _fieldval)
{
    *((uint32_t *)(8 + _dtptr)) = (((*((uint32_t *)(8 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_sittsc_t ehci_sitd_tsc_extract(ehci_sitd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_sittsc_t ehci_sitd_tsc_extract(ehci_sitd_t _dtptr)
{
    return(((*((uint32_t *)(12 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_sitd_tsc_insert(ehci_sitd_t _dtptr, ehci_sittsc_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sitd_tsc_insert(ehci_sitd_t _dtptr, ehci_sittsc_t _fieldval)
{
    *((uint32_t *)(12 + _dtptr)) = (((*((uint32_t *)(12 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_sitbpl0_t ehci_sitd_bpl0_extract(ehci_sitd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_sitbpl0_t ehci_sitd_bpl0_extract(ehci_sitd_t _dtptr)
{
    return(((*((uint32_t *)(16 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_sitd_bpl0_insert(ehci_sitd_t _dtptr, ehci_sitbpl0_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sitd_bpl0_insert(ehci_sitd_t _dtptr, ehci_sitbpl0_t _fieldval)
{
    *((uint32_t *)(16 + _dtptr)) = (((*((uint32_t *)(16 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_sitbpl1_t ehci_sitd_bpl1_extract(ehci_sitd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_sitbpl1_t ehci_sitd_bpl1_extract(ehci_sitd_t _dtptr)
{
    return(((*((uint32_t *)(20 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_sitd_bpl1_insert(ehci_sitd_t _dtptr, ehci_sitbpl1_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sitd_bpl1_insert(ehci_sitd_t _dtptr, ehci_sitbpl1_t _fieldval)
{
    *((uint32_t *)(20 + _dtptr)) = (((*((uint32_t *)(20 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_sitblp_t ehci_sitd_bp_extract(ehci_sitd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_sitblp_t ehci_sitd_bp_extract(ehci_sitd_t _dtptr)
{
    return(((*((uint32_t *)(24 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_sitd_bp_insert(ehci_sitd_t _dtptr, ehci_sitblp_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sitd_bp_insert(ehci_sitd_t _dtptr, ehci_sitblp_t _fieldval)
{
    *((uint32_t *)(24 + _dtptr)) = (((*((uint32_t *)(24 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline int ehci_sitd_prtval(char *_s, size_t _size, ehci_sitd_t _regval) __attribute__ ((always_inline));
static inline int ehci_sitd_prtval(char *_s, size_t _size, ehci_sitd_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " next =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_lp_prtval(_s + _r, _avail, ehci_sitd_next_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Next descriptor)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cap =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_sitcap_prtval(_s + _r, _avail, ehci_sitd_cap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Endpoint capabilities/characteristics)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_sitmsc_prtval(_s + _r, _avail, ehci_sitd_msc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Micro-frame schedule control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tsc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_sittsc_prtval(_s + _r, _avail, ehci_sitd_tsc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Transfer status and control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bpl0 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_sitbpl0_prtval(_s + _r, _avail, ehci_sitd_bpl0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Buffer page pointer 0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bpl1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_sitbpl1_prtval(_s + _r, _avail, ehci_sitd_bpl1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Buffer page pointer 1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bp =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_sitblp_prtval(_s + _r, _avail, ehci_sitd_bp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Back link)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ehci_sitcap_t
 * Description: siTD endpoint capabilities/characteristics
 * Fields:
 *   da	(size 7, offset 0, init 0):	RW	Device address
 *   _anon7	(size 1, offset 7, init 0):	MBZ	_
 *   epn	(size 4, offset 8, init 0):	RW	Endpoint number
 *   _anon12	(size 4, offset 12, init 0):	MBZ	_
 *   hub	(size 7, offset 16, init 0):	RW	Hub address
 *   _anon23	(size 1, offset 23, init 0):	MBZ	_
 *   port	(size 7, offset 24, init 0):	RW	Port number
 *   dir	(size 1, offset 31, init 0):	RW	In (1) or out (0) PID
 */
typedef uint8_t *ehci_sitcap_t;
typedef uint8_t ehci_sitcap_array_t[4];
static const size_t ehci_sitcap_size = sizeof(ehci_sitcap_array_t );
static inline uint8_t ehci_sitcap_da_extract(ehci_sitcap_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_sitcap_da_extract(ehci_sitcap_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x7f) >> 0);
}

static inline void ehci_sitcap_da_insert(ehci_sitcap_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sitcap_da_insert(ehci_sitcap_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0x80) | (0x7f & (_fieldval << 0)));
}

static inline uint8_t ehci_sitcap_epn_extract(ehci_sitcap_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_sitcap_epn_extract(ehci_sitcap_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0xf) >> 0);
}

static inline void ehci_sitcap_epn_insert(ehci_sitcap_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sitcap_epn_insert(ehci_sitcap_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xf0) | (0xf & (_fieldval << 0)));
}

static inline uint8_t ehci_sitcap_hub_extract(ehci_sitcap_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_sitcap_hub_extract(ehci_sitcap_t _dtptr)
{
    return(((*((uint8_t *)(2 + _dtptr))) & 0x7f) >> 0);
}

static inline void ehci_sitcap_hub_insert(ehci_sitcap_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sitcap_hub_insert(ehci_sitcap_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(2 + _dtptr)) = (((*((uint8_t *)(2 + _dtptr))) & 0x80) | (0x7f & (_fieldval << 0)));
}

static inline uint8_t ehci_sitcap_port_extract(ehci_sitcap_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_sitcap_port_extract(ehci_sitcap_t _dtptr)
{
    return(((*((uint8_t *)(3 + _dtptr))) & 0x7f) >> 0);
}

static inline void ehci_sitcap_port_insert(ehci_sitcap_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sitcap_port_insert(ehci_sitcap_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(3 + _dtptr)) = (((*((uint8_t *)(3 + _dtptr))) & 0x80) | (0x7f & (_fieldval << 0)));
}

static inline uint8_t ehci_sitcap_dir_extract(ehci_sitcap_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_sitcap_dir_extract(ehci_sitcap_t _dtptr)
{
    return(((*((uint8_t *)(3 + _dtptr))) & 0x80) >> 7);
}

static inline void ehci_sitcap_dir_insert(ehci_sitcap_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sitcap_dir_insert(ehci_sitcap_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(3 + _dtptr)) = (((*((uint8_t *)(3 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline int ehci_sitcap_prtval(char *_s, size_t _size, ehci_sitcap_t _regval) __attribute__ ((always_inline));
static inline int ehci_sitcap_prtval(char *_s, size_t _size, ehci_sitcap_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " da =\t%" PRIx8 "\t(Device address)\n", ehci_sitcap_da_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " epn =\t%" PRIx8 "\t(Endpoint number)\n", ehci_sitcap_epn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hub =\t%" PRIx8 "\t(Hub address)\n", ehci_sitcap_hub_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " port =\t%" PRIx8 "\t(Port number)\n", ehci_sitcap_port_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dir =\t%" PRIx8 "\t(In (1) or out (0) PID)\n", ehci_sitcap_dir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ehci_sitmsc_t
 * Description: siTD micro-frame schedule control
 * Fields:
 *   ssm	(size 8, offset 0, init 0):	RW	Split start mask
 *   scm	(size 8, offset 8, init 0):	RW	Split completion mask
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
typedef uint8_t *ehci_sitmsc_t;
typedef uint8_t ehci_sitmsc_array_t[4];
static const size_t ehci_sitmsc_size = sizeof(ehci_sitmsc_array_t );
static inline uint8_t ehci_sitmsc_ssm_extract(ehci_sitmsc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_sitmsc_ssm_extract(ehci_sitmsc_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0xff) >> 0);
}

static inline void ehci_sitmsc_ssm_insert(ehci_sitmsc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sitmsc_ssm_insert(ehci_sitmsc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0x0) | (0xff & (_fieldval << 0)));
}

static inline uint8_t ehci_sitmsc_scm_extract(ehci_sitmsc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_sitmsc_scm_extract(ehci_sitmsc_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0xff) >> 0);
}

static inline void ehci_sitmsc_scm_insert(ehci_sitmsc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sitmsc_scm_insert(ehci_sitmsc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0x0) | (0xff & (_fieldval << 0)));
}

static inline int ehci_sitmsc_prtval(char *_s, size_t _size, ehci_sitmsc_t _regval) __attribute__ ((always_inline));
static inline int ehci_sitmsc_prtval(char *_s, size_t _size, ehci_sitmsc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ssm =\t%" PRIx8 "\t(Split start mask)\n", ehci_sitmsc_ssm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " scm =\t%" PRIx8 "\t(Split completion mask)\n", ehci_sitmsc_scm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ehci_sittsc_t
 * Description: siTD transfer status and control
 * Fields:
 *   _anon0	(size 1, offset 0, init 0):	MBZ	_
 *   sts	(size 1, offset 1, init 0):	RW	Split transaction state
 *   mmf	(size 1, offset 2, init 0):	RW	Missed micro-frame
 *   xacterr	(size 1, offset 3, init 0):	RW	Transaction error
 *   babble	(size 1, offset 4, init 0):	RW	Babble detected
 *   dbe	(size 1, offset 5, init 0):	RW	Data buffer error
 *   err	(size 1, offset 6, init 0):	RW	ERR response rcvd from transaction translator
 *   active	(size 1, offset 7, init 0):	RW	Status active
 *   cpm	(size 8, offset 8, init 0):	RW	Microframe complete-split progress mask
 *   total	(size 10, offset 16, init 0):	RW	Total bytes to transfer
 *   _anon26	(size 4, offset 26, init 0):	MBZ	_
 *   p	(size 1, offset 30, init 0):	RW	Page select
 *   ioc	(size 1, offset 31, init 0):	RW	Interrupt on complete
 */
typedef uint8_t *ehci_sittsc_t;
typedef uint8_t ehci_sittsc_array_t[4];
static const size_t ehci_sittsc_size = sizeof(ehci_sittsc_array_t );
static inline uint8_t ehci_sittsc_sts_extract(ehci_sittsc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_sittsc_sts_extract(ehci_sittsc_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x2) >> 1);
}

static inline void ehci_sittsc_sts_insert(ehci_sittsc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sittsc_sts_insert(ehci_sittsc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xfd) | (0x2 & (_fieldval << 1)));
}

static inline uint8_t ehci_sittsc_mmf_extract(ehci_sittsc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_sittsc_mmf_extract(ehci_sittsc_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x4) >> 2);
}

static inline void ehci_sittsc_mmf_insert(ehci_sittsc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sittsc_mmf_insert(ehci_sittsc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xfb) | (0x4 & (_fieldval << 2)));
}

static inline uint8_t ehci_sittsc_xacterr_extract(ehci_sittsc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_sittsc_xacterr_extract(ehci_sittsc_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x8) >> 3);
}

static inline void ehci_sittsc_xacterr_insert(ehci_sittsc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sittsc_xacterr_insert(ehci_sittsc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xf7) | (0x8 & (_fieldval << 3)));
}

static inline uint8_t ehci_sittsc_babble_extract(ehci_sittsc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_sittsc_babble_extract(ehci_sittsc_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x10) >> 4);
}

static inline void ehci_sittsc_babble_insert(ehci_sittsc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sittsc_babble_insert(ehci_sittsc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xef) | (0x10 & (_fieldval << 4)));
}

static inline uint8_t ehci_sittsc_dbe_extract(ehci_sittsc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_sittsc_dbe_extract(ehci_sittsc_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x20) >> 5);
}

static inline void ehci_sittsc_dbe_insert(ehci_sittsc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sittsc_dbe_insert(ehci_sittsc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xdf) | (0x20 & (_fieldval << 5)));
}

static inline uint8_t ehci_sittsc_err_extract(ehci_sittsc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_sittsc_err_extract(ehci_sittsc_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x40) >> 6);
}

static inline void ehci_sittsc_err_insert(ehci_sittsc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sittsc_err_insert(ehci_sittsc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xbf) | (0x40 & (_fieldval << 6)));
}

static inline uint8_t ehci_sittsc_active_extract(ehci_sittsc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_sittsc_active_extract(ehci_sittsc_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x80) >> 7);
}

static inline void ehci_sittsc_active_insert(ehci_sittsc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sittsc_active_insert(ehci_sittsc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline uint8_t ehci_sittsc_cpm_extract(ehci_sittsc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_sittsc_cpm_extract(ehci_sittsc_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0xff) >> 0);
}

static inline void ehci_sittsc_cpm_insert(ehci_sittsc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sittsc_cpm_insert(ehci_sittsc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0x0) | (0xff & (_fieldval << 0)));
}

static inline uint16_t ehci_sittsc_total_extract(ehci_sittsc_t _dtptr) __attribute__ ((always_inline));
static inline uint16_t ehci_sittsc_total_extract(ehci_sittsc_t _dtptr)
{
    return(((*((uint16_t *)(2 + _dtptr))) & 0x3ff) >> 0);
}

static inline void ehci_sittsc_total_insert(ehci_sittsc_t _dtptr, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sittsc_total_insert(ehci_sittsc_t _dtptr, uint16_t _fieldval)
{
    *((uint16_t *)(2 + _dtptr)) = (((*((uint16_t *)(2 + _dtptr))) & 0xfc00) | (0x3ff & (_fieldval << 0)));
}

static inline uint8_t ehci_sittsc_p_extract(ehci_sittsc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_sittsc_p_extract(ehci_sittsc_t _dtptr)
{
    return(((*((uint8_t *)(3 + _dtptr))) & 0x40) >> 6);
}

static inline void ehci_sittsc_p_insert(ehci_sittsc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sittsc_p_insert(ehci_sittsc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(3 + _dtptr)) = (((*((uint8_t *)(3 + _dtptr))) & 0xbf) | (0x40 & (_fieldval << 6)));
}

static inline uint8_t ehci_sittsc_ioc_extract(ehci_sittsc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_sittsc_ioc_extract(ehci_sittsc_t _dtptr)
{
    return(((*((uint8_t *)(3 + _dtptr))) & 0x80) >> 7);
}

static inline void ehci_sittsc_ioc_insert(ehci_sittsc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sittsc_ioc_insert(ehci_sittsc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(3 + _dtptr)) = (((*((uint8_t *)(3 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline int ehci_sittsc_prtval(char *_s, size_t _size, ehci_sittsc_t _regval) __attribute__ ((always_inline));
static inline int ehci_sittsc_prtval(char *_s, size_t _size, ehci_sittsc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sts =\t%" PRIx8 "\t(Split transaction state)\n", ehci_sittsc_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mmf =\t%" PRIx8 "\t(Missed micro-frame)\n", ehci_sittsc_mmf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xacterr =\t%" PRIx8 "\t(Transaction error)\n", ehci_sittsc_xacterr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " babble =\t%" PRIx8 "\t(Babble detected)\n", ehci_sittsc_babble_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dbe =\t%" PRIx8 "\t(Data buffer error)\n", ehci_sittsc_dbe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " err =\t%" PRIx8 "\t(ERR response rcvd from transaction translator)\n", ehci_sittsc_err_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " active =\t%" PRIx8 "\t(Status active)\n", ehci_sittsc_active_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpm =\t%" PRIx8 "\t(Microframe complete-split progress mask)\n", ehci_sittsc_cpm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " total =\t%" PRIx16 "\t(Total bytes to transfer)\n", ehci_sittsc_total_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p =\t%" PRIx8 "\t(Page select)\n", ehci_sittsc_p_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ioc =\t%" PRIx8 "\t(Interrupt on complete)\n", ehci_sittsc_ioc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ehci_sitbpl0_t
 * Description: siTD buffer page pointer list page 0
 * Fields:
 *   offset	(size 12, offset 0, init 0):	RW	Current offset
 *   p	(size 20, offset 12, init 0):	RW	Buffer pointer (4k aligned)
 */
typedef uint8_t *ehci_sitbpl0_t;
typedef uint8_t ehci_sitbpl0_array_t[4];
static const size_t ehci_sitbpl0_size = sizeof(ehci_sitbpl0_array_t );
static inline uint16_t ehci_sitbpl0_offset_extract(ehci_sitbpl0_t _dtptr) __attribute__ ((always_inline));
static inline uint16_t ehci_sitbpl0_offset_extract(ehci_sitbpl0_t _dtptr)
{
    return(((*((uint16_t *)(0 + _dtptr))) & 0xfff) >> 0);
}

static inline void ehci_sitbpl0_offset_insert(ehci_sitbpl0_t _dtptr, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sitbpl0_offset_insert(ehci_sitbpl0_t _dtptr, uint16_t _fieldval)
{
    *((uint16_t *)(0 + _dtptr)) = (((*((uint16_t *)(0 + _dtptr))) & 0xf000) | (0xfff & (_fieldval << 0)));
}

static inline uint32_t ehci_sitbpl0_p_extract(ehci_sitbpl0_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t ehci_sitbpl0_p_extract(ehci_sitbpl0_t _dtptr)
{
    return(((*((uint32_t *)(0 + _dtptr))) & 0xfffff000) >> 12);
}

static inline void ehci_sitbpl0_p_insert(ehci_sitbpl0_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sitbpl0_p_insert(ehci_sitbpl0_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(0 + _dtptr)) = (((*((uint32_t *)(0 + _dtptr))) & 0xfff) | (0xfffff000 & (_fieldval << 12)));
}

static inline int ehci_sitbpl0_prtval(char *_s, size_t _size, ehci_sitbpl0_t _regval) __attribute__ ((always_inline));
static inline int ehci_sitbpl0_prtval(char *_s, size_t _size, ehci_sitbpl0_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " offset =\t%" PRIx16 "\t(Current offset)\n", ehci_sitbpl0_offset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p =\t%" PRIx32 "\t(Buffer pointer (4k aligned))\n", ehci_sitbpl0_p_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ehci_sitbpl1_t
 * Description: siTD buffer page pointer list page 1
 * Fields:
 *   tc	(size 3, offset 0, init 0):	RW	Transaction count
 *   tp	(size 2, offset 3, init 0):	RW	Transaction position
 *   _anon5	(size 7, offset 5, init 0):	MBZ	_
 *   p	(size 20, offset 12, init 0):	RW	Buffer pointer (4k aligned)
 */
typedef uint8_t *ehci_sitbpl1_t;
typedef uint8_t ehci_sitbpl1_array_t[4];
static const size_t ehci_sitbpl1_size = sizeof(ehci_sitbpl1_array_t );
static inline uint8_t ehci_sitbpl1_tc_extract(ehci_sitbpl1_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_sitbpl1_tc_extract(ehci_sitbpl1_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x7) >> 0);
}

static inline void ehci_sitbpl1_tc_insert(ehci_sitbpl1_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sitbpl1_tc_insert(ehci_sitbpl1_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xf8) | (0x7 & (_fieldval << 0)));
}

static inline ehci_xpos_t ehci_sitbpl1_tp_extract(ehci_sitbpl1_t _dtptr) __attribute__ ((always_inline));
static inline ehci_xpos_t ehci_sitbpl1_tp_extract(ehci_sitbpl1_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x18) >> 3);
}

static inline void ehci_sitbpl1_tp_insert(ehci_sitbpl1_t _dtptr, ehci_xpos_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sitbpl1_tp_insert(ehci_sitbpl1_t _dtptr, ehci_xpos_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xe7) | (0x18 & (_fieldval << 3)));
}

static inline uint32_t ehci_sitbpl1_p_extract(ehci_sitbpl1_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t ehci_sitbpl1_p_extract(ehci_sitbpl1_t _dtptr)
{
    return(((*((uint32_t *)(0 + _dtptr))) & 0xfffff000) >> 12);
}

static inline void ehci_sitbpl1_p_insert(ehci_sitbpl1_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sitbpl1_p_insert(ehci_sitbpl1_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(0 + _dtptr)) = (((*((uint32_t *)(0 + _dtptr))) & 0xfff) | (0xfffff000 & (_fieldval << 12)));
}

static inline int ehci_sitbpl1_prtval(char *_s, size_t _size, ehci_sitbpl1_t _regval) __attribute__ ((always_inline));
static inline int ehci_sitbpl1_prtval(char *_s, size_t _size, ehci_sitbpl1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc =\t%" PRIx8 "\t(Transaction count)\n", ehci_sitbpl1_tc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tp =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_xpos_prtval(_s + _r, _avail, ehci_sitbpl1_tp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Transaction position)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p =\t%" PRIx32 "\t(Buffer pointer (4k aligned))\n", ehci_sitbpl1_p_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ehci_sitblp_t
 * Description: siTD back link pointer
 * Fields:
 *   t	(size 1, offset 0, init 0):	RW	Terminate (0 -> bp is valid)
 *   _anon1	(size 4, offset 1, init 0):	MBZ	_
 *   bp	(size 27, offset 5, init 0):	RW	Back pointer
 */
typedef uint8_t *ehci_sitblp_t;
typedef uint8_t ehci_sitblp_array_t[4];
static const size_t ehci_sitblp_size = sizeof(ehci_sitblp_array_t );
static inline uint8_t ehci_sitblp_t_extract(ehci_sitblp_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_sitblp_t_extract(ehci_sitblp_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x1) >> 0);
}

static inline void ehci_sitblp_t_insert(ehci_sitblp_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sitblp_t_insert(ehci_sitblp_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xfe) | (0x1 & (_fieldval << 0)));
}

static inline uint32_t ehci_sitblp_bp_extract(ehci_sitblp_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t ehci_sitblp_bp_extract(ehci_sitblp_t _dtptr)
{
    return(((*((uint32_t *)(0 + _dtptr))) & 0xffffffe0) >> 5);
}

static inline void ehci_sitblp_bp_insert(ehci_sitblp_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_sitblp_bp_insert(ehci_sitblp_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(0 + _dtptr)) = (((*((uint32_t *)(0 + _dtptr))) & 0x1f) | (0xffffffe0 & (_fieldval << 5)));
}

static inline int ehci_sitblp_prtval(char *_s, size_t _size, ehci_sitblp_t _regval) __attribute__ ((always_inline));
static inline int ehci_sitblp_prtval(char *_s, size_t _size, ehci_sitblp_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " t =\t%" PRIx8 "\t(Terminate (0 -> bp is valid))\n", ehci_sitblp_t_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bp =\t%" PRIx32 "\t(Back pointer)\n", ehci_sitblp_bp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ehci_qtd_t
 * Description: Queue element transfer descriptor
 * Fields:
 *   next	(size 32, offset 0, init 0):	RW	Next element
 *   altnext	(size 32, offset 32, init 0):	RW	Alternate next pointer
 *   token	(size 32, offset 64, init 0):	RW	Token
 *   bp0	(size 32, offset 96, init 0):	RW	Buffer pointer 0
 *   bp1	(size 32, offset 128, init 0):	RW	Buffer pointer 1
 *   bp2	(size 32, offset 160, init 0):	RW	Buffer pointer 2
 *   bp3	(size 32, offset 192, init 0):	RW	Buffer pointer 3
 *   bp4	(size 32, offset 224, init 0):	RW	Buffer pointer 4
 */
typedef uint8_t *ehci_qtd_t;
typedef uint8_t ehci_qtd_array_t[32];
static const size_t ehci_qtd_size = sizeof(ehci_qtd_array_t );
static inline ehci_lp_t ehci_qtd_next_extract(ehci_qtd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_lp_t ehci_qtd_next_extract(ehci_qtd_t _dtptr)
{
    return(((*((uint32_t *)(0 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_qtd_next_insert(ehci_qtd_t _dtptr, ehci_lp_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qtd_next_insert(ehci_qtd_t _dtptr, ehci_lp_t _fieldval)
{
    *((uint32_t *)(0 + _dtptr)) = (((*((uint32_t *)(0 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_lp_t ehci_qtd_altnext_extract(ehci_qtd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_lp_t ehci_qtd_altnext_extract(ehci_qtd_t _dtptr)
{
    return(((*((uint32_t *)(4 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_qtd_altnext_insert(ehci_qtd_t _dtptr, ehci_lp_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qtd_altnext_insert(ehci_qtd_t _dtptr, ehci_lp_t _fieldval)
{
    *((uint32_t *)(4 + _dtptr)) = (((*((uint32_t *)(4 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_qttok_t ehci_qtd_token_extract(ehci_qtd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_qttok_t ehci_qtd_token_extract(ehci_qtd_t _dtptr)
{
    return(((*((uint32_t *)(8 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_qtd_token_insert(ehci_qtd_t _dtptr, ehci_qttok_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qtd_token_insert(ehci_qtd_t _dtptr, ehci_qttok_t _fieldval)
{
    *((uint32_t *)(8 + _dtptr)) = (((*((uint32_t *)(8 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_qtbp0_t ehci_qtd_bp0_extract(ehci_qtd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_qtbp0_t ehci_qtd_bp0_extract(ehci_qtd_t _dtptr)
{
    return(((*((uint32_t *)(12 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_qtd_bp0_insert(ehci_qtd_t _dtptr, ehci_qtbp0_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qtd_bp0_insert(ehci_qtd_t _dtptr, ehci_qtbp0_t _fieldval)
{
    *((uint32_t *)(12 + _dtptr)) = (((*((uint32_t *)(12 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_qtbp1_t ehci_qtd_bp1_extract(ehci_qtd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_qtbp1_t ehci_qtd_bp1_extract(ehci_qtd_t _dtptr)
{
    return(((*((uint32_t *)(16 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_qtd_bp1_insert(ehci_qtd_t _dtptr, ehci_qtbp1_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qtd_bp1_insert(ehci_qtd_t _dtptr, ehci_qtbp1_t _fieldval)
{
    *((uint32_t *)(16 + _dtptr)) = (((*((uint32_t *)(16 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_qtbp1_t ehci_qtd_bp2_extract(ehci_qtd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_qtbp1_t ehci_qtd_bp2_extract(ehci_qtd_t _dtptr)
{
    return(((*((uint32_t *)(20 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_qtd_bp2_insert(ehci_qtd_t _dtptr, ehci_qtbp1_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qtd_bp2_insert(ehci_qtd_t _dtptr, ehci_qtbp1_t _fieldval)
{
    *((uint32_t *)(20 + _dtptr)) = (((*((uint32_t *)(20 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_qtbp1_t ehci_qtd_bp3_extract(ehci_qtd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_qtbp1_t ehci_qtd_bp3_extract(ehci_qtd_t _dtptr)
{
    return(((*((uint32_t *)(24 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_qtd_bp3_insert(ehci_qtd_t _dtptr, ehci_qtbp1_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qtd_bp3_insert(ehci_qtd_t _dtptr, ehci_qtbp1_t _fieldval)
{
    *((uint32_t *)(24 + _dtptr)) = (((*((uint32_t *)(24 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_qtbp1_t ehci_qtd_bp4_extract(ehci_qtd_t _dtptr) __attribute__ ((always_inline));
static inline ehci_qtbp1_t ehci_qtd_bp4_extract(ehci_qtd_t _dtptr)
{
    return(((*((uint32_t *)(28 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_qtd_bp4_insert(ehci_qtd_t _dtptr, ehci_qtbp1_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qtd_bp4_insert(ehci_qtd_t _dtptr, ehci_qtbp1_t _fieldval)
{
    *((uint32_t *)(28 + _dtptr)) = (((*((uint32_t *)(28 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline int ehci_qtd_prtval(char *_s, size_t _size, ehci_qtd_t _regval) __attribute__ ((always_inline));
static inline int ehci_qtd_prtval(char *_s, size_t _size, ehci_qtd_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " next =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_lp_prtval(_s + _r, _avail, ehci_qtd_next_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Next element)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " altnext =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_lp_prtval(_s + _r, _avail, ehci_qtd_altnext_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Alternate next pointer)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " token =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_qttok_prtval(_s + _r, _avail, ehci_qtd_token_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Token)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bp0 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_qtbp0_prtval(_s + _r, _avail, ehci_qtd_bp0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Buffer pointer 0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bp1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_qtbp1_prtval(_s + _r, _avail, ehci_qtd_bp1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Buffer pointer 1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bp2 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_qtbp1_prtval(_s + _r, _avail, ehci_qtd_bp2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Buffer pointer 2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bp3 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_qtbp1_prtval(_s + _r, _avail, ehci_qtd_bp3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Buffer pointer 3)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bp4 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_qtbp1_prtval(_s + _r, _avail, ehci_qtd_bp4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Buffer pointer 4)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ehci_qttok_t
 * Description: qTD Token
 * Fields:
 *   ping	(size 1, offset 0, init 0):	RW	Ping state
 *   sts	(size 1, offset 1, init 0):	RW	Split transaction state
 *   mmf	(size 1, offset 2, init 0):	RW	Missed micro-frame
 *   xacterr	(size 1, offset 3, init 0):	RW	Transaction error
 *   babble	(size 1, offset 4, init 0):	RW	Babble detected
 *   dbe	(size 1, offset 5, init 0):	RW	Data buffer error
 *   halted	(size 1, offset 6, init 0):	RW	Serious error at endpoint
 *   active	(size 1, offset 7, init 0):	RW	Status active
 *   pidc	(size 2, offset 8, init 0):	RW	PID code token
 *   cerr	(size 2, offset 10, init 0):	RW	Error counter
 *   cp	(size 3, offset 12, init 0):	RW	Current page
 *   ioc	(size 1, offset 15, init 0):	RW	Interrupt on complete
 *   tbt	(size 15, offset 16, init 0):	RW	Total bytes to transfer
 *   toggle	(size 1, offset 31, init 0):	RW	Data toggle
 */
typedef uint8_t *ehci_qttok_t;
typedef uint8_t ehci_qttok_array_t[4];
static const size_t ehci_qttok_size = sizeof(ehci_qttok_array_t );
static inline uint8_t ehci_qttok_ping_extract(ehci_qttok_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qttok_ping_extract(ehci_qttok_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x1) >> 0);
}

static inline void ehci_qttok_ping_insert(ehci_qttok_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qttok_ping_insert(ehci_qttok_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xfe) | (0x1 & (_fieldval << 0)));
}

static inline uint8_t ehci_qttok_sts_extract(ehci_qttok_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qttok_sts_extract(ehci_qttok_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x2) >> 1);
}

static inline void ehci_qttok_sts_insert(ehci_qttok_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qttok_sts_insert(ehci_qttok_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xfd) | (0x2 & (_fieldval << 1)));
}

static inline uint8_t ehci_qttok_mmf_extract(ehci_qttok_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qttok_mmf_extract(ehci_qttok_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x4) >> 2);
}

static inline void ehci_qttok_mmf_insert(ehci_qttok_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qttok_mmf_insert(ehci_qttok_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xfb) | (0x4 & (_fieldval << 2)));
}

static inline uint8_t ehci_qttok_xacterr_extract(ehci_qttok_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qttok_xacterr_extract(ehci_qttok_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x8) >> 3);
}

static inline void ehci_qttok_xacterr_insert(ehci_qttok_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qttok_xacterr_insert(ehci_qttok_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xf7) | (0x8 & (_fieldval << 3)));
}

static inline uint8_t ehci_qttok_babble_extract(ehci_qttok_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qttok_babble_extract(ehci_qttok_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x10) >> 4);
}

static inline void ehci_qttok_babble_insert(ehci_qttok_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qttok_babble_insert(ehci_qttok_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xef) | (0x10 & (_fieldval << 4)));
}

static inline uint8_t ehci_qttok_dbe_extract(ehci_qttok_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qttok_dbe_extract(ehci_qttok_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x20) >> 5);
}

static inline void ehci_qttok_dbe_insert(ehci_qttok_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qttok_dbe_insert(ehci_qttok_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xdf) | (0x20 & (_fieldval << 5)));
}

static inline uint8_t ehci_qttok_halted_extract(ehci_qttok_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qttok_halted_extract(ehci_qttok_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x40) >> 6);
}

static inline void ehci_qttok_halted_insert(ehci_qttok_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qttok_halted_insert(ehci_qttok_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xbf) | (0x40 & (_fieldval << 6)));
}

static inline uint8_t ehci_qttok_active_extract(ehci_qttok_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qttok_active_extract(ehci_qttok_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x80) >> 7);
}

static inline void ehci_qttok_active_insert(ehci_qttok_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qttok_active_insert(ehci_qttok_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline ehci_pid_t ehci_qttok_pidc_extract(ehci_qttok_t _dtptr) __attribute__ ((always_inline));
static inline ehci_pid_t ehci_qttok_pidc_extract(ehci_qttok_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x3) >> 0);
}

static inline void ehci_qttok_pidc_insert(ehci_qttok_t _dtptr, ehci_pid_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qttok_pidc_insert(ehci_qttok_t _dtptr, ehci_pid_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xfc) | (0x3 & (_fieldval << 0)));
}

static inline uint8_t ehci_qttok_cerr_extract(ehci_qttok_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qttok_cerr_extract(ehci_qttok_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0xc) >> 2);
}

static inline void ehci_qttok_cerr_insert(ehci_qttok_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qttok_cerr_insert(ehci_qttok_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xf3) | (0xc & (_fieldval << 2)));
}

static inline uint8_t ehci_qttok_cp_extract(ehci_qttok_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qttok_cp_extract(ehci_qttok_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x70) >> 4);
}

static inline void ehci_qttok_cp_insert(ehci_qttok_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qttok_cp_insert(ehci_qttok_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0x8f) | (0x70 & (_fieldval << 4)));
}

static inline uint8_t ehci_qttok_ioc_extract(ehci_qttok_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qttok_ioc_extract(ehci_qttok_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x80) >> 7);
}

static inline void ehci_qttok_ioc_insert(ehci_qttok_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qttok_ioc_insert(ehci_qttok_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline uint16_t ehci_qttok_tbt_extract(ehci_qttok_t _dtptr) __attribute__ ((always_inline));
static inline uint16_t ehci_qttok_tbt_extract(ehci_qttok_t _dtptr)
{
    return(((*((uint16_t *)(2 + _dtptr))) & 0x7fff) >> 0);
}

static inline void ehci_qttok_tbt_insert(ehci_qttok_t _dtptr, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qttok_tbt_insert(ehci_qttok_t _dtptr, uint16_t _fieldval)
{
    *((uint16_t *)(2 + _dtptr)) = (((*((uint16_t *)(2 + _dtptr))) & 0x8000) | (0x7fff & (_fieldval << 0)));
}

static inline uint8_t ehci_qttok_toggle_extract(ehci_qttok_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qttok_toggle_extract(ehci_qttok_t _dtptr)
{
    return(((*((uint8_t *)(3 + _dtptr))) & 0x80) >> 7);
}

static inline void ehci_qttok_toggle_insert(ehci_qttok_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qttok_toggle_insert(ehci_qttok_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(3 + _dtptr)) = (((*((uint8_t *)(3 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline int ehci_qttok_prtval(char *_s, size_t _size, ehci_qttok_t _regval) __attribute__ ((always_inline));
static inline int ehci_qttok_prtval(char *_s, size_t _size, ehci_qttok_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ping =\t%" PRIx8 "\t(Ping state)\n", ehci_qttok_ping_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sts =\t%" PRIx8 "\t(Split transaction state)\n", ehci_qttok_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mmf =\t%" PRIx8 "\t(Missed micro-frame)\n", ehci_qttok_mmf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xacterr =\t%" PRIx8 "\t(Transaction error)\n", ehci_qttok_xacterr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " babble =\t%" PRIx8 "\t(Babble detected)\n", ehci_qttok_babble_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dbe =\t%" PRIx8 "\t(Data buffer error)\n", ehci_qttok_dbe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " halted =\t%" PRIx8 "\t(Serious error at endpoint)\n", ehci_qttok_halted_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " active =\t%" PRIx8 "\t(Status active)\n", ehci_qttok_active_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pidc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_pid_prtval(_s + _r, _avail, ehci_qttok_pidc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(PID code token)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cerr =\t%" PRIx8 "\t(Error counter)\n", ehci_qttok_cerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cp =\t%" PRIx8 "\t(Current page)\n", ehci_qttok_cp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ioc =\t%" PRIx8 "\t(Interrupt on complete)\n", ehci_qttok_ioc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tbt =\t%" PRIx16 "\t(Total bytes to transfer)\n", ehci_qttok_tbt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " toggle =\t%" PRIx8 "\t(Data toggle)\n", ehci_qttok_toggle_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ehci_qtbp0_t
 * Description: Queue element buffer pointer page 0
 * Fields:
 *   offset	(size 12, offset 0, init 0):	RW	Current offset
 *   p	(size 20, offset 12, init 0):	RW	Buffer pointer (4k aligned)
 */
typedef uint8_t *ehci_qtbp0_t;
typedef uint8_t ehci_qtbp0_array_t[4];
static const size_t ehci_qtbp0_size = sizeof(ehci_qtbp0_array_t );
static inline uint16_t ehci_qtbp0_offset_extract(ehci_qtbp0_t _dtptr) __attribute__ ((always_inline));
static inline uint16_t ehci_qtbp0_offset_extract(ehci_qtbp0_t _dtptr)
{
    return(((*((uint16_t *)(0 + _dtptr))) & 0xfff) >> 0);
}

static inline void ehci_qtbp0_offset_insert(ehci_qtbp0_t _dtptr, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qtbp0_offset_insert(ehci_qtbp0_t _dtptr, uint16_t _fieldval)
{
    *((uint16_t *)(0 + _dtptr)) = (((*((uint16_t *)(0 + _dtptr))) & 0xf000) | (0xfff & (_fieldval << 0)));
}

static inline uint32_t ehci_qtbp0_p_extract(ehci_qtbp0_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t ehci_qtbp0_p_extract(ehci_qtbp0_t _dtptr)
{
    return(((*((uint32_t *)(0 + _dtptr))) & 0xfffff000) >> 12);
}

static inline void ehci_qtbp0_p_insert(ehci_qtbp0_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qtbp0_p_insert(ehci_qtbp0_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(0 + _dtptr)) = (((*((uint32_t *)(0 + _dtptr))) & 0xfff) | (0xfffff000 & (_fieldval << 12)));
}

static inline int ehci_qtbp0_prtval(char *_s, size_t _size, ehci_qtbp0_t _regval) __attribute__ ((always_inline));
static inline int ehci_qtbp0_prtval(char *_s, size_t _size, ehci_qtbp0_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " offset =\t%" PRIx16 "\t(Current offset)\n", ehci_qtbp0_offset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p =\t%" PRIx32 "\t(Buffer pointer (4k aligned))\n", ehci_qtbp0_p_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ehci_qtbp1_t
 * Description: Queue element buffer pointer page 1
 * Fields:
 *   _anon0	(size 12, offset 0, init 0):	MBZ	_
 *   p	(size 20, offset 12, init 0):	RW	Buffer pointer (4k aligned)
 */
typedef uint8_t *ehci_qtbp1_t;
typedef uint8_t ehci_qtbp1_array_t[4];
static const size_t ehci_qtbp1_size = sizeof(ehci_qtbp1_array_t );
static inline uint32_t ehci_qtbp1_p_extract(ehci_qtbp1_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t ehci_qtbp1_p_extract(ehci_qtbp1_t _dtptr)
{
    return(((*((uint32_t *)(0 + _dtptr))) & 0xfffff000) >> 12);
}

static inline void ehci_qtbp1_p_insert(ehci_qtbp1_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qtbp1_p_insert(ehci_qtbp1_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(0 + _dtptr)) = (((*((uint32_t *)(0 + _dtptr))) & 0xfff) | (0xfffff000 & (_fieldval << 12)));
}

static inline int ehci_qtbp1_prtval(char *_s, size_t _size, ehci_qtbp1_t _regval) __attribute__ ((always_inline));
static inline int ehci_qtbp1_prtval(char *_s, size_t _size, ehci_qtbp1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p =\t%" PRIx32 "\t(Buffer pointer (4k aligned))\n", ehci_qtbp1_p_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ehci_qh_t
 * Description: Queue head
 * Fields:
 *   hlp	(size 32, offset 0, init 0):	RW	Horizontal link pointer
 *   cap1	(size 32, offset 32, init 0):	RW	Endpoint capabilities/characteristics 1
 *   cap2	(size 32, offset 64, init 0):	RW	Endpoint capabilities/characteristics 2
 *   current	(size 32, offset 96, init 0):	RW	Current element
 *   next	(size 32, offset 128, init 0):	RW	Next element
 *   altnext	(size 32, offset 160, init 0):	RW	Alternate next pointer
 *   token	(size 32, offset 192, init 0):	RW	Token
 *   bp0	(size 32, offset 224, init 0):	RW	Buffer pointer 0
 *   bp1	(size 32, offset 256, init 0):	RW	Buffer pointer 1
 *   bp2	(size 32, offset 288, init 0):	RW	Buffer pointer 2
 *   bp3	(size 32, offset 320, init 0):	RW	Buffer pointer 3
 *   bp4	(size 32, offset 352, init 0):	RW	Buffer pointer 4
 */
typedef uint8_t *ehci_qh_t;
typedef uint8_t ehci_qh_array_t[48];
static const size_t ehci_qh_size = sizeof(ehci_qh_array_t );
static inline ehci_lp_t ehci_qh_hlp_extract(ehci_qh_t _dtptr) __attribute__ ((always_inline));
static inline ehci_lp_t ehci_qh_hlp_extract(ehci_qh_t _dtptr)
{
    return(((*((uint32_t *)(0 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_qh_hlp_insert(ehci_qh_t _dtptr, ehci_lp_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qh_hlp_insert(ehci_qh_t _dtptr, ehci_lp_t _fieldval)
{
    *((uint32_t *)(0 + _dtptr)) = (((*((uint32_t *)(0 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_qhcap1_t ehci_qh_cap1_extract(ehci_qh_t _dtptr) __attribute__ ((always_inline));
static inline ehci_qhcap1_t ehci_qh_cap1_extract(ehci_qh_t _dtptr)
{
    return(((*((uint32_t *)(4 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_qh_cap1_insert(ehci_qh_t _dtptr, ehci_qhcap1_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qh_cap1_insert(ehci_qh_t _dtptr, ehci_qhcap1_t _fieldval)
{
    *((uint32_t *)(4 + _dtptr)) = (((*((uint32_t *)(4 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_qhcap2_t ehci_qh_cap2_extract(ehci_qh_t _dtptr) __attribute__ ((always_inline));
static inline ehci_qhcap2_t ehci_qh_cap2_extract(ehci_qh_t _dtptr)
{
    return(((*((uint32_t *)(8 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_qh_cap2_insert(ehci_qh_t _dtptr, ehci_qhcap2_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qh_cap2_insert(ehci_qh_t _dtptr, ehci_qhcap2_t _fieldval)
{
    *((uint32_t *)(8 + _dtptr)) = (((*((uint32_t *)(8 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_lp_t ehci_qh_current_extract(ehci_qh_t _dtptr) __attribute__ ((always_inline));
static inline ehci_lp_t ehci_qh_current_extract(ehci_qh_t _dtptr)
{
    return(((*((uint32_t *)(12 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_qh_current_insert(ehci_qh_t _dtptr, ehci_lp_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qh_current_insert(ehci_qh_t _dtptr, ehci_lp_t _fieldval)
{
    *((uint32_t *)(12 + _dtptr)) = (((*((uint32_t *)(12 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_lp_t ehci_qh_next_extract(ehci_qh_t _dtptr) __attribute__ ((always_inline));
static inline ehci_lp_t ehci_qh_next_extract(ehci_qh_t _dtptr)
{
    return(((*((uint32_t *)(16 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_qh_next_insert(ehci_qh_t _dtptr, ehci_lp_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qh_next_insert(ehci_qh_t _dtptr, ehci_lp_t _fieldval)
{
    *((uint32_t *)(16 + _dtptr)) = (((*((uint32_t *)(16 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_qhlp_t ehci_qh_altnext_extract(ehci_qh_t _dtptr) __attribute__ ((always_inline));
static inline ehci_qhlp_t ehci_qh_altnext_extract(ehci_qh_t _dtptr)
{
    return(((*((uint32_t *)(20 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_qh_altnext_insert(ehci_qh_t _dtptr, ehci_qhlp_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qh_altnext_insert(ehci_qh_t _dtptr, ehci_qhlp_t _fieldval)
{
    *((uint32_t *)(20 + _dtptr)) = (((*((uint32_t *)(20 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_qttok_t ehci_qh_token_extract(ehci_qh_t _dtptr) __attribute__ ((always_inline));
static inline ehci_qttok_t ehci_qh_token_extract(ehci_qh_t _dtptr)
{
    return(((*((uint32_t *)(24 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_qh_token_insert(ehci_qh_t _dtptr, ehci_qttok_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qh_token_insert(ehci_qh_t _dtptr, ehci_qttok_t _fieldval)
{
    *((uint32_t *)(24 + _dtptr)) = (((*((uint32_t *)(24 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_qtbp0_t ehci_qh_bp0_extract(ehci_qh_t _dtptr) __attribute__ ((always_inline));
static inline ehci_qtbp0_t ehci_qh_bp0_extract(ehci_qh_t _dtptr)
{
    return(((*((uint32_t *)(28 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_qh_bp0_insert(ehci_qh_t _dtptr, ehci_qtbp0_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qh_bp0_insert(ehci_qh_t _dtptr, ehci_qtbp0_t _fieldval)
{
    *((uint32_t *)(28 + _dtptr)) = (((*((uint32_t *)(28 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_qhbp1_t ehci_qh_bp1_extract(ehci_qh_t _dtptr) __attribute__ ((always_inline));
static inline ehci_qhbp1_t ehci_qh_bp1_extract(ehci_qh_t _dtptr)
{
    return(((*((uint32_t *)(32 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_qh_bp1_insert(ehci_qh_t _dtptr, ehci_qhbp1_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qh_bp1_insert(ehci_qh_t _dtptr, ehci_qhbp1_t _fieldval)
{
    *((uint32_t *)(32 + _dtptr)) = (((*((uint32_t *)(32 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_qhbp2_t ehci_qh_bp2_extract(ehci_qh_t _dtptr) __attribute__ ((always_inline));
static inline ehci_qhbp2_t ehci_qh_bp2_extract(ehci_qh_t _dtptr)
{
    return(((*((uint32_t *)(36 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_qh_bp2_insert(ehci_qh_t _dtptr, ehci_qhbp2_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qh_bp2_insert(ehci_qh_t _dtptr, ehci_qhbp2_t _fieldval)
{
    *((uint32_t *)(36 + _dtptr)) = (((*((uint32_t *)(36 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_qtbp1_t ehci_qh_bp3_extract(ehci_qh_t _dtptr) __attribute__ ((always_inline));
static inline ehci_qtbp1_t ehci_qh_bp3_extract(ehci_qh_t _dtptr)
{
    return(((*((uint32_t *)(40 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_qh_bp3_insert(ehci_qh_t _dtptr, ehci_qtbp1_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qh_bp3_insert(ehci_qh_t _dtptr, ehci_qtbp1_t _fieldval)
{
    *((uint32_t *)(40 + _dtptr)) = (((*((uint32_t *)(40 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_qtbp1_t ehci_qh_bp4_extract(ehci_qh_t _dtptr) __attribute__ ((always_inline));
static inline ehci_qtbp1_t ehci_qh_bp4_extract(ehci_qh_t _dtptr)
{
    return(((*((uint32_t *)(44 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_qh_bp4_insert(ehci_qh_t _dtptr, ehci_qtbp1_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qh_bp4_insert(ehci_qh_t _dtptr, ehci_qtbp1_t _fieldval)
{
    *((uint32_t *)(44 + _dtptr)) = (((*((uint32_t *)(44 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline int ehci_qh_prtval(char *_s, size_t _size, ehci_qh_t _regval) __attribute__ ((always_inline));
static inline int ehci_qh_prtval(char *_s, size_t _size, ehci_qh_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hlp =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_lp_prtval(_s + _r, _avail, ehci_qh_hlp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Horizontal link pointer)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cap1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_qhcap1_prtval(_s + _r, _avail, ehci_qh_cap1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Endpoint capabilities/characteristics 1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cap2 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_qhcap2_prtval(_s + _r, _avail, ehci_qh_cap2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Endpoint capabilities/characteristics 2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " current =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_lp_prtval(_s + _r, _avail, ehci_qh_current_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Current element)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " next =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_lp_prtval(_s + _r, _avail, ehci_qh_next_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Next element)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " altnext =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_qhlp_prtval(_s + _r, _avail, ehci_qh_altnext_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Alternate next pointer)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " token =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_qttok_prtval(_s + _r, _avail, ehci_qh_token_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Token)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bp0 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_qtbp0_prtval(_s + _r, _avail, ehci_qh_bp0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Buffer pointer 0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bp1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_qhbp1_prtval(_s + _r, _avail, ehci_qh_bp1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Buffer pointer 1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bp2 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_qhbp2_prtval(_s + _r, _avail, ehci_qh_bp2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Buffer pointer 2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bp3 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_qtbp1_prtval(_s + _r, _avail, ehci_qh_bp3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Buffer pointer 3)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bp4 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_qtbp1_prtval(_s + _r, _avail, ehci_qh_bp4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Buffer pointer 4)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ehci_qhcap1_t
 * Description: Endpoint capabilities: queue head word 1
 * Fields:
 *   da	(size 7, offset 0, init 0):	RW	Device address
 *   i	(size 1, offset 7, init 0):	RW	Inactivate on next transaction
 *   epn	(size 4, offset 8, init 0):	RW	Endpoint number
 *   eps	(size 2, offset 12, init 0):	RW	Endpoint speed
 *   dtc	(size 1, offset 14, init 0):	RW	Data toggle control
 *   h	(size 1, offset 15, init 0):	RW	Head of reclamation list flag
 *   mpl	(size 11, offset 16, init 0):	RW	Maximum packet length
 *   c	(size 1, offset 27, init 0):	RW	Control endpoint flag
 *   rl	(size 4, offset 28, init 0):	RW	NAK count reload
 */
typedef uint8_t *ehci_qhcap1_t;
typedef uint8_t ehci_qhcap1_array_t[4];
static const size_t ehci_qhcap1_size = sizeof(ehci_qhcap1_array_t );
static inline uint8_t ehci_qhcap1_da_extract(ehci_qhcap1_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qhcap1_da_extract(ehci_qhcap1_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x7f) >> 0);
}

static inline void ehci_qhcap1_da_insert(ehci_qhcap1_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qhcap1_da_insert(ehci_qhcap1_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0x80) | (0x7f & (_fieldval << 0)));
}

static inline uint8_t ehci_qhcap1_i_extract(ehci_qhcap1_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qhcap1_i_extract(ehci_qhcap1_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x80) >> 7);
}

static inline void ehci_qhcap1_i_insert(ehci_qhcap1_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qhcap1_i_insert(ehci_qhcap1_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline uint8_t ehci_qhcap1_epn_extract(ehci_qhcap1_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qhcap1_epn_extract(ehci_qhcap1_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0xf) >> 0);
}

static inline void ehci_qhcap1_epn_insert(ehci_qhcap1_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qhcap1_epn_insert(ehci_qhcap1_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xf0) | (0xf & (_fieldval << 0)));
}

static inline ehci_speed_t ehci_qhcap1_eps_extract(ehci_qhcap1_t _dtptr) __attribute__ ((always_inline));
static inline ehci_speed_t ehci_qhcap1_eps_extract(ehci_qhcap1_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x30) >> 4);
}

static inline void ehci_qhcap1_eps_insert(ehci_qhcap1_t _dtptr, ehci_speed_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qhcap1_eps_insert(ehci_qhcap1_t _dtptr, ehci_speed_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xcf) | (0x30 & (_fieldval << 4)));
}

static inline uint8_t ehci_qhcap1_dtc_extract(ehci_qhcap1_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qhcap1_dtc_extract(ehci_qhcap1_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x40) >> 6);
}

static inline void ehci_qhcap1_dtc_insert(ehci_qhcap1_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qhcap1_dtc_insert(ehci_qhcap1_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xbf) | (0x40 & (_fieldval << 6)));
}

static inline uint8_t ehci_qhcap1_h_extract(ehci_qhcap1_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qhcap1_h_extract(ehci_qhcap1_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x80) >> 7);
}

static inline void ehci_qhcap1_h_insert(ehci_qhcap1_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qhcap1_h_insert(ehci_qhcap1_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline uint16_t ehci_qhcap1_mpl_extract(ehci_qhcap1_t _dtptr) __attribute__ ((always_inline));
static inline uint16_t ehci_qhcap1_mpl_extract(ehci_qhcap1_t _dtptr)
{
    return(((*((uint16_t *)(2 + _dtptr))) & 0x7ff) >> 0);
}

static inline void ehci_qhcap1_mpl_insert(ehci_qhcap1_t _dtptr, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qhcap1_mpl_insert(ehci_qhcap1_t _dtptr, uint16_t _fieldval)
{
    *((uint16_t *)(2 + _dtptr)) = (((*((uint16_t *)(2 + _dtptr))) & 0xf800) | (0x7ff & (_fieldval << 0)));
}

static inline uint8_t ehci_qhcap1_c_extract(ehci_qhcap1_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qhcap1_c_extract(ehci_qhcap1_t _dtptr)
{
    return(((*((uint8_t *)(3 + _dtptr))) & 0x8) >> 3);
}

static inline void ehci_qhcap1_c_insert(ehci_qhcap1_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qhcap1_c_insert(ehci_qhcap1_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(3 + _dtptr)) = (((*((uint8_t *)(3 + _dtptr))) & 0xf7) | (0x8 & (_fieldval << 3)));
}

static inline uint8_t ehci_qhcap1_rl_extract(ehci_qhcap1_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qhcap1_rl_extract(ehci_qhcap1_t _dtptr)
{
    return(((*((uint8_t *)(3 + _dtptr))) & 0xf0) >> 4);
}

static inline void ehci_qhcap1_rl_insert(ehci_qhcap1_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qhcap1_rl_insert(ehci_qhcap1_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(3 + _dtptr)) = (((*((uint8_t *)(3 + _dtptr))) & 0xf) | (0xf0 & (_fieldval << 4)));
}

static inline int ehci_qhcap1_prtval(char *_s, size_t _size, ehci_qhcap1_t _regval) __attribute__ ((always_inline));
static inline int ehci_qhcap1_prtval(char *_s, size_t _size, ehci_qhcap1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " da =\t%" PRIx8 "\t(Device address)\n", ehci_qhcap1_da_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i =\t%" PRIx8 "\t(Inactivate on next transaction)\n", ehci_qhcap1_i_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " epn =\t%" PRIx8 "\t(Endpoint number)\n", ehci_qhcap1_epn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eps =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_speed_prtval(_s + _r, _avail, ehci_qhcap1_eps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Endpoint speed)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dtc =\t%" PRIx8 "\t(Data toggle control)\n", ehci_qhcap1_dtc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " h =\t%" PRIx8 "\t(Head of reclamation list flag)\n", ehci_qhcap1_h_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mpl =\t%" PRIx16 "\t(Maximum packet length)\n", ehci_qhcap1_mpl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " c =\t%" PRIx8 "\t(Control endpoint flag)\n", ehci_qhcap1_c_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rl =\t%" PRIx8 "\t(NAK count reload)\n", ehci_qhcap1_rl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ehci_qhcap2_t
 * Description: Endpoint capabilities: queue head word 2
 * Fields:
 *   ism	(size 8, offset 0, init 0):	RW	Interrupt schedule mask
 *   scm	(size 8, offset 8, init 0):	RW	Split completion mask
 *   hub	(size 7, offset 16, init 0):	RW	Hub address
 *   port	(size 7, offset 23, init 0):	RW	Port number
 *   mult	(size 2, offset 30, init 0):	RW	High-bandwidth pipe multiplier
 */
typedef uint8_t *ehci_qhcap2_t;
typedef uint8_t ehci_qhcap2_array_t[4];
static const size_t ehci_qhcap2_size = sizeof(ehci_qhcap2_array_t );
static inline uint8_t ehci_qhcap2_ism_extract(ehci_qhcap2_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qhcap2_ism_extract(ehci_qhcap2_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0xff) >> 0);
}

static inline void ehci_qhcap2_ism_insert(ehci_qhcap2_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qhcap2_ism_insert(ehci_qhcap2_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0x0) | (0xff & (_fieldval << 0)));
}

static inline uint8_t ehci_qhcap2_scm_extract(ehci_qhcap2_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qhcap2_scm_extract(ehci_qhcap2_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0xff) >> 0);
}

static inline void ehci_qhcap2_scm_insert(ehci_qhcap2_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qhcap2_scm_insert(ehci_qhcap2_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0x0) | (0xff & (_fieldval << 0)));
}

static inline uint8_t ehci_qhcap2_hub_extract(ehci_qhcap2_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qhcap2_hub_extract(ehci_qhcap2_t _dtptr)
{
    return(((*((uint8_t *)(2 + _dtptr))) & 0x7f) >> 0);
}

static inline void ehci_qhcap2_hub_insert(ehci_qhcap2_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qhcap2_hub_insert(ehci_qhcap2_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(2 + _dtptr)) = (((*((uint8_t *)(2 + _dtptr))) & 0x80) | (0x7f & (_fieldval << 0)));
}

static inline uint8_t ehci_qhcap2_port_extract(ehci_qhcap2_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qhcap2_port_extract(ehci_qhcap2_t _dtptr)
{
    return(((*((uint16_t *)(2 + _dtptr))) & 0x3f80) >> 7);
}

static inline void ehci_qhcap2_port_insert(ehci_qhcap2_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qhcap2_port_insert(ehci_qhcap2_t _dtptr, uint8_t _fieldval)
{
    *((uint16_t *)(2 + _dtptr)) = (((*((uint16_t *)(2 + _dtptr))) & 0xc07f) | (0x3f80 & (_fieldval << 7)));
}

static inline uint8_t ehci_qhcap2_mult_extract(ehci_qhcap2_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qhcap2_mult_extract(ehci_qhcap2_t _dtptr)
{
    return(((*((uint8_t *)(3 + _dtptr))) & 0xc0) >> 6);
}

static inline void ehci_qhcap2_mult_insert(ehci_qhcap2_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qhcap2_mult_insert(ehci_qhcap2_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(3 + _dtptr)) = (((*((uint8_t *)(3 + _dtptr))) & 0x3f) | (0xc0 & (_fieldval << 6)));
}

static inline int ehci_qhcap2_prtval(char *_s, size_t _size, ehci_qhcap2_t _regval) __attribute__ ((always_inline));
static inline int ehci_qhcap2_prtval(char *_s, size_t _size, ehci_qhcap2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ism =\t%" PRIx8 "\t(Interrupt schedule mask)\n", ehci_qhcap2_ism_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " scm =\t%" PRIx8 "\t(Split completion mask)\n", ehci_qhcap2_scm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hub =\t%" PRIx8 "\t(Hub address)\n", ehci_qhcap2_hub_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " port =\t%" PRIx8 "\t(Port number)\n", ehci_qhcap2_port_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mult =\t%" PRIx8 "\t(High-bandwidth pipe multiplier)\n", ehci_qhcap2_mult_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ehci_qhlpa_t
 * Description: Alternate queue head link pointer
 * Fields:
 *   t	(size 1, offset 0, init 0):	RW	Pointer value invalid
 *   nakcnt	(size 4, offset 1, init 0):	RW	NACK counter
 *   p	(size 27, offset 5, init 0):	RW	Frame list link pointer
 */
typedef uint8_t *ehci_qhlpa_t;
typedef uint8_t ehci_qhlpa_array_t[4];
static const size_t ehci_qhlpa_size = sizeof(ehci_qhlpa_array_t );
static inline uint8_t ehci_qhlpa_t_extract(ehci_qhlpa_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qhlpa_t_extract(ehci_qhlpa_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x1) >> 0);
}

static inline void ehci_qhlpa_t_insert(ehci_qhlpa_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qhlpa_t_insert(ehci_qhlpa_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xfe) | (0x1 & (_fieldval << 0)));
}

static inline uint8_t ehci_qhlpa_nakcnt_extract(ehci_qhlpa_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qhlpa_nakcnt_extract(ehci_qhlpa_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x1e) >> 1);
}

static inline void ehci_qhlpa_nakcnt_insert(ehci_qhlpa_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qhlpa_nakcnt_insert(ehci_qhlpa_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xe1) | (0x1e & (_fieldval << 1)));
}

static inline uint32_t ehci_qhlpa_p_extract(ehci_qhlpa_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t ehci_qhlpa_p_extract(ehci_qhlpa_t _dtptr)
{
    return(((*((uint32_t *)(0 + _dtptr))) & 0xffffffe0) >> 5);
}

static inline void ehci_qhlpa_p_insert(ehci_qhlpa_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qhlpa_p_insert(ehci_qhlpa_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(0 + _dtptr)) = (((*((uint32_t *)(0 + _dtptr))) & 0x1f) | (0xffffffe0 & (_fieldval << 5)));
}

static inline int ehci_qhlpa_prtval(char *_s, size_t _size, ehci_qhlpa_t _regval) __attribute__ ((always_inline));
static inline int ehci_qhlpa_prtval(char *_s, size_t _size, ehci_qhlpa_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " t =\t%" PRIx8 "\t(Pointer value invalid)\n", ehci_qhlpa_t_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nakcnt =\t%" PRIx8 "\t(NACK counter)\n", ehci_qhlpa_nakcnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p =\t%" PRIx32 "\t(Frame list link pointer)\n", ehci_qhlpa_p_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ehci_qhbp1_t
 * Description: Queue head buffer pointer page 1
 * Fields:
 *   cpm	(size 8, offset 0, init 0):	RW	Split-transaction complete-split progress
 *   _anon8	(size 4, offset 8, init 0):	MBZ	_
 *   p	(size 20, offset 12, init 0):	RW	Buffer pointer (4k aligned)
 */
typedef uint8_t *ehci_qhbp1_t;
typedef uint8_t ehci_qhbp1_array_t[4];
static const size_t ehci_qhbp1_size = sizeof(ehci_qhbp1_array_t );
static inline uint8_t ehci_qhbp1_cpm_extract(ehci_qhbp1_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qhbp1_cpm_extract(ehci_qhbp1_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0xff) >> 0);
}

static inline void ehci_qhbp1_cpm_insert(ehci_qhbp1_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qhbp1_cpm_insert(ehci_qhbp1_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0x0) | (0xff & (_fieldval << 0)));
}

static inline uint32_t ehci_qhbp1_p_extract(ehci_qhbp1_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t ehci_qhbp1_p_extract(ehci_qhbp1_t _dtptr)
{
    return(((*((uint32_t *)(0 + _dtptr))) & 0xfffff000) >> 12);
}

static inline void ehci_qhbp1_p_insert(ehci_qhbp1_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qhbp1_p_insert(ehci_qhbp1_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(0 + _dtptr)) = (((*((uint32_t *)(0 + _dtptr))) & 0xfff) | (0xfffff000 & (_fieldval << 12)));
}

static inline int ehci_qhbp1_prtval(char *_s, size_t _size, ehci_qhbp1_t _regval) __attribute__ ((always_inline));
static inline int ehci_qhbp1_prtval(char *_s, size_t _size, ehci_qhbp1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpm =\t%" PRIx8 "\t(Split-transaction complete-split progress)\n", ehci_qhbp1_cpm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p =\t%" PRIx32 "\t(Buffer pointer (4k aligned))\n", ehci_qhbp1_p_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ehci_qhbp2_t
 * Description: Queue head buffer pointer page 2
 * Fields:
 *   ft	(size 5, offset 0, init 0):	RW	Split-transaction frame tag
 *   sb	(size 7, offset 5, init 0):	RW	S-bytes
 *   p	(size 20, offset 12, init 0):	RW	Buffer pointer (4k aligned)
 */
typedef uint8_t *ehci_qhbp2_t;
typedef uint8_t ehci_qhbp2_array_t[4];
static const size_t ehci_qhbp2_size = sizeof(ehci_qhbp2_array_t );
static inline uint8_t ehci_qhbp2_ft_extract(ehci_qhbp2_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qhbp2_ft_extract(ehci_qhbp2_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x1f) >> 0);
}

static inline void ehci_qhbp2_ft_insert(ehci_qhbp2_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qhbp2_ft_insert(ehci_qhbp2_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xe0) | (0x1f & (_fieldval << 0)));
}

static inline uint8_t ehci_qhbp2_sb_extract(ehci_qhbp2_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ehci_qhbp2_sb_extract(ehci_qhbp2_t _dtptr)
{
    return(((*((uint16_t *)(0 + _dtptr))) & 0xfe0) >> 5);
}

static inline void ehci_qhbp2_sb_insert(ehci_qhbp2_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qhbp2_sb_insert(ehci_qhbp2_t _dtptr, uint8_t _fieldval)
{
    *((uint16_t *)(0 + _dtptr)) = (((*((uint16_t *)(0 + _dtptr))) & 0xf01f) | (0xfe0 & (_fieldval << 5)));
}

static inline uint32_t ehci_qhbp2_p_extract(ehci_qhbp2_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t ehci_qhbp2_p_extract(ehci_qhbp2_t _dtptr)
{
    return(((*((uint32_t *)(0 + _dtptr))) & 0xfffff000) >> 12);
}

static inline void ehci_qhbp2_p_insert(ehci_qhbp2_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_qhbp2_p_insert(ehci_qhbp2_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(0 + _dtptr)) = (((*((uint32_t *)(0 + _dtptr))) & 0xfff) | (0xfffff000 & (_fieldval << 12)));
}

static inline int ehci_qhbp2_prtval(char *_s, size_t _size, ehci_qhbp2_t _regval) __attribute__ ((always_inline));
static inline int ehci_qhbp2_prtval(char *_s, size_t _size, ehci_qhbp2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ft =\t%" PRIx8 "\t(Split-transaction frame tag)\n", ehci_qhbp2_ft_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sb =\t%" PRIx8 "\t(S-bytes)\n", ehci_qhbp2_sb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p =\t%" PRIx32 "\t(Buffer pointer (4k aligned))\n", ehci_qhbp2_p_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ehci_fstm_t
 * Description: Periodic Frame Span Traversal Node
 * Fields:
 *   normal	(size 32, offset 0, init 0):	RW	Normal path link pointer
 *   back	(size 32, offset 32, init 0):	RW	Back path link pointer
 */
typedef uint8_t *ehci_fstm_t;
typedef uint8_t ehci_fstm_array_t[8];
static const size_t ehci_fstm_size = sizeof(ehci_fstm_array_t );
static inline ehci_lp_t ehci_fstm_normal_extract(ehci_fstm_t _dtptr) __attribute__ ((always_inline));
static inline ehci_lp_t ehci_fstm_normal_extract(ehci_fstm_t _dtptr)
{
    return(((*((uint32_t *)(0 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_fstm_normal_insert(ehci_fstm_t _dtptr, ehci_lp_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_fstm_normal_insert(ehci_fstm_t _dtptr, ehci_lp_t _fieldval)
{
    *((uint32_t *)(0 + _dtptr)) = (((*((uint32_t *)(0 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline ehci_lp_t ehci_fstm_back_extract(ehci_fstm_t _dtptr) __attribute__ ((always_inline));
static inline ehci_lp_t ehci_fstm_back_extract(ehci_fstm_t _dtptr)
{
    return(((*((uint32_t *)(4 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ehci_fstm_back_insert(ehci_fstm_t _dtptr, ehci_lp_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_fstm_back_insert(ehci_fstm_t _dtptr, ehci_lp_t _fieldval)
{
    *((uint32_t *)(4 + _dtptr)) = (((*((uint32_t *)(4 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline int ehci_fstm_prtval(char *_s, size_t _size, ehci_fstm_t _regval) __attribute__ ((always_inline));
static inline int ehci_fstm_prtval(char *_s, size_t _size, ehci_fstm_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " normal =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_lp_prtval(_s + _r, _avail, ehci_fstm_normal_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Normal path link pointer)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " back =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_lp_prtval(_s + _r, _avail, ehci_fstm_back_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Back path link pointer)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t cap;
    mackerel_addr_t op;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum ehci_initials {
    ehci_cap_length_initial = 0x0,
    ehci_hcirev_initial = 0x0,
    ehci_hcs_params_initial = 0x0,
    ehci_hccparams_initial = 0x0,
    ehci_hcspportroute_initial = 0x0,
    ehci_usb_cmd_initial = 0x0,
    ehci_usb_status_initial = 0x0,
    ehci_usb_int_initial = 0x0,
    ehci_frame_index_initial = 0x0,
    ehci_ctrl_dss_reg_initial = 0x0,
    ehci_flba_reg_initial = 0x0,
    ehci_asyn_list_reg_initial = 0x0,
    ehci_config_flag_initial = 0x0,
    ehci_portsc_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void ehci_initialize(__DN(t) *_dev, mackerel_addr_t cap, mackerel_addr_t op) __attribute__ ((always_inline));
static inline void ehci_initialize(__DN(t) *_dev, mackerel_addr_t cap, mackerel_addr_t op)
{
    _dev->cap = cap;
    _dev->op = op;
}

/*
 * Register cap_length: Capability register length
 * Type: ehci.uint8 (primitive type)
 */
static inline uint8_t ehci_cap_length_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_cap_length_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->cap, 0x0));
}

static inline uint8_t ehci_cap_length_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_cap_length_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->cap, 0x0));
}

static inline void ehci_cap_length_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void ehci_cap_length_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    mackerel_write_addr_8(_dev->cap, 0x0, _regval);
}

// Register cap_length is not writeable
static inline int ehci_cap_length_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_cap_length_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_addr_8(_dev->cap, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cap_length (Capability register length): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register hcirev: HCI version number
 * Type: ehci.uint16 (primitive type)
 */
static inline uint16_t ehci_hcirev_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ehci_hcirev_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->cap, 0x2));
}

static inline uint16_t ehci_hcirev_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ehci_hcirev_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->cap, 0x2));
}

static inline void ehci_hcirev_rawwr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void ehci_hcirev_rawwr(__DN(t) *_dev, uint16_t _regval)
{
    mackerel_write_addr_16(_dev->cap, 0x2, _regval);
}

// Register hcirev is not writeable
static inline int ehci_hcirev_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_hcirev_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint16_t _regval = mackerel_read_addr_16(_dev->cap, 0x2);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register hcirev (HCI version number): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx16 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register hcs_params: Structural parameters
 * Type: ehci.hcs_params (Implicit type of Structural parameters register)
 *   n_ports	(size 4, offset 0, init 0):	RO	Num. physical downstream ports on this controller
 *   ppc	(size 1, offset 4, init 0):	RO	Port power control
 *   _anon5	(size 2, offset 5, init 0):	RSVD	_
 *   prr	(size 1, offset 7, init 0):	RO	Port routing rules
 *   n_pcc	(size 4, offset 8, init 0):	RO	Number of ports per companion controller
 *   n_cc	(size 4, offset 12, init 0):	RO	Number of campanion controller
 *   pi	(size 1, offset 16, init 0):	RO	Port indicator
 *   _anon17	(size 3, offset 17, init 0):	RSVD	_
 *   dpn	(size 4, offset 20, init 0):	RO	Debug port number
 *   _anon24	(size 8, offset 24, init 0):	RSVD	_
 */
static inline ehci_hcs_params_t ehci_hcs_params_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_hcs_params_t ehci_hcs_params_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->cap, 0x4));
}

static inline ehci_hcs_params_t ehci_hcs_params_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_hcs_params_t ehci_hcs_params_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->cap, 0x4));
}

static inline void ehci_hcs_params_rawwr(__DN(t) *_dev, ehci_hcs_params_t _regval) __attribute__ ((always_inline));
static inline void ehci_hcs_params_rawwr(__DN(t) *_dev, ehci_hcs_params_t _regval)
{
    mackerel_write_addr_32(_dev->cap, 0x4, _regval);
}

// Register hcs_params is not writeable
static inline int ehci_hcs_params_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_hcs_params_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ehci_hcs_params_t _regval = mackerel_read_addr_32(_dev->cap, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register hcs_params (Structural parameters): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " n_ports =\t%" PRIx8 "\t(Num. physical downstream ports on this controller)\n", ehci_hcs_params_n_ports_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ppc =\t%" PRIx8 "\t(Port power control)\n", ehci_hcs_params_ppc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prr =\t%" PRIx8 "\t(Port routing rules)\n", ehci_hcs_params_prr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " n_pcc =\t%" PRIx8 "\t(Number of ports per companion controller)\n", ehci_hcs_params_n_pcc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " n_cc =\t%" PRIx8 "\t(Number of campanion controller)\n", ehci_hcs_params_n_cc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pi =\t%" PRIx8 "\t(Port indicator)\n", ehci_hcs_params_pi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon17 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpn =\t%" PRIx8 "\t(Debug port number)\n", ehci_hcs_params_dpn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    return(_r);
}

static inline uint8_t ehci_hcs_params_n_ports_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_hcs_params_n_ports_rdf(__DN(t) *_dev)
{
    ehci_hcs_params_t _regval = mackerel_read_addr_32(_dev->cap, 0x4);
    return(ehci_hcs_params_n_ports_extract(_regval));
}

static inline uint8_t ehci_hcs_params_ppc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_hcs_params_ppc_rdf(__DN(t) *_dev)
{
    ehci_hcs_params_t _regval = mackerel_read_addr_32(_dev->cap, 0x4);
    return(ehci_hcs_params_ppc_extract(_regval));
}

static inline uint8_t ehci_hcs_params_prr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_hcs_params_prr_rdf(__DN(t) *_dev)
{
    ehci_hcs_params_t _regval = mackerel_read_addr_32(_dev->cap, 0x4);
    return(ehci_hcs_params_prr_extract(_regval));
}

static inline uint8_t ehci_hcs_params_n_pcc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_hcs_params_n_pcc_rdf(__DN(t) *_dev)
{
    ehci_hcs_params_t _regval = mackerel_read_addr_32(_dev->cap, 0x4);
    return(ehci_hcs_params_n_pcc_extract(_regval));
}

static inline uint8_t ehci_hcs_params_n_cc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_hcs_params_n_cc_rdf(__DN(t) *_dev)
{
    ehci_hcs_params_t _regval = mackerel_read_addr_32(_dev->cap, 0x4);
    return(ehci_hcs_params_n_cc_extract(_regval));
}

static inline uint8_t ehci_hcs_params_pi_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_hcs_params_pi_rdf(__DN(t) *_dev)
{
    ehci_hcs_params_t _regval = mackerel_read_addr_32(_dev->cap, 0x4);
    return(ehci_hcs_params_pi_extract(_regval));
}

static inline uint8_t ehci_hcs_params_dpn_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_hcs_params_dpn_rdf(__DN(t) *_dev)
{
    ehci_hcs_params_t _regval = mackerel_read_addr_32(_dev->cap, 0x4);
    return(ehci_hcs_params_dpn_extract(_regval));
}

/*
 * Register hccparams: Capability parameters
 * Type: ehci.hccparams (Implicit type of Capability parameters register)
 *   ex_ac	(size 1, offset 0, init 0):	RO	Extended 64 bit addressing capability
 *   pflf	(size 1, offset 1, init 0):	RO	Programmable frame list flag
 *   aspc	(size 1, offset 2, init 0):	RO	Asynchronous sechedule park capability
 *   _anon3	(size 1, offset 3, init 0):	RSVD	_
 *   ist	(size 4, offset 4, init 0):	RO	Isochronous scheduling threshold
 *   eecp	(size 8, offset 8, init 0):	RO	EHCI extended capabilities pointer
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline ehci_hccparams_t ehci_hccparams_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_hccparams_t ehci_hccparams_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->cap, 0x8));
}

static inline ehci_hccparams_t ehci_hccparams_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_hccparams_t ehci_hccparams_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->cap, 0x8));
}

static inline void ehci_hccparams_rawwr(__DN(t) *_dev, ehci_hccparams_t _regval) __attribute__ ((always_inline));
static inline void ehci_hccparams_rawwr(__DN(t) *_dev, ehci_hccparams_t _regval)
{
    mackerel_write_addr_32(_dev->cap, 0x8, _regval);
}

// Register hccparams is not writeable
static inline int ehci_hccparams_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_hccparams_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ehci_hccparams_t _regval = mackerel_read_addr_32(_dev->cap, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register hccparams (Capability parameters): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ex_ac =\t%" PRIx8 "\t(Extended 64 bit addressing capability)\n", ehci_hccparams_ex_ac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pflf =\t%" PRIx8 "\t(Programmable frame list flag)\n", ehci_hccparams_pflf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aspc =\t%" PRIx8 "\t(Asynchronous sechedule park capability)\n", ehci_hccparams_aspc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ist =\t%" PRIx8 "\t(Isochronous scheduling threshold)\n", ehci_hccparams_ist_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eecp =\t%" PRIx8 "\t(EHCI extended capabilities pointer)\n", ehci_hccparams_eecp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t ehci_hccparams_ex_ac_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_hccparams_ex_ac_rdf(__DN(t) *_dev)
{
    ehci_hccparams_t _regval = mackerel_read_addr_32(_dev->cap, 0x8);
    return(ehci_hccparams_ex_ac_extract(_regval));
}

static inline uint8_t ehci_hccparams_pflf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_hccparams_pflf_rdf(__DN(t) *_dev)
{
    ehci_hccparams_t _regval = mackerel_read_addr_32(_dev->cap, 0x8);
    return(ehci_hccparams_pflf_extract(_regval));
}

static inline uint8_t ehci_hccparams_aspc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_hccparams_aspc_rdf(__DN(t) *_dev)
{
    ehci_hccparams_t _regval = mackerel_read_addr_32(_dev->cap, 0x8);
    return(ehci_hccparams_aspc_extract(_regval));
}

static inline uint8_t ehci_hccparams_ist_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_hccparams_ist_rdf(__DN(t) *_dev)
{
    ehci_hccparams_t _regval = mackerel_read_addr_32(_dev->cap, 0x8);
    return(ehci_hccparams_ist_extract(_regval));
}

static inline uint8_t ehci_hccparams_eecp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_hccparams_eecp_rdf(__DN(t) *_dev)
{
    ehci_hccparams_t _regval = mackerel_read_addr_32(_dev->cap, 0x8);
    return(ehci_hccparams_eecp_extract(_regval));
}

/*
 * Register hcspportroute: Companion port route descr.
 * Type: ehci.hcspportroute (Implicit type of Companion port route descr. register)
 *   _anon0	(size 4, offset 0, init 0):	RSVD	_
 *   attr	(size 60, offset 4, init 0):	RO	Port array
 */
static inline ehci_hcspportroute_t ehci_hcspportroute_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_hcspportroute_t ehci_hcspportroute_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_64(_dev->cap, 0xc));
}

static inline ehci_hcspportroute_t ehci_hcspportroute_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_hcspportroute_t ehci_hcspportroute_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_64(_dev->cap, 0xc));
}

static inline void ehci_hcspportroute_rawwr(__DN(t) *_dev, ehci_hcspportroute_t _regval) __attribute__ ((always_inline));
static inline void ehci_hcspportroute_rawwr(__DN(t) *_dev, ehci_hcspportroute_t _regval)
{
    mackerel_write_addr_64(_dev->cap, 0xc, _regval);
}

// Register hcspportroute is not writeable
static inline int ehci_hcspportroute_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_hcspportroute_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ehci_hcspportroute_t _regval = mackerel_read_addr_64(_dev->cap, 0xc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register hcspportroute (Companion port route descr.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " attr =\t%" PRIx64 "\t(Port array)\n", ehci_hcspportroute_attr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint64_t ehci_hcspportroute_attr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint64_t ehci_hcspportroute_attr_rdf(__DN(t) *_dev)
{
    ehci_hcspportroute_t _regval = mackerel_read_addr_64(_dev->cap, 0xc);
    return(ehci_hcspportroute_attr_extract(_regval));
}

/*
 * Register usb_cmd: USB command
 * Type: ehci.usb_cmd (Implicit type of USB command register)
 *   rs	(size 1, offset 0, init 0):	RW	Run stop for scheduling
 *   hcr	(size 1, offset 1, init 0):	RW	Host controller reset
 *   fl_sz	(size 2, offset 2, init 0):	RW	Frame list size
 *   ps_e	(size 1, offset 4, init 0):	RW	Periodic schedule enable
 *   as_e	(size 1, offset 5, init 0):	RW	Asynchronous schedule enable
 *   iaad	(size 1, offset 6, init 0):	RW	Interrupt on async advance doorbell
 *   lhcr	(size 1, offset 7, init 0):	RW	Light host controller reset
 *   aspm_c	(size 2, offset 8, init 0):	RW	Asynchronous schedule park mode count
 *   _anon10	(size 1, offset 10, init 0):	MBZ	_
 *   aspm_e	(size 1, offset 11, init 0):	RW	Asynchronous schedule park mode enable
 *   _anon12	(size 4, offset 12, init 0):	MBZ	_
 *   itc	(size 8, offset 16, init 0):	RW	Interrupt threshold control
 *   _anon24	(size 8, offset 24, init 0):	MBZ	_
 */
static inline ehci_usb_cmd_t ehci_usb_cmd_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_usb_cmd_t ehci_usb_cmd_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x0));
}

static inline ehci_usb_cmd_t ehci_usb_cmd_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_usb_cmd_t ehci_usb_cmd_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x0));
}

static inline void ehci_usb_cmd_rawwr(__DN(t) *_dev, ehci_usb_cmd_t _regval) __attribute__ ((always_inline));
static inline void ehci_usb_cmd_rawwr(__DN(t) *_dev, ehci_usb_cmd_t _regval)
{
    mackerel_write_addr_32(_dev->op, 0x0, _regval);
}

static inline void ehci_usb_cmd_wr(__DN(t) *_dev, ehci_usb_cmd_t _regval) __attribute__ ((always_inline));
static inline void ehci_usb_cmd_wr(__DN(t) *_dev, ehci_usb_cmd_t _regval)
{
    _regval = (_regval & 0xff0bff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->op, 0x0, _regval);
}

static inline int ehci_usb_cmd_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_usb_cmd_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ehci_usb_cmd_t _regval = mackerel_read_addr_32(_dev->op, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register usb_cmd (USB command): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rs =\t%" PRIx8 "\t(Run stop for scheduling)\n", ehci_usb_cmd_rs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hcr =\t%" PRIx8 "\t(Host controller reset)\n", ehci_usb_cmd_hcr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_sz =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_frame_val_prtval(_s + _r, _avail, ehci_usb_cmd_fl_sz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Frame list size)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ps_e =\t%" PRIx8 "\t(Periodic schedule enable)\n", ehci_usb_cmd_ps_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " as_e =\t%" PRIx8 "\t(Asynchronous schedule enable)\n", ehci_usb_cmd_as_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iaad =\t%" PRIx8 "\t(Interrupt on async advance doorbell)\n", ehci_usb_cmd_iaad_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lhcr =\t%" PRIx8 "\t(Light host controller reset)\n", ehci_usb_cmd_lhcr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aspm_c =\t%" PRIx8 "\t(Asynchronous schedule park mode count)\n", ehci_usb_cmd_aspm_c_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aspm_e =\t%" PRIx8 "\t(Asynchronous schedule park mode enable)\n", ehci_usb_cmd_aspm_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " itc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_itc_val_prtval(_s + _r, _avail, ehci_usb_cmd_itc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Interrupt threshold control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    return(_r);
}

static inline uint8_t ehci_usb_cmd_rs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_cmd_rs_rdf(__DN(t) *_dev)
{
    ehci_usb_cmd_t _regval = mackerel_read_addr_32(_dev->op, 0x0);
    return(ehci_usb_cmd_rs_extract(_regval));
}

static inline uint8_t ehci_usb_cmd_hcr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_cmd_hcr_rdf(__DN(t) *_dev)
{
    ehci_usb_cmd_t _regval = mackerel_read_addr_32(_dev->op, 0x0);
    return(ehci_usb_cmd_hcr_extract(_regval));
}

static inline ehci_frame_val_t ehci_usb_cmd_fl_sz_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_frame_val_t ehci_usb_cmd_fl_sz_rdf(__DN(t) *_dev)
{
    ehci_usb_cmd_t _regval = mackerel_read_addr_32(_dev->op, 0x0);
    return(ehci_usb_cmd_fl_sz_extract(_regval));
}

static inline uint8_t ehci_usb_cmd_ps_e_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_cmd_ps_e_rdf(__DN(t) *_dev)
{
    ehci_usb_cmd_t _regval = mackerel_read_addr_32(_dev->op, 0x0);
    return(ehci_usb_cmd_ps_e_extract(_regval));
}

static inline uint8_t ehci_usb_cmd_as_e_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_cmd_as_e_rdf(__DN(t) *_dev)
{
    ehci_usb_cmd_t _regval = mackerel_read_addr_32(_dev->op, 0x0);
    return(ehci_usb_cmd_as_e_extract(_regval));
}

static inline uint8_t ehci_usb_cmd_iaad_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_cmd_iaad_rdf(__DN(t) *_dev)
{
    ehci_usb_cmd_t _regval = mackerel_read_addr_32(_dev->op, 0x0);
    return(ehci_usb_cmd_iaad_extract(_regval));
}

static inline uint8_t ehci_usb_cmd_lhcr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_cmd_lhcr_rdf(__DN(t) *_dev)
{
    ehci_usb_cmd_t _regval = mackerel_read_addr_32(_dev->op, 0x0);
    return(ehci_usb_cmd_lhcr_extract(_regval));
}

static inline uint8_t ehci_usb_cmd_aspm_c_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_cmd_aspm_c_rdf(__DN(t) *_dev)
{
    ehci_usb_cmd_t _regval = mackerel_read_addr_32(_dev->op, 0x0);
    return(ehci_usb_cmd_aspm_c_extract(_regval));
}

static inline uint8_t ehci_usb_cmd_aspm_e_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_cmd_aspm_e_rdf(__DN(t) *_dev)
{
    ehci_usb_cmd_t _regval = mackerel_read_addr_32(_dev->op, 0x0);
    return(ehci_usb_cmd_aspm_e_extract(_regval));
}

static inline ehci_itc_val_t ehci_usb_cmd_itc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_itc_val_t ehci_usb_cmd_itc_rdf(__DN(t) *_dev)
{
    ehci_usb_cmd_t _regval = mackerel_read_addr_32(_dev->op, 0x0);
    return(ehci_usb_cmd_itc_extract(_regval));
}

static inline void ehci_usb_cmd_rs_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usb_cmd_rs_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usb_cmd_t _regval = 0x1 & (((ehci_usb_cmd_t )(_fieldval)) << 0);
    _regval = (_regval | (0xff0bfe & mackerel_read_addr_32(_dev->op, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x0, _regval);
    // No shadow register to write to
}

static inline void ehci_usb_cmd_hcr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usb_cmd_hcr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usb_cmd_t _regval = 0x2 & (((ehci_usb_cmd_t )(_fieldval)) << 1);
    _regval = (_regval | (0xff0bfd & mackerel_read_addr_32(_dev->op, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x0, _regval);
    // No shadow register to write to
}

static inline void ehci_usb_cmd_fl_sz_wrf(__DN(t) *_dev, ehci_frame_val_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usb_cmd_fl_sz_wrf(__DN(t) *_dev, ehci_frame_val_t _fieldval)
{
    ehci_usb_cmd_t _regval = 0xc & (((ehci_usb_cmd_t )(_fieldval)) << 2);
    _regval = (_regval | (0xff0bf3 & mackerel_read_addr_32(_dev->op, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x0, _regval);
    // No shadow register to write to
}

static inline void ehci_usb_cmd_ps_e_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usb_cmd_ps_e_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usb_cmd_t _regval = 0x10 & (((ehci_usb_cmd_t )(_fieldval)) << 4);
    _regval = (_regval | (0xff0bef & mackerel_read_addr_32(_dev->op, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x0, _regval);
    // No shadow register to write to
}

static inline void ehci_usb_cmd_as_e_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usb_cmd_as_e_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usb_cmd_t _regval = 0x20 & (((ehci_usb_cmd_t )(_fieldval)) << 5);
    _regval = (_regval | (0xff0bdf & mackerel_read_addr_32(_dev->op, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x0, _regval);
    // No shadow register to write to
}

static inline void ehci_usb_cmd_iaad_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usb_cmd_iaad_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usb_cmd_t _regval = 0x40 & (((ehci_usb_cmd_t )(_fieldval)) << 6);
    _regval = (_regval | (0xff0bbf & mackerel_read_addr_32(_dev->op, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x0, _regval);
    // No shadow register to write to
}

static inline void ehci_usb_cmd_lhcr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usb_cmd_lhcr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usb_cmd_t _regval = 0x80 & (((ehci_usb_cmd_t )(_fieldval)) << 7);
    _regval = (_regval | (0xff0b7f & mackerel_read_addr_32(_dev->op, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x0, _regval);
    // No shadow register to write to
}

static inline void ehci_usb_cmd_aspm_c_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usb_cmd_aspm_c_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usb_cmd_t _regval = 0x300 & (((ehci_usb_cmd_t )(_fieldval)) << 8);
    _regval = (_regval | (0xff08ff & mackerel_read_addr_32(_dev->op, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x0, _regval);
    // No shadow register to write to
}

static inline void ehci_usb_cmd_aspm_e_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usb_cmd_aspm_e_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usb_cmd_t _regval = 0x800 & (((ehci_usb_cmd_t )(_fieldval)) << 11);
    _regval = (_regval | (0xff03ff & mackerel_read_addr_32(_dev->op, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x0, _regval);
    // No shadow register to write to
}

static inline void ehci_usb_cmd_itc_wrf(__DN(t) *_dev, ehci_itc_val_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usb_cmd_itc_wrf(__DN(t) *_dev, ehci_itc_val_t _fieldval)
{
    ehci_usb_cmd_t _regval = 0xff0000 & (((ehci_usb_cmd_t )(_fieldval)) << 16);
    _regval = (_regval | (0xbff & mackerel_read_addr_32(_dev->op, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x0, _regval);
    // No shadow register to write to
}

/*
 * Register usb_status: USB status
 * Type: ehci.usb_status (Implicit type of USB status register)
 *   usb_i	(size 1, offset 0, init 0):	RWC	USB interrupt
 *   usb_ei	(size 1, offset 1, init 0):	RWC	USB error interrupt
 *   pcd	(size 1, offset 2, init 0):	RWC	Port change detect
 *   flr	(size 1, offset 3, init 0):	RWC	Frame list rollover
 *   hs_err	(size 1, offset 4, init 0):	RWC	Host system error
 *   i_aa	(size 1, offset 5, init 0):	RWC	Interrupt on Async advance
 *   _anon6	(size 6, offset 6, init 0):	MBZ	_
 *   hc_halt	(size 1, offset 12, init 0):	RO	Host controller halted see Run/Stop
 *   rec	(size 1, offset 13, init 0):	RO	Reclamation
 *   ps_s	(size 1, offset 14, init 0):	RO	Periodic schedule status
 *   as_s	(size 1, offset 15, init 0):	RO	Asynchronous schedule status
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
static inline ehci_usb_status_t ehci_usb_status_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_usb_status_t ehci_usb_status_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x4));
}

static inline ehci_usb_status_t ehci_usb_status_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_usb_status_t ehci_usb_status_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x4));
}

static inline void ehci_usb_status_rawwr(__DN(t) *_dev, ehci_usb_status_t _regval) __attribute__ ((always_inline));
static inline void ehci_usb_status_rawwr(__DN(t) *_dev, ehci_usb_status_t _regval)
{
    mackerel_write_addr_32(_dev->op, 0x4, _regval);
}

static inline void ehci_usb_status_wr(__DN(t) *_dev, ehci_usb_status_t _regval) __attribute__ ((always_inline));
static inline void ehci_usb_status_wr(__DN(t) *_dev, ehci_usb_status_t _regval)
{
    _regval = (_regval & 0xf03f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->op, 0x4, _regval);
}

static inline int ehci_usb_status_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_usb_status_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ehci_usb_status_t _regval = mackerel_read_addr_32(_dev->op, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register usb_status (USB status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usb_i =\t%" PRIx8 "\t(USB interrupt)\n", ehci_usb_status_usb_i_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usb_ei =\t%" PRIx8 "\t(USB error interrupt)\n", ehci_usb_status_usb_ei_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcd =\t%" PRIx8 "\t(Port change detect)\n", ehci_usb_status_pcd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flr =\t%" PRIx8 "\t(Frame list rollover)\n", ehci_usb_status_flr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hs_err =\t%" PRIx8 "\t(Host system error)\n", ehci_usb_status_hs_err_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_aa =\t%" PRIx8 "\t(Interrupt on Async advance)\n", ehci_usb_status_i_aa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hc_halt =\t%" PRIx8 "\t(Host controller halted see Run/Stop)\n", ehci_usb_status_hc_halt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rec =\t%" PRIx8 "\t(Reclamation)\n", ehci_usb_status_rec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ps_s =\t%" PRIx8 "\t(Periodic schedule status)\n", ehci_usb_status_ps_s_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " as_s =\t%" PRIx8 "\t(Asynchronous schedule status)\n", ehci_usb_status_as_s_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t ehci_usb_status_usb_i_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_status_usb_i_rdf(__DN(t) *_dev)
{
    ehci_usb_status_t _regval = mackerel_read_addr_32(_dev->op, 0x4);
    return(ehci_usb_status_usb_i_extract(_regval));
}

static inline uint8_t ehci_usb_status_usb_ei_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_status_usb_ei_rdf(__DN(t) *_dev)
{
    ehci_usb_status_t _regval = mackerel_read_addr_32(_dev->op, 0x4);
    return(ehci_usb_status_usb_ei_extract(_regval));
}

static inline uint8_t ehci_usb_status_pcd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_status_pcd_rdf(__DN(t) *_dev)
{
    ehci_usb_status_t _regval = mackerel_read_addr_32(_dev->op, 0x4);
    return(ehci_usb_status_pcd_extract(_regval));
}

static inline uint8_t ehci_usb_status_flr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_status_flr_rdf(__DN(t) *_dev)
{
    ehci_usb_status_t _regval = mackerel_read_addr_32(_dev->op, 0x4);
    return(ehci_usb_status_flr_extract(_regval));
}

static inline uint8_t ehci_usb_status_hs_err_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_status_hs_err_rdf(__DN(t) *_dev)
{
    ehci_usb_status_t _regval = mackerel_read_addr_32(_dev->op, 0x4);
    return(ehci_usb_status_hs_err_extract(_regval));
}

static inline uint8_t ehci_usb_status_i_aa_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_status_i_aa_rdf(__DN(t) *_dev)
{
    ehci_usb_status_t _regval = mackerel_read_addr_32(_dev->op, 0x4);
    return(ehci_usb_status_i_aa_extract(_regval));
}

static inline uint8_t ehci_usb_status_hc_halt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_status_hc_halt_rdf(__DN(t) *_dev)
{
    ehci_usb_status_t _regval = mackerel_read_addr_32(_dev->op, 0x4);
    return(ehci_usb_status_hc_halt_extract(_regval));
}

static inline uint8_t ehci_usb_status_rec_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_status_rec_rdf(__DN(t) *_dev)
{
    ehci_usb_status_t _regval = mackerel_read_addr_32(_dev->op, 0x4);
    return(ehci_usb_status_rec_extract(_regval));
}

static inline uint8_t ehci_usb_status_ps_s_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_status_ps_s_rdf(__DN(t) *_dev)
{
    ehci_usb_status_t _regval = mackerel_read_addr_32(_dev->op, 0x4);
    return(ehci_usb_status_ps_s_extract(_regval));
}

static inline uint8_t ehci_usb_status_as_s_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_status_as_s_rdf(__DN(t) *_dev)
{
    ehci_usb_status_t _regval = mackerel_read_addr_32(_dev->op, 0x4);
    return(ehci_usb_status_as_s_extract(_regval));
}

static inline void ehci_usb_status_usb_i_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usb_status_usb_i_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usb_status_t _regval = 0x1 & (((ehci_usb_status_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xf03f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x4, _regval);
    // No shadow register to write to
}

static inline void ehci_usb_status_usb_ei_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usb_status_usb_ei_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usb_status_t _regval = 0x2 & (((ehci_usb_status_t )(_fieldval)) << 1);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xf03f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x4, _regval);
    // No shadow register to write to
}

static inline void ehci_usb_status_pcd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usb_status_pcd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usb_status_t _regval = 0x4 & (((ehci_usb_status_t )(_fieldval)) << 2);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xf03f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x4, _regval);
    // No shadow register to write to
}

static inline void ehci_usb_status_flr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usb_status_flr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usb_status_t _regval = 0x8 & (((ehci_usb_status_t )(_fieldval)) << 3);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xf03f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x4, _regval);
    // No shadow register to write to
}

static inline void ehci_usb_status_hs_err_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usb_status_hs_err_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usb_status_t _regval = 0x10 & (((ehci_usb_status_t )(_fieldval)) << 4);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xf03f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x4, _regval);
    // No shadow register to write to
}

static inline void ehci_usb_status_i_aa_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usb_status_i_aa_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usb_status_t _regval = 0x20 & (((ehci_usb_status_t )(_fieldval)) << 5);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xf03f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x4, _regval);
    // No shadow register to write to
}

/*
 * Register usb_int: USB interrupt enable
 * Type: ehci.usb_int (Implicit type of USB interrupt enable register)
 *   usbi_e	(size 1, offset 0, init 0):	RW	USB interrupt enable
 *   usbei_e	(size 1, offset 1, init 0):	RW	USB error interrupt enable
 *   pci_e	(size 1, offset 2, init 0):	RW	Port change interrupt enable
 *   flr_e	(size 1, offset 3, init 0):	RW	Frame list rollover enable
 *   hye_e	(size 1, offset 4, init 0):	RW	Host system error enable
 *   iaa_e	(size 1, offset 5, init 0):	RW	Interrupt on async advance enable
 *   _anon6	(size 26, offset 6, init 0):	MBZ	_
 */
static inline ehci_usb_int_t ehci_usb_int_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_usb_int_t ehci_usb_int_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x8));
}

static inline ehci_usb_int_t ehci_usb_int_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_usb_int_t ehci_usb_int_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x8));
}

static inline void ehci_usb_int_rawwr(__DN(t) *_dev, ehci_usb_int_t _regval) __attribute__ ((always_inline));
static inline void ehci_usb_int_rawwr(__DN(t) *_dev, ehci_usb_int_t _regval)
{
    mackerel_write_addr_32(_dev->op, 0x8, _regval);
}

static inline void ehci_usb_int_wr(__DN(t) *_dev, ehci_usb_int_t _regval) __attribute__ ((always_inline));
static inline void ehci_usb_int_wr(__DN(t) *_dev, ehci_usb_int_t _regval)
{
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->op, 0x8, _regval);
}

static inline int ehci_usb_int_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_usb_int_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ehci_usb_int_t _regval = mackerel_read_addr_32(_dev->op, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register usb_int (USB interrupt enable): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usbi_e =\t%" PRIx8 "\t(USB interrupt enable)\n", ehci_usb_int_usbi_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usbei_e =\t%" PRIx8 "\t(USB error interrupt enable)\n", ehci_usb_int_usbei_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pci_e =\t%" PRIx8 "\t(Port change interrupt enable)\n", ehci_usb_int_pci_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flr_e =\t%" PRIx8 "\t(Frame list rollover enable)\n", ehci_usb_int_flr_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hye_e =\t%" PRIx8 "\t(Host system error enable)\n", ehci_usb_int_hye_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iaa_e =\t%" PRIx8 "\t(Interrupt on async advance enable)\n", ehci_usb_int_iaa_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    return(_r);
}

static inline uint8_t ehci_usb_int_usbi_e_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_int_usbi_e_rdf(__DN(t) *_dev)
{
    ehci_usb_int_t _regval = mackerel_read_addr_32(_dev->op, 0x8);
    return(ehci_usb_int_usbi_e_extract(_regval));
}

static inline uint8_t ehci_usb_int_usbei_e_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_int_usbei_e_rdf(__DN(t) *_dev)
{
    ehci_usb_int_t _regval = mackerel_read_addr_32(_dev->op, 0x8);
    return(ehci_usb_int_usbei_e_extract(_regval));
}

static inline uint8_t ehci_usb_int_pci_e_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_int_pci_e_rdf(__DN(t) *_dev)
{
    ehci_usb_int_t _regval = mackerel_read_addr_32(_dev->op, 0x8);
    return(ehci_usb_int_pci_e_extract(_regval));
}

static inline uint8_t ehci_usb_int_flr_e_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_int_flr_e_rdf(__DN(t) *_dev)
{
    ehci_usb_int_t _regval = mackerel_read_addr_32(_dev->op, 0x8);
    return(ehci_usb_int_flr_e_extract(_regval));
}

static inline uint8_t ehci_usb_int_hye_e_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_int_hye_e_rdf(__DN(t) *_dev)
{
    ehci_usb_int_t _regval = mackerel_read_addr_32(_dev->op, 0x8);
    return(ehci_usb_int_hye_e_extract(_regval));
}

static inline uint8_t ehci_usb_int_iaa_e_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usb_int_iaa_e_rdf(__DN(t) *_dev)
{
    ehci_usb_int_t _regval = mackerel_read_addr_32(_dev->op, 0x8);
    return(ehci_usb_int_iaa_e_extract(_regval));
}

static inline void ehci_usb_int_usbi_e_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usb_int_usbi_e_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usb_int_t _regval = 0x1 & (((ehci_usb_int_t )(_fieldval)) << 0);
    _regval = (_regval | (0x3e & mackerel_read_addr_32(_dev->op, 0x8)));
    // No read of register shadow required
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x8, _regval);
    // No shadow register to write to
}

static inline void ehci_usb_int_usbei_e_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usb_int_usbei_e_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usb_int_t _regval = 0x2 & (((ehci_usb_int_t )(_fieldval)) << 1);
    _regval = (_regval | (0x3d & mackerel_read_addr_32(_dev->op, 0x8)));
    // No read of register shadow required
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x8, _regval);
    // No shadow register to write to
}

static inline void ehci_usb_int_pci_e_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usb_int_pci_e_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usb_int_t _regval = 0x4 & (((ehci_usb_int_t )(_fieldval)) << 2);
    _regval = (_regval | (0x3b & mackerel_read_addr_32(_dev->op, 0x8)));
    // No read of register shadow required
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x8, _regval);
    // No shadow register to write to
}

static inline void ehci_usb_int_flr_e_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usb_int_flr_e_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usb_int_t _regval = 0x8 & (((ehci_usb_int_t )(_fieldval)) << 3);
    _regval = (_regval | (0x37 & mackerel_read_addr_32(_dev->op, 0x8)));
    // No read of register shadow required
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x8, _regval);
    // No shadow register to write to
}

static inline void ehci_usb_int_hye_e_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usb_int_hye_e_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usb_int_t _regval = 0x10 & (((ehci_usb_int_t )(_fieldval)) << 4);
    _regval = (_regval | (0x2f & mackerel_read_addr_32(_dev->op, 0x8)));
    // No read of register shadow required
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x8, _regval);
    // No shadow register to write to
}

static inline void ehci_usb_int_iaa_e_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usb_int_iaa_e_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usb_int_t _regval = 0x20 & (((ehci_usb_int_t )(_fieldval)) << 5);
    _regval = (_regval | (0x1f & mackerel_read_addr_32(_dev->op, 0x8)));
    // No read of register shadow required
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x8, _regval);
    // No shadow register to write to
}

/*
 * Register frame_index: Frame index
 * Type: ehci.frame_index (Implicit type of Frame index register)
 *   fi	(size 14, offset 0, init 0):	RW	Frame index
 *   _anon14	(size 18, offset 14, init 0):	MBZ	_
 */
static inline ehci_frame_index_t ehci_frame_index_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_frame_index_t ehci_frame_index_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0xc));
}

static inline ehci_frame_index_t ehci_frame_index_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_frame_index_t ehci_frame_index_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0xc));
}

static inline void ehci_frame_index_rawwr(__DN(t) *_dev, ehci_frame_index_t _regval) __attribute__ ((always_inline));
static inline void ehci_frame_index_rawwr(__DN(t) *_dev, ehci_frame_index_t _regval)
{
    mackerel_write_addr_32(_dev->op, 0xc, _regval);
}

static inline void ehci_frame_index_wr(__DN(t) *_dev, ehci_frame_index_t _regval) __attribute__ ((always_inline));
static inline void ehci_frame_index_wr(__DN(t) *_dev, ehci_frame_index_t _regval)
{
    _regval = (_regval & 0x3fff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->op, 0xc, _regval);
}

static inline int ehci_frame_index_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_frame_index_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ehci_frame_index_t _regval = mackerel_read_addr_32(_dev->op, 0xc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register frame_index (Frame index): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fi =\t%" PRIx16 "\t(Frame index)\n", ehci_frame_index_fi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    return(_r);
}

static inline uint16_t ehci_frame_index_fi_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ehci_frame_index_fi_rdf(__DN(t) *_dev)
{
    ehci_frame_index_t _regval = mackerel_read_addr_32(_dev->op, 0xc);
    return(ehci_frame_index_fi_extract(_regval));
}

static inline void ehci_frame_index_fi_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_frame_index_fi_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    ehci_frame_index_t _regval = 0x3fff & (((ehci_frame_index_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3fff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0xc, _regval);
    // No shadow register to write to
}

/*
 * Register ctrl_dss_reg: Control data structure segment
 * Type: ehci.ctrl_dss_reg (Implicit type of Control data structure segment register)
 *   data	(size 32, offset 0, init 0):	RW	MSB [63:32] bits of EHCI data strctures
 */
static inline ehci_ctrl_dss_reg_t ehci_ctrl_dss_reg_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_ctrl_dss_reg_t ehci_ctrl_dss_reg_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x10));
}

static inline ehci_ctrl_dss_reg_t ehci_ctrl_dss_reg_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_ctrl_dss_reg_t ehci_ctrl_dss_reg_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x10));
}

static inline void ehci_ctrl_dss_reg_rawwr(__DN(t) *_dev, ehci_ctrl_dss_reg_t _regval) __attribute__ ((always_inline));
static inline void ehci_ctrl_dss_reg_rawwr(__DN(t) *_dev, ehci_ctrl_dss_reg_t _regval)
{
    mackerel_write_addr_32(_dev->op, 0x10, _regval);
}

static inline void ehci_ctrl_dss_reg_wr(__DN(t) *_dev, ehci_ctrl_dss_reg_t _regval) __attribute__ ((always_inline));
static inline void ehci_ctrl_dss_reg_wr(__DN(t) *_dev, ehci_ctrl_dss_reg_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->op, 0x10, _regval);
}

static inline int ehci_ctrl_dss_reg_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_ctrl_dss_reg_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ehci_ctrl_dss_reg_t _regval = mackerel_read_addr_32(_dev->op, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ctrl_dss_reg (Control data structure segment): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx32 "\t(MSB [63:32] bits of EHCI data strctures)\n", ehci_ctrl_dss_reg_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t ehci_ctrl_dss_reg_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ehci_ctrl_dss_reg_data_rdf(__DN(t) *_dev)
{
    ehci_ctrl_dss_reg_t _regval = mackerel_read_addr_32(_dev->op, 0x10);
    return(ehci_ctrl_dss_reg_data_extract(_regval));
}

static inline void ehci_ctrl_dss_reg_data_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_ctrl_dss_reg_data_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    ehci_ctrl_dss_reg_t _regval = 0xffffffff & (((ehci_ctrl_dss_reg_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x10, _regval);
    // No shadow register to write to
}

/*
 * Register flba_reg: Periodic frame list base addr
 * Type: ehci.flba_reg (Implicit type of Periodic frame list base addr register)
 *   _anon0	(size 12, offset 0, init 0):	MBZ	_
 *   addr	(size 20, offset 12, init 0):	RW	Base address (must be 4k aligned)
 */
static inline ehci_flba_reg_t ehci_flba_reg_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_flba_reg_t ehci_flba_reg_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x14));
}

static inline ehci_flba_reg_t ehci_flba_reg_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_flba_reg_t ehci_flba_reg_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x14));
}

static inline void ehci_flba_reg_rawwr(__DN(t) *_dev, ehci_flba_reg_t _regval) __attribute__ ((always_inline));
static inline void ehci_flba_reg_rawwr(__DN(t) *_dev, ehci_flba_reg_t _regval)
{
    mackerel_write_addr_32(_dev->op, 0x14, _regval);
}

static inline void ehci_flba_reg_wr(__DN(t) *_dev, ehci_flba_reg_t _regval) __attribute__ ((always_inline));
static inline void ehci_flba_reg_wr(__DN(t) *_dev, ehci_flba_reg_t _regval)
{
    _regval = (_regval & 0xfffff000);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->op, 0x14, _regval);
}

static inline int ehci_flba_reg_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_flba_reg_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ehci_flba_reg_t _regval = mackerel_read_addr_32(_dev->op, 0x14);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register flba_reg (Periodic frame list base addr): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx32 "\t(Base address (must be 4k aligned))\n", ehci_flba_reg_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t ehci_flba_reg_addr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ehci_flba_reg_addr_rdf(__DN(t) *_dev)
{
    ehci_flba_reg_t _regval = mackerel_read_addr_32(_dev->op, 0x14);
    return(ehci_flba_reg_addr_extract(_regval));
}

static inline void ehci_flba_reg_addr_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_flba_reg_addr_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    ehci_flba_reg_t _regval = 0xfffff000 & (((ehci_flba_reg_t )(_fieldval)) << 12);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xfffff000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x14, _regval);
    // No shadow register to write to
}

/*
 * Register asyn_list_reg: Current async. list addr.
 * Type: ehci.asyn_list_reg (Implicit type of Current async. list addr. register)
 *   _anon0	(size 5, offset 0, init 0):	MBZ	_
 *   lpl	(size 27, offset 5, init 0):	RW	Link pointer low
 */
static inline ehci_asyn_list_reg_t ehci_asyn_list_reg_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_asyn_list_reg_t ehci_asyn_list_reg_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x18));
}

static inline ehci_asyn_list_reg_t ehci_asyn_list_reg_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_asyn_list_reg_t ehci_asyn_list_reg_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x18));
}

static inline void ehci_asyn_list_reg_rawwr(__DN(t) *_dev, ehci_asyn_list_reg_t _regval) __attribute__ ((always_inline));
static inline void ehci_asyn_list_reg_rawwr(__DN(t) *_dev, ehci_asyn_list_reg_t _regval)
{
    mackerel_write_addr_32(_dev->op, 0x18, _regval);
}

static inline void ehci_asyn_list_reg_wr(__DN(t) *_dev, ehci_asyn_list_reg_t _regval) __attribute__ ((always_inline));
static inline void ehci_asyn_list_reg_wr(__DN(t) *_dev, ehci_asyn_list_reg_t _regval)
{
    _regval = (_regval & 0xffffffe0);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->op, 0x18, _regval);
}

static inline int ehci_asyn_list_reg_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_asyn_list_reg_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ehci_asyn_list_reg_t _regval = mackerel_read_addr_32(_dev->op, 0x18);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register asyn_list_reg (Current async. list addr.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpl =\t%" PRIx32 "\t(Link pointer low)\n", ehci_asyn_list_reg_lpl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t ehci_asyn_list_reg_lpl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ehci_asyn_list_reg_lpl_rdf(__DN(t) *_dev)
{
    ehci_asyn_list_reg_t _regval = mackerel_read_addr_32(_dev->op, 0x18);
    return(ehci_asyn_list_reg_lpl_extract(_regval));
}

static inline void ehci_asyn_list_reg_lpl_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_asyn_list_reg_lpl_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    ehci_asyn_list_reg_t _regval = 0xffffffe0 & (((ehci_asyn_list_reg_t )(_fieldval)) << 5);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xffffffe0);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x18, _regval);
    // No shadow register to write to
}

/*
 * Register config_flag: Configure flag
 * Type: ehci.config_flag (Implicit type of Configure flag register)
 *   cf	(size 1, offset 0, init 0):	RW	Configure flag
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
static inline ehci_config_flag_t ehci_config_flag_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_config_flag_t ehci_config_flag_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x40));
}

static inline ehci_config_flag_t ehci_config_flag_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_config_flag_t ehci_config_flag_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x40));
}

static inline void ehci_config_flag_rawwr(__DN(t) *_dev, ehci_config_flag_t _regval) __attribute__ ((always_inline));
static inline void ehci_config_flag_rawwr(__DN(t) *_dev, ehci_config_flag_t _regval)
{
    mackerel_write_addr_32(_dev->op, 0x40, _regval);
}

static inline void ehci_config_flag_wr(__DN(t) *_dev, ehci_config_flag_t _regval) __attribute__ ((always_inline));
static inline void ehci_config_flag_wr(__DN(t) *_dev, ehci_config_flag_t _regval)
{
    _regval = (_regval & 0x1);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->op, 0x40, _regval);
}

static inline int ehci_config_flag_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_config_flag_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ehci_config_flag_t _regval = mackerel_read_addr_32(_dev->op, 0x40);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register config_flag (Configure flag): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cf =\t%" PRIx8 "\t(Configure flag)\n", ehci_config_flag_cf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    return(_r);
}

static inline uint8_t ehci_config_flag_cf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_config_flag_cf_rdf(__DN(t) *_dev)
{
    ehci_config_flag_t _regval = mackerel_read_addr_32(_dev->op, 0x40);
    return(ehci_config_flag_cf_extract(_regval));
}

static inline void ehci_config_flag_cf_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_config_flag_cf_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_config_flag_t _regval = 0x1 & (((ehci_config_flag_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x1);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x40, _regval);
    // No shadow register to write to
}

/*
 * Register array portsc: Port status and control
 * Type: ehci.portsc (Implicit type of Port status and control register array)
 *   ccs	(size 1, offset 0, init 0):	RO	Current connect status
 *   csc	(size 1, offset 1, init 0):	RWC	Connect status change
 *   p_ed	(size 1, offset 2, init 0):	RW	Port enabled/disabled
 *   p_edc	(size 1, offset 3, init 0):	RWC	Port enable/disbale change
 *   oca	(size 1, offset 4, init 0):	RO	Over current active
 *   occ	(size 1, offset 5, init 0):	RWC	Over current change
 *   p_resume	(size 1, offset 6, init 0):	RW	Force port resume
 *   p_suspend	(size 1, offset 7, init 0):	RW	Port suspend
 *   p_reset	(size 1, offset 8, init 0):	RW	Port reset
 *   _anon9	(size 1, offset 9, init 0):	MBZ	_
 *   line_status	(size 2, offset 10, init 0):	RW	Line status value
 *   p_power	(size 1, offset 12, init 0):	RW	Port power
 *   p_owner	(size 1, offset 13, init 0):	RW	Port owner
 *   p_ic	(size 2, offset 14, init 0):	RW	Port indicator control
 *   p_tc	(size 4, offset 16, init 0):	RW	Port test control
 *   wkcnnt_e	(size 1, offset 20, init 0):	RW	Wake on connect enable
 *   wkdscnnt_e	(size 1, offset 21, init 0):	RW	Wake on disconnect enable
 *   wkoc_e	(size 1, offset 22, init 0):	RW	Wake on over-current enable
 *   _anon23	(size 9, offset 23, init 0):	MBZ	_
 */
static const size_t ehci_portsc_length = 16;
static inline ehci_portsc_t ehci_portsc_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8))));
}

static inline ehci_portsc_t ehci_portsc_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8))));
}

static inline void ehci_portsc_rawwr(__DN(t) *_dev, int _i, ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline void ehci_portsc_rawwr(__DN(t) *_dev, int _i, ehci_portsc_t _regval)
{
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
}

static inline void ehci_portsc_wr(__DN(t) *_dev, int _i, ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline void ehci_portsc_wr(__DN(t) *_dev, int _i, ehci_portsc_t _regval)
{
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
}

static inline int ehci_portsc_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int ehci_portsc_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "portsc", _i, "Port status and control");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ccs =\t%" PRIx8 "\t(Current connect status)\n", ehci_portsc_ccs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " csc =\t%" PRIx8 "\t(Connect status change)\n", ehci_portsc_csc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p_ed =\t%" PRIx8 "\t(Port enabled/disabled)\n", ehci_portsc_p_ed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p_edc =\t%" PRIx8 "\t(Port enable/disbale change)\n", ehci_portsc_p_edc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oca =\t%" PRIx8 "\t(Over current active)\n", ehci_portsc_oca_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " occ =\t%" PRIx8 "\t(Over current change)\n", ehci_portsc_occ_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p_resume =\t%" PRIx8 "\t(Force port resume)\n", ehci_portsc_p_resume_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p_suspend =\t%" PRIx8 "\t(Port suspend)\n", ehci_portsc_p_suspend_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p_reset =\t%" PRIx8 "\t(Port reset)\n", ehci_portsc_p_reset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " line_status =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_lstatus_val_prtval(_s + _r, _avail, ehci_portsc_line_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Line status value)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p_power =\t%" PRIx8 "\t(Port power)\n", ehci_portsc_p_power_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p_owner =\t%" PRIx8 "\t(Port owner)\n", ehci_portsc_p_owner_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p_ic =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_indi_val_prtval(_s + _r, _avail, ehci_portsc_p_ic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port indicator control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p_tc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_test_mode_val_prtval(_s + _r, _avail, ehci_portsc_p_tc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port test control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkcnnt_e =\t%" PRIx8 "\t(Wake on connect enable)\n", ehci_portsc_wkcnnt_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkdscnnt_e =\t%" PRIx8 "\t(Wake on disconnect enable)\n", ehci_portsc_wkdscnnt_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkoc_e =\t%" PRIx8 "\t(Wake on over-current enable)\n", ehci_portsc_wkoc_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon23 is anonymous
    return(_r);
}

static inline int ehci_portsc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_portsc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 16; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = ehci_portsc_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t ehci_portsc_ccs_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_ccs_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_ccs_extract(_regval));
}

static inline uint8_t ehci_portsc_csc_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_csc_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_csc_extract(_regval));
}

static inline uint8_t ehci_portsc_p_ed_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_p_ed_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_p_ed_extract(_regval));
}

static inline uint8_t ehci_portsc_p_edc_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_p_edc_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_p_edc_extract(_regval));
}

static inline uint8_t ehci_portsc_oca_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_oca_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_oca_extract(_regval));
}

static inline uint8_t ehci_portsc_occ_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_occ_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_occ_extract(_regval));
}

static inline uint8_t ehci_portsc_p_resume_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_p_resume_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_p_resume_extract(_regval));
}

static inline uint8_t ehci_portsc_p_suspend_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_p_suspend_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_p_suspend_extract(_regval));
}

static inline uint8_t ehci_portsc_p_reset_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_p_reset_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_p_reset_extract(_regval));
}

static inline ehci_lstatus_val_t ehci_portsc_line_status_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline ehci_lstatus_val_t ehci_portsc_line_status_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_line_status_extract(_regval));
}

static inline uint8_t ehci_portsc_p_power_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_p_power_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_p_power_extract(_regval));
}

static inline uint8_t ehci_portsc_p_owner_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_p_owner_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_p_owner_extract(_regval));
}

static inline ehci_indi_val_t ehci_portsc_p_ic_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline ehci_indi_val_t ehci_portsc_p_ic_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_p_ic_extract(_regval));
}

static inline ehci_test_mode_val_t ehci_portsc_p_tc_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline ehci_test_mode_val_t ehci_portsc_p_tc_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_p_tc_extract(_regval));
}

static inline uint8_t ehci_portsc_wkcnnt_e_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_wkcnnt_e_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_wkcnnt_e_extract(_regval));
}

static inline uint8_t ehci_portsc_wkdscnnt_e_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_wkdscnnt_e_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_wkdscnnt_e_extract(_regval));
}

static inline uint8_t ehci_portsc_wkoc_e_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_wkoc_e_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_wkoc_e_extract(_regval));
}

static inline void ehci_portsc_csc_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_csc_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ehci_portsc_t _regval = 0x2 & (((ehci_portsc_t )(_fieldval)) << 1);
    _regval = (_regval | (0x7ffdc4 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_p_ed_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_p_ed_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ehci_portsc_t _regval = 0x4 & (((ehci_portsc_t )(_fieldval)) << 2);
    _regval = (_regval | (0x7ffdc0 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_p_edc_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_p_edc_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ehci_portsc_t _regval = 0x8 & (((ehci_portsc_t )(_fieldval)) << 3);
    _regval = (_regval | (0x7ffdc4 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_occ_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_occ_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ehci_portsc_t _regval = 0x20 & (((ehci_portsc_t )(_fieldval)) << 5);
    _regval = (_regval | (0x7ffdc4 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_p_resume_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_p_resume_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ehci_portsc_t _regval = 0x40 & (((ehci_portsc_t )(_fieldval)) << 6);
    _regval = (_regval | (0x7ffd84 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_p_suspend_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_p_suspend_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ehci_portsc_t _regval = 0x80 & (((ehci_portsc_t )(_fieldval)) << 7);
    _regval = (_regval | (0x7ffd44 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_p_reset_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_p_reset_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ehci_portsc_t _regval = 0x100 & (((ehci_portsc_t )(_fieldval)) << 8);
    _regval = (_regval | (0x7ffcc4 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_line_status_wrf(__DN(t) *_dev, int _i, ehci_lstatus_val_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_line_status_wrf(__DN(t) *_dev, int _i, ehci_lstatus_val_t _fieldval)
{
    ehci_portsc_t _regval = 0xc00 & (((ehci_portsc_t )(_fieldval)) << 10);
    _regval = (_regval | (0x7ff1c4 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_p_power_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_p_power_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ehci_portsc_t _regval = 0x1000 & (((ehci_portsc_t )(_fieldval)) << 12);
    _regval = (_regval | (0x7fedc4 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_p_owner_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_p_owner_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ehci_portsc_t _regval = 0x2000 & (((ehci_portsc_t )(_fieldval)) << 13);
    _regval = (_regval | (0x7fddc4 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_p_ic_wrf(__DN(t) *_dev, int _i, ehci_indi_val_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_p_ic_wrf(__DN(t) *_dev, int _i, ehci_indi_val_t _fieldval)
{
    ehci_portsc_t _regval = 0xc000 & (((ehci_portsc_t )(_fieldval)) << 14);
    _regval = (_regval | (0x7f3dc4 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_p_tc_wrf(__DN(t) *_dev, int _i, ehci_test_mode_val_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_p_tc_wrf(__DN(t) *_dev, int _i, ehci_test_mode_val_t _fieldval)
{
    ehci_portsc_t _regval = 0xf0000 & (((ehci_portsc_t )(_fieldval)) << 16);
    _regval = (_regval | (0x70fdc4 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_wkcnnt_e_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_wkcnnt_e_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ehci_portsc_t _regval = 0x100000 & (((ehci_portsc_t )(_fieldval)) << 20);
    _regval = (_regval | (0x6ffdc4 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_wkdscnnt_e_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_wkdscnnt_e_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ehci_portsc_t _regval = 0x200000 & (((ehci_portsc_t )(_fieldval)) << 21);
    _regval = (_regval | (0x5ffdc4 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_wkoc_e_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_wkoc_e_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ehci_portsc_t _regval = 0x400000 & (((ehci_portsc_t )(_fieldval)) << 22);
    _regval = (_regval | (0x3ffdc4 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline int ehci_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device ehci (EHCI USB Controller):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_cap_length_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_hcirev_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_hcs_params_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_hccparams_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_hcspportroute_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_usb_cmd_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_usb_status_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_usb_int_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_frame_index_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_ctrl_dss_reg_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_flba_reg_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_asyn_list_reg_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_config_flag_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_portsc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device ehci\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __ehci_DEV_H
